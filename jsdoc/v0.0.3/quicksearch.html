<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_parser_assetdeclaration.js.html":{"id":"lib_parser_assetdeclaration.js.html","title":"Source: lib/parser/assetdeclaration.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/assetdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * AssetDeclaration defines the schema (aka model or class) for * an Asset. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * * @extends ClassDeclaration */ class AssetDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } } module.exports = AssetDeclaration; × Search results Close "},"lib_parser_classdeclaration.js.html":{"id":"lib_parser_classdeclaration.js.html","title":"Source: lib/parser/classdeclaration.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/classdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Field = require('./field'); const Relationship = require('./relationship'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); /** * ClassDeclaration defines the structure (model/schema) of composite data. * It is composed of a set of Fields, may have an identifying field, and may * have a super-type. * A ClassDeclaration is conceptually owned with a ModelFile which * defines all the classes that are part of a namespace. * * This class is abstract and should not be instantiated. * * @abstract */ class ClassDeclaration { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { if(!modelFile || !ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; this.modelFile = modelFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.fields = []; this.superType = null; this.idField = null; if(this.ast.classExtension) { this.superType = this.ast.classExtension.class.name; } if(this.ast.idField) { this.idField = this.ast.idField.name; } for(let n=0; n &lt; this.ast.body.declarations.length; n++ ) { let thing = this.ast.body.declarations[n]; if(thing.type === 'PropertyDeclaration') { this.fields.push( new Field(thing) ); } else if(thing.type === 'RelationshipDeclaration') { this.fields.push( new Relationship(thing) ); } else { let formatter = Globalize.messageFormatter('classdeclaration-process-unrecmodelelem'); formatter({ 'type': thing.type }); throw new IllegalModelException( formatter ); } } } /** * Semantic validation of the structure of this class. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {InvalidModelException} * @private */ validate() { // TODO (LG) check that all imported classes exist, rather than just // used imports // if we have a super type make sure it exists if(this.superType!==null) { let classDecl = null; if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } } // TODO (DCS) we need to validate that the super type is compatible // with this class. e.g. an asset cannot extend a transaction... if(this.idField) { let field = this.getField(this.idField); if(!field) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotproperty'); throw new IllegalModelException(formatter({ 'class': this.name, 'idField': this.idField })); } else { // check that identifiers are strings if(field.getType() !== 'String') { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotstring'); throw new IllegalModelException( formatter({ 'class': this.name, 'idField': this.idField })); } } } for(let n=0; n &lt; this.fields.length; n++) { let field = this.fields[n]; field.validate(this); } // TODO (DCS) -- validate that all field names are unique... } /** * Returns the short name of a class. This name does not include the * namespace from the owning ModelFile. * * @return {string} the short name of this class */ getName() { return this.name; } /** * Returns the fully qualified name of this class. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this class */ getFullyQualifiedName() { if(this.modelFile.getNamespace()) { return this.modelFile.getNamespace() + '.' + this.name; } else { return this.name; } } /** * Returns the name of the identifying field for this class. Note * that the identifying field may come from a super type. * * @return {string} the name of the id field for this class */ getIdentifierFieldName() { if(this.idField) { return this.idField; } else { if(this.getSuperType()) { let fqnImport = this.getSuperType(); if(this.modelFile.isImportedType(this.getSuperType())) { fqnImport = this.modelFile.resolveImport(this.getSuperType()); } else { // it is a local type, build the FQN if(this.modelFile.getNamespace()) { fqnImport = this.modelFile.getNamespace() + '.' + this.getSuperType(); } } let classDecl = this.modelFile.getModelManager().getType(fqnImport); return classDecl.getIdentifierFieldName(); } } } /** * Returns the field with a given name or null if it does not exist. * The field must be directly owned by this class -- the super-type is * not introspected. * * @param {string} name the name of the field * @return {Field} the field definition or null if it does not exist. */ getOwnField(name) { for(let n=0; n &lt; this.fields.length; n++) { let field = this.fields[n]; if(field.getName() === name) { return field; } } return null; } /** * Returns the fields directly defined by this class. * * @return {Field[]} the array of fields */ getOwnFields() { return this.fields; } /** * Returns the name of the super type for this class or null if this * class does not have a super type. * * @return {string} the name of the super type or null */ getSuperType() { return this.superType; } /** * Returns the field with a given name or null if it does not exist. * Fields defined in super-types are also introspected. * * @param {string} name the name of the field * @return {Field} the field, or null if it does not exist */ getField(name) { let result = this.getOwnField(name); if(result === null &amp;&amp; this.superType!==null) { // TODO (DCS) -- this assumes the super type is in the same namespace! // as this type! let classDecl = this.modelFile.getType(this.superType); result = classDecl.getField(name); } return result; } /** * Returns the fields defined in this class and all super classes. * * @return {Field[]} the array of fields */ getFields() { let result = this.fields; let classDecl = null; if(this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } result.concat(classDecl.getOwnFields()); } return result; } } module.exports = ClassDeclaration; × Search results Close "},"lib_assetregistry.js.html":{"id":"lib_assetregistry.js.html","title":"Source: lib/assetregistry.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/assetregistry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const CObject = require('./model/cobject'); const Registry = require('./registry'); const Util = require('./util'); const REGISTRY_TYPE = 'Asset'; /** * The AssetRegistry is used to manage a set of assets. * &lt;p&gt;&lt;a href=&quot;diagrams/assetregistry.svg&quot;&gt;&lt;img src=&quot;diagrams/assetregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry */ class AssetRegistry extends Registry { /** * Get a list of all existing asset registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link AssetRegistry} * instances representing the asset registries. */ static getAllAssetRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then(function (assetRegistries) { return assetRegistries.map(function (assetRegistry) { return new AssetRegistry(assetRegistry.id, assetRegistry.name, modelManager, factory, serializer); }); }); } /** * Get an existing asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the asset registry. */ static getAssetRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then(function (registry) { return new AssetRegistry(registry.id, registry.name, modelManager, factory, serializer); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {string} name The name of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the new asset registry. */ static addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(function () { return new AssetRegistry(id, name, modelManager, factory, serializer); }); } /** * Create an asset registry. * * @protected * @param {string} id The unique identifier of the asset registry. * @param {string} name The display name for the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. */ constructor(id, name, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; } /** * Adds an asset to the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {CObject} asset The asset to be added to the asset registry. * @return {Promise} A promise that is resolved when the asset is added to * the asset registry. */ add(securityContext, asset) { Util.securityCheck(securityContext); let data = this.serializer.toJSON(asset); return super.add(securityContext, asset.getIdentifier(), data); } /** * Updates an asset in the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {CObject} asset The asset to be updated in the asset registry. * @return {Promise} A promise that is resolved when the asset is updated * in the asset registry. */ update(securityContext, asset) { Util.securityCheck(securityContext); let data = this.serializer.toJSON(asset); return super.update(securityContext, asset.getIdentifier(), data); } /** * Remove an asset with a given type and id from the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {(CObject|string)} asset The asset, or the unique identifier of the asset. * @return {Promise} A promise that is resolved when the element is removed * from the registry. */ remove(securityContext, asset) { Util.securityCheck(securityContext); let id; if (asset instanceof CObject) { id = asset.getIdentifier(); } else { id = asset; } return super.remove(securityContext, id); } /** * Get all of the assets in the registry. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of {@link * CObject} instances representing the assets. */ getAll(securityContext) { Util.securityCheck(securityContext); let self = this; return super.getAll(securityContext) .then(function (resources) { return resources.map(function (resource) { return self.serializer.fromJSON(resource.data); }); }); } /** * Get a specific asset in the registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset. * @return {Promise} A promise that will be resolved with a {@link CObject} * instance representing the asset. */ get(securityContext, id) { Util.securityCheck(securityContext); let self = this; return super.get(securityContext, id) .then(function (resource) { return self.serializer.fromJSON(resource.data); }); } } module.exports = AssetRegistry; × Search results Close "},"lib_baseexception.js.html":{"id":"lib_baseexception.js.html","title":"Source: lib/baseexception.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/baseexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * A base class for all exceptions * &lt;p&gt;&lt;a href=&quot;diagrams/baseexception.svg&quot;&gt;&lt;img src=&quot;diagrams/baseexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class BaseException extends Error { /** * Create the BaseException. * @param {string} message - The exception message. */ constructor(message) { super(message); this.name = this.constructor.name; this.message = message; Error.captureStackTrace(this, this.constructor); } } module.exports = BaseException; × Search results Close "},"lib_model_cbase.js.html":{"id":"lib_model_cbase.js.html","title":"Source: lib/model/cbase.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/model/cbase.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * Base is an entity with a namespace, type and an identifier. * It is used in Concerto to represent Assets and other classes that can be * serialized for long-term persistent storage. * * This class is abstract. * @abstract */ class CBase { /** * Use the Factory to create instances. * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { this.modelManager = modelManager; this.namespace = ns; this.identifier = id; this.type = type; } /** * Get the identifier of this instance * @return {string} The identifier for this object */ getIdentifier() { return this.identifier; } /** * Get the fully qualified identifier of this instance. * (namespace '.' type '#' identifier) or (type '#' identifier). * @return {string} the fully qualified identifier of this instance */ getFullyQualifiedIdentifier() { return this.getFullyQualifiedType() + '#' + this.identifier; } /** * Get the type of the instance (a short name, not including namespace). * @return {string} The type of this object */ getType() { return this.type; } /** * Get the fully-qualified type name of the instance (including namespace). * @return {string} The fully-qualified type name of this object */ getFullyQualifiedType() { if(this.namespace) { return this.namespace + '.' + this.type; } else { return this.type; } } /** * Get the namespace of the instance. * @return {string} The namespace of this object */ getNamespace() { return this.namespace; } } module.exports = CBase; × Search results Close "},"lib_model_cobject.js.html":{"id":"lib_model_cobject.js.html","title":"Source: lib/model/cobject.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/model/cobject.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const CBase = require('./cbase'); const CRelationship = require('./crelationship'); const Field = require('../parser/field'); const Relationship = require('../parser/relationship'); /** * CObject is an instance that is associated with a ClassDeclaration and * that has a set of Fields that are defined by the ClassDeclaration. * * It is used in Concerto to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * @extends Base */ class CObject extends CBase { /** * This constructor should not be called directly. * Use the Factory class to create instances. * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setFieldValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getField(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } CObject.validateField(this.getIdentifier(), field, value); this[propName] = value; } /** * Sets the fields to their default values, based on the model * @private */ assignFieldDefaults() { let classDeclaration = this.getClassDeclaration(); let fields = classDeclaration.getFields(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field) { let defaultValue = field.getDefaultValue(); if (defaultValue) { if (field.getType() === 'String') { this.setFieldValue(field.getName(), defaultValue); } else if (field.getType() === 'Integer') { this.setFieldValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Long') { this.setFieldValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Double') { this.setFieldValue(field.getName(), parseFloat(defaultValue)); } else if (field.getType() === 'Boolean') { this.setFieldValue(field.getName(), (defaultValue === 'true')); } else if (field.getType() === 'DateTime') { this.setFieldValue(field.getName(), Date.parse(defaultValue)); } } } } } /** * Returns the class declaration for this instance object. * * @return {ClassDeclaration} - the class declaration for this CObject * @throws {Error} - if the class or namespace for the instance is not declared * @private */ getClassDeclaration() { // do we have a model file? let modelFile = this.modelManager.getModelFile(this.getNamespace()); if (!modelFile) { throw new Error('No model for namespace ' + this.getNamespace() + ' is registered with the ModelManager'); } // do we have a class? let classDeclaration = modelFile.getType(this.getType()); if (!classDeclaration) { throw new Error('The namespace ' + this.getNamespace() + ' does not contain the type ' + this.getType()); } return classDeclaration; } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model * @private */ validate() { let classDeclaration = this.getClassDeclaration(); // check all the properties are declared let props = Object.getOwnPropertyNames(this); for (let n = 0; n &lt; props.length; n++) { let propName = props[n]; // we don't validate system properties - TODO (DCS) if (['modelManager', 'namespace', 'identifier', 'type'].indexOf(propName) &lt; 0) { let field = classDeclaration.getField(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' has a field named ' + propName + ' which is not declared in the model.'); } // validate the data agains the field from the model let data = this[propName]; CObject.validateField(this.getIdentifier(), field, data); } } // are there any missing non-optional fields? let fields = classDeclaration.getFields(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field &amp;&amp; field.isOptional() === false) { if (this.hasOwnProperty(field.getName()) === false || this[field.getName()] === null) { CObject.reportMissingRequiredField(this.getIdentifier(), field); } } } } /** * Validates a field / data combination against the model * * @param {string} id - the identifier of this instance. * @param {Field} field - the field * @param {*} data - the data to validate against the field * @throws {Error} - if the data is invalid with respect to the field * @private */ static validateField(id, field, data) { let dataType = typeof data; let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol' || dataType === 'function') { CObject.reportModelViolation(id, propName, data, field); } if (data !== null) { if (field.isArray() === false) { if (field instanceof Field) { switch (field.getType()) { case 'Integer': case 'Double': case 'Long': if (dataType !== 'number') { CObject.reportModelViolation(id, propName, data, field); } break; case 'Boolean': if (dataType !== 'boolean') { CObject.reportModelViolation(id, propName, data, field); } break; case 'DateTime': if (data instanceof Date === false) { CObject.reportModelViolation(id, propName, data, field); } break; case 'String': if (dataType !== 'string') { CObject.reportModelViolation(id, propName, data, field); } break; default: //CObject.reportModelViolation(id, propName, data, field ); } } else if (field instanceof Relationship) { if (data instanceof CRelationship === false) { CObject.reportModelViolation(id, propName, data, field); } } else { CObject.reportModelViolation(id, propName, data, field); } } else { // an array type if (dataType !== 'object') { // TODO (DCS) we don't yet verify the contents of the array! CObject.reportModelViolation(id, propName, data, field); } } } // data !== null } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {string} propName - the name of the field. * @param {*} value - the value of the field. * @param {Field} field - the field/ * @private */ static reportModelViolation(id, propName, value, field) { let isArray = field.isArray() ? '[]' : ''; throw new Error('Model violation in instance ' + id + ' field ' + propName + ' has value ' + value + ' (' + typeof value + ') expected type ' + field.getType() + isArray); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field/ * @private */ static reportMissingRequiredField(id, field) { throw new Error('Instance ' + id + ' missing required field ' + field.getName()); } } module.exports = CObject; × Search results Close "},"lib_model_crelationship.js.html":{"id":"lib_model_crelationship.js.html","title":"Source: lib/model/crelationship.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/model/crelationship.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const CBase = require('./cbase'); /** * A Relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @extends Base */ class CRelationship extends CBase { /** * Create an asset. Use the Factory to create instances. * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } } module.exports = CRelationship; × Search results Close "},"lib_codegen_filewriter.js.html":{"id":"lib_codegen_filewriter.js.html","title":"Source: lib/codegen/filewriter.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/codegen/filewriter.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const fs = require('fs'); const mkdirp = require('mkdirp'); const path = require('path'); /** * Writes output to a file. */ class FileWriter { /** * Create a FileWriter. * * @param {string} outputDirectory - the ModelManager that manages this * ModelFile */ constructor(outputDirectory) { this.outputDirectory = outputDirectory; this.relativeDir = null; this.beforeBuffer = ''; this.buffer = ''; this.fileName = null; this.linesWritten = 0; if (!fs.existsSync(outputDirectory)) { mkdirp.sync(outputDirectory); } } /** * Opens a file for writing * @param {string} fileName - the name of the file to open */ openFile(fileName) { this.fileName = fileName; this.relativeDir = null; } /** * Opens a file for writing * @param {string} relativeDir - the relative directory to use * @param {string} fileName - the name of the file to open */ openRelativeFile(relativeDir, fileName) { this.relativeDir = relativeDir; this.fileName = fileName; } /** * Writes text to the start of the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { if (this.fileName) { for(let n=0; n &lt; tabs; n++) { this.beforeBuffer += ' '; } this.beforeBuffer += text; this.beforeBuffer += '\\n'; this.linesWritten++; } else { throw Error('File has not been opened!'); } } /** * Writes text to the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { if (this.fileName) { for(let n=0; n &lt; tabs; n++) { this.buffer += ' '; } this.buffer += text; this.buffer += '\\n'; this.linesWritten++; } else { throw Error('File has not been opened!'); } } /** * Closes the current open file */ closeFile() { if (!this.fileName) { throw new Error('No file open'); } let path = this.outputDirectory; if(!path.endsWith('/')) { path += '/'; } if (this.relativeDir) { path += this.relativeDir; } if(!path.endsWith('/')) { path += '/'; } path += this.fileName; ensureDirectoryExistence(path); console.log('Writing to ' + path ); fs.writeFileSync(path, this.beforeBuffer + this.buffer); this.fileName = null; this.beforeBuffer = ''; this.buffer = ''; this.RelativeDir = null; } } /** * * @param {string} filePath - the file path to check * @return {boolean} true if the directory exists */ function ensureDirectoryExistence(filePath) { let dirname = path.dirname(filePath); if (directoryExists(dirname)) { return true; } ensureDirectoryExistence(dirname); fs.mkdirSync(dirname); return false; } /** * @param {string} path - the file path to check * @return {boolean} true if the directory exists */ function directoryExists(path) { try { return fs.statSync(path).isDirectory(); } catch (err) { return false; } } module.exports = FileWriter; × Search results Close "},"lib_factory.js.html":{"id":"lib_factory.js.html","title":"Source: lib/factory.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/factory.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const CObject = require('./model/cobject'); const CRelationship = require('./model/crelationship'); const Util = require('./util'); const debug = require('debug')('ibm-concerto'); const Globalize = require('./globalize'); /** * Use the Factory to create instances of CObject. An instance of this class * can be retrieved from the Concerto class. * &lt;p&gt;&lt;a href=&quot;diagrams/factory.svg&quot;&gt;&lt;img src=&quot;diagrams/factory.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class Factory { /** * Create the factory. This class should not be called by solutions. * @param {ModelManager} modelManager - The ModelManager to use for this registry */ constructor(modelManager) { this.modelManager = modelManager; } /** * Create a new CObject with a given namespace, type name and id * @param {SecurityContext} securityContext - The user's security context * @param {string} ns - the namespace of the CObject * @param {string} type - the type of the CObject * @param {string} id - the identifier * @return {CObject} - the new instance * @throws {ModelException} if the type is not registered with the ModelManager */ newInstance(securityContext, ns, type, id) { Util.securityCheck(securityContext); let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newinstance-notregisteredwithmm'); throw new Error(formatter({ namespace: 'foo' })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let newObj = new CObject(this.modelManager,ns,type,id); newObj.assignFieldDefaults(); let classDecl = modelFile.getType(type); // if we have an identifier, we set it now let idField = classDecl.getIdentifierFieldName(); if(idField) { newObj[idField] = id; } debug('Factory.newInstance created %s', id ); return newObj; } /** * Create a new Relationship with a given namespace, type and identifier. ` * A relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @param {SecurityContext} securityContext - The user's security context * @param {string} ns - the namespace of the CObject * @param {string} type - the type of the CObject * @param {string} id - the identifier * @return {Relationship} - the new relationship instance * @throws {ModelException} if the type is not registered with the ModelManager */ newRelationship(securityContext, ns, type, id) { Util.securityCheck(securityContext); let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newrelationship-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let relationship = new CRelationship(this.modelManager,ns,type,id); return relationship; } } module.exports = Factory; × Search results Close "},"lib_parser_field.js.html":{"id":"lib_parser_field.js.html","title":"Source: lib/parser/field.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/field.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Property = require('./property'); /** * Class representing the definition of a Field. A Field is owned * by a ClassDeclaration and has a name, type and additional metadata * (see below). * @extends Property */ class Field extends Property { /** * Create an Field. * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(ast) { super(ast); } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { super.process(); if(this.ast.validator) { this.validator = this.ast.validator.text.value; } if(this.ast.default) { this.defaultValue = this.ast.default.text.value; } if(this.ast.optional) { this.optional = true; } else { this.optional = false; } } /** * Returns the validator string for this field * @return {string} the validator for the field or null */ getValidator() { return this.validator; } /** * Returns true if the field is optional * @return {boolean} true if the field is optional */ isOptional() { return this.optional; } /** * Returns the default value for the field or null * @return {string} the default value for the field or null */ getDefaultValue() { if(this.defaultValue) { return this.defaultValue; } else { return null; } } } module.exports = Field; × Search results Close "},"lib_parser_property.js.html":{"id":"lib_parser_property.js.html","title":"Source: lib/parser/property.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/property.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * Property representing an attribute of a class declaration, * either a Field or a Relationship. */ class Property { /** * Create a Property. * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(ast) { this.ast = ast; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.type = this.ast.propertyType.name; this.array = false; if(this.ast.array) { this.array = true; } } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { classDecl.getModelFile().resolveType('Property type ' + this.name, this.type); } /** * Returns the name of a field * @return {string} the name of this field */ getName() { return this.name; } /** * Returns the type of a field * @return {string} the type of this field */ getType() { return this.type; } /** * Returns true if the field is declared as an array type * @return {boolean} true if the field is an array type */ isArray() { return this.array; } } module.exports = Property; × Search results Close "},"lib_codegen_umlgen.js.html":{"id":"lib_codegen_umlgen.js.html","title":"Source: lib/codegen/umlgen.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/codegen/umlgen.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const fs = require('fs'); const path = require('path'); const program = require('commander'); const acorn = require('acorn'); const FileWriter = require('./filewriter'); /** * Generates Plant UML files from Javascript source files * * node ./lib/codegen/umlgen.js * --outputDir &lt;location to write UML files&gt; * --inputDir &lt;location to recursively read .js files&gt; */ program .version('0.0.1') .description('Generates PlantUML model files from Javascript source') .usage('[options]') .option('-o, --outputDir &lt;outputDir&gt;', 'Output directory') .option('-i, --inputDir &lt;inputDir&gt;', 'Input source directory') .parse(process.argv); // Loop through all the files in the input directory processDirectory(program.inputDir); /** * @param {string} path - the path to process */ function processDirectory(path) { fs.readdir(path, function(err, files) { if (err) { console.error('Could not list the directory.', err); process.exit(1); } files.forEach(function(file, index) { console.log('stat on: ' + file); let stats = fs.statSync(path + '/' + file); if (stats.isFile()) { processFile(path + '/' + file); } else if (stats.isDirectory()) { processDirectory(path + '/' + file); } }); }); } /** * @param {string} file - the file to process */ function processFile(file) { let filePath = path.parse(file); if (filePath.ext === '.js') { console.log('%s is a file.', file); let fileContents = fs.readFileSync(file, 'utf8'); let comments = [], tokens = []; let ast = acorn.parse(fileContents, { // collect ranges for each node ranges: true, // collect comments in Esprima's format onComment: comments, // collect token ranges onToken: tokens }); let fileWriter = new FileWriter(program.outputDir); console.log('open file: ' + toUMLFilename(program.inputDir, program.outputDir, file)); fileWriter.openFile(toUMLFilename(program.inputDir, program.outputDir, file)); fileWriter.writeBeforeLine(0, '@startuml'); let classExists = ast.body.find((statement) =&gt; { return statement.type === 'ClassDeclaration'; }) !== undefined; if (!classExists) { fileWriter.writeLine(0, 'class ' + filePath.name + ' &lt;&lt; (P,orchid) &gt;&gt; {'); } for (let n = 0; n &lt; ast.body.length; n++) { let statement = ast.body[n]; if (statement.type === 'VariableDeclaration') { let variableDeclarations = statement.declarations; for (let n = 0; n &lt; variableDeclarations.length; n++) { let variableDeclaration = variableDeclarations[n]; if (variableDeclaration.init.type === 'CallExpression' &amp;&amp; variableDeclaration.init.callee.name === 'require') { let requireName = variableDeclaration.init.arguments[0].value; // we only care about the code we require with a relative path if (requireName.startsWith('./')) { fileWriter.writeBeforeLine(0, '!include ' + variableDeclaration.init.arguments[0].value + '.uml'); } } } } else if (statement.type === 'ClassDeclaration') { fileWriter.writeLine(0, 'class ' + statement.id.name + '{'); for(let n=0; n &lt; statement.body.body.length; n++) { let thing = statement.body.body[n]; if (thing.type === 'MethodDefinition') { let closestComment = findCommentBefore(thing.key.start, thing.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = '()'; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = getReturnType(comment); visibility = getVisibility(comment); methodArgs = getMethodArguments(comment); } fileWriter.writeLine(1, visibility + ' ' + returnType + ' ' + thing.key.name + methodArgs ); } } fileWriter.writeLine(0, '}'); if (statement.superClass) { fileWriter.writeLine(0, statement.id.name + ' --|&gt; ' + statement.superClass.name); } } else if (statement.type === 'MethodDefinition') { let closestComment = findCommentBefore(statement.key.start, statement.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = '()'; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = getReturnType(comment); visibility = getVisibility(comment); methodArgs = getMethodArguments(comment); } fileWriter.writeLine(1, visibility + ' ' + returnType + ' ' + statement.key.name + methodArgs ); } } if (!classExists) { fileWriter.writeLine(0, '}'); } fileWriter.writeLine(0, '@enduml'); // Only close and write the file if we wrote more than the @startuml/@enduml tags. if (fileWriter.linesWritten &gt; 2) { fileWriter.closeFile(); } else { console.error('not writing output file; did not find anything useful to write'); process.exit(2); } } } /** * Find the comments that is above and closest to the start of the range. * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string[]} comments - the end of the range * @return {integer} the comment index or -1 if there are no comments */ function findCommentBefore(rangeStart, rangeEnd, comments) { let foundIndex = -1; let distance = -1; for(let n=0; n &lt; comments.length; n++) { let comment = comments[n]; let endComment = comment.end; if(rangeStart &gt; endComment ) { if(distance === -1 || rangeStart - endComment &lt; distance) { distance = rangeStart - endComment; foundIndex = n; } } } return foundIndex; } /** * @param {string} inputDir - the fully qualified input directory * @param {string} outputDir - the fully qualified output directory * @param {string} filename - the fully qualified input file name (.js) * @return {string} the UML file name to use */ function toUMLFilename(inputDir, outputDir, filename) { console.log('inputDir' + inputDir); console.log('outputDir' + outputDir); console.log('filename' + filename); let index = filename.indexOf(inputDir); console.log('index ' + index); let rest = filename.substr(index + 1 + inputDir.length); // let out = outputDir + '/' + rest; let i = rest.lastIndexOf('.'); // console.log('result' + out.substr(0, i) + '.uml' ); return (i &lt; 0) ? '' : rest.substr(0, i) + '.uml'; } /** * Visitor design pattern * @param {Relationship} relationship - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ /** * Extracts the method visibilty from a comment block * @param {string} comment - the comment block * @return {string} the return visibility (either + for public, or - for private) */ function getVisibility(comment) { const PRIVATE = '@private'; let result = '+'; let index = comment.indexOf(PRIVATE); if(index&gt;=0) { result = '-'; } return result; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment */ function getReturnType(comment) { const RETURN = '@return {'; let result = 'void'; let index = comment.indexOf(RETURN); if(index&gt;=0) { let end = comment.indexOf('}', index+RETURN.length+1); if(end &gt; index) { result = comment.substring(index + RETURN.length, end); } } return result; } /** * Extracts the method arguments from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types */ function getMethodArguments(comment) { const PARAM = '@param {'; let paramTypes = []; let index = comment.indexOf(PARAM); while(index&gt;=0) { let end = comment.indexOf('}', index+PARAM.length+1); if(end &gt; index) { let aParam = comment.substring(index + PARAM.length, end); paramTypes.push(aParam); } index = comment.indexOf(PARAM, end); } let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } × Search results Close "},"lib_codegen_golang_golangvisitor.js.html":{"id":"lib_codegen_golang_golangvisitor.js.html","title":"Source: lib/codegen/golang/golangvisitor.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/codegen/golang/golangvisitor.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelUtil = require('../../modelutil'); const ModelManager = require('../../modelmanager'); const ModelFile = require('../../parser/modelfile'); const ClassDeclaration = require('../../parser/classdeclaration'); const Field = require('../../parser/field'); const Relationship = require('../../parser/relationship'); const _ = require('underscore'); /** * Convert the contents of a ModelManager to Go Lang code. * All generated code is placed into the 'main' package. Set a * fileWriter property (instance of FileWriter) on the parameters * object to control where the generated code is written to disk. */ class GoLangVisitor { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ModelManager) { return this.visitModelManager(thing, parameters); } else if (thing instanceof ModelFile) { return this.visitModelFile(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else if (thing instanceof Relationship) { return this.visitRelationship(thing, parameters); } else { throw new Error('Unrecognised!'); } } /** * Visitor design pattern * @param {ModelManager} modelManager - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelManager(modelManager, parameters) { parameters.fileWriter.openFile('main.go'); parameters.fileWriter.writeLine(0, 'package main'); parameters.fileWriter.writeLine(0, 'import \\&quot;fmt\\&quot;'); parameters.fileWriter.writeLine(0, 'func main() {'); parameters.fileWriter.writeLine(1, 'fmt.Printf(\\&quot;Hello, world.\\&quot;)'); parameters.fileWriter.writeLine(0, '}'); parameters.fileWriter.closeFile(); let visitModelFile = function(modelFile) { modelFile.accept(this,parameters); }; _.each(modelManager.getModelFiles(), visitModelFile.bind(this)); return null; } /** * Visitor design pattern * @param {ModelFile} modelFile - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelFile(modelFile, parameters) { // we put all the code into the main package, but we // seperate out into multiple files using the namespaces let packageName = this.toGoPackageName(modelFile.getNamespace()); parameters.fileWriter.openFile(packageName + '.go'); parameters.fileWriter.writeLine(0, 'package main'); if(this.containsDateTimeField(modelFile)) { parameters.fileWriter.writeLine(0, 'import \\&quot;time&quot;' ); } let visitClass = function(classDeclaration) { classDeclaration.accept(this,parameters); }; _.each(modelFile.getAllDeclarations(), visitClass.bind(this)); parameters.fileWriter.closeFile(); return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'type ' + classDeclaration.getName() + ' struct {' ); //embed the super-type, because Go Lang does not have 'extends' if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(1, classDeclaration.getSuperType()); } let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getFields(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { let array = ''; if(field.isArray()) { array = '[]'; } // we export all fields by capitalizing them parameters.fileWriter.writeLine(1, ModelUtil.capitalizeFirstLetter(field.getName()) + ' ' + array + this.toGoType(field.getType()) + ' `json:&quot;' + field.getName() + '&quot;`' ); return null; } /** * Visitor design pattern * @param {Relationship} relationship - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationship(relationship, parameters) { let array = ''; if(relationship.isArray()) { array = '[]'; } // we export all relationships by capitalizing them parameters.fileWriter.writeLine(1, ModelUtil.capitalizeFirstLetter(relationship.getName()) + ' ' + array + 'string `json:&quot;' + relationship.getName() + '&quot;`' ); return null; } /** * Returns true if the ModelFile contains a class that has a DateTime * field. * @param {ModelFile} modelFile - the modelFile * @return {boolean} true if the modelFile contains a class that contains * a field of type DateTime. * @private */ containsDateTimeField(modelFile) { let classDeclarations = modelFile.getAllDeclarations(); for(let n=0; n &lt; classDeclarations.length; n++) { let classDecl = classDeclarations[n]; let fields = classDecl.getFields(); for(let i=0; i &lt; fields.length; i++) { let field = fields[i]; if(field.getType() === 'DateTime') { return true; } } } return false; } /** * Converts a Concerto type to a Go Lang type. Primitive types are converted * everything else is passed through unchanged. * @param {string} type - the concerto type * @return {string} the corresponding type in Go Lang * @private */ toGoType(type) { switch(type) { case 'DateTime': return 'time.Time'; case 'Boolean': return 'bool'; case 'String': return 'string'; case 'Double': return 'float64'; case 'Long': return 'int64'; case 'Integer': return 'int32'; default: return type; } } /** * Converts a Concerto namespace to a Go package name. * @param {string} namespace - the concerto type * @return {string} the corresponding package name in Go Lang * @private */ toGoPackageName(namespace) { return namespace.replace('.', ''); } } module.exports = GoLangVisitor; × Search results Close "},"lib_parser_illegalmodelexception.js.html":{"id":"lib_parser_illegalmodelexception.js.html","title":"Source: lib/parser/illegalmodelexception.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/illegalmodelexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('../baseexception'); /** Class throws when a model is invalid */ class IllegalModelException extends BaseException { /** * Create an IllegalModelException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = IllegalModelException; × Search results Close "},"lib_parser_modelfile.js.html":{"id":"lib_parser_modelfile.js.html","title":"Source: lib/parser/modelfile.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/modelfile.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const parser = require('./parser'); const AssetDeclaration = require('./assetdeclaration'); const ParticipantDeclaration = require('./participantdeclaration'); const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); const Globalize = require('../globalize'); const JSON2 = require('JSON2'); /** * Class representing a Model File. A Model File contains a single namespace * and a set of model elements: assets, transactions etc. */ class ModelFile { /** * Convert the specified JSON into an instance of a model file. * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} json - A serialized instance of a ModelFile. * @return {ModelFile} An instance of a model file. */ static fromJSON(modelManager, json) { let temp = JSON2.parse(json); return new ModelFile(modelManager, temp.id, temp.name, temp.definitions); } /** * Create a ModelFile. This should only be called by framework code. * Use the ModelManager to manage ModelFiles. * * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} id - The unique identifier of the model as a string. * @param {string} name - The name of the model as a string. * @param {string} definitions - The DSL model as a string. * @throws {InvalidModelException} */ constructor(modelManager, id, name, definitions) { this.modelManager = modelManager; this.declarations = []; this.imports = []; if (!id || typeof id !== 'string') { throw new Error('ModelFile expects a id as a string as input.'); } else if (!name || typeof name !== 'string') { throw new Error('ModelFile expects a name as a string as input.'); } else if(!definitions || typeof definitions !== 'string') { throw new Error('ModelFile expects a Concerto model as a string as input.'); } this.id = id; this.name = name; this.definitions = definitions; this.ast = parser.parse(definitions); this.namespace = this.ast.namespace; if(this.ast.imports) { this.imports = this.ast.imports; } for(let n=0; n &lt; this.ast.body.length; n++ ) { let thing = this.ast.body[n]; if(thing.type === 'AssetDeclaration') { this.declarations.push( new AssetDeclaration(this, thing) ); } else if(thing.type === 'TransactionDeclaration') { this.declarations.push( new TransactionDeclaration(this, thing) ); } else if(thing.type === 'ParticipantDeclaration') { this.declarations.push( new ParticipantDeclaration(this, thing) ); } else { let formatter = Globalize('en').messageFormatter('modelfile-constructor-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type, })); } } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this ModelFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Returns the types that have been imported into this ModelFile. * * @return {string[]} The array of imports for this ModelFile */ getImports() { return this.imports; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; classDeclaration.validate(); } } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - a short type name * @throws {IllegalModelException} - if the type is not defined * @return {string} type - the FQN of the type * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { let formatter = Globalize('en').messageFormatter('modelfile-resolvetype-undecltype'); throw new IllegalModelException(formatter({ 'type': type, 'context': context })); } } else { // check whether type is defined in another file this.getModelManager().resolveType(context,this.resolveImport(type)); } } else { return type; } } /** * Returns true if the type is defined in this namespace. * @param {string} type - the short name of the type * @return {boolean} - true if the type is defined in this ModelFile * @private */ isLocalType(type) { let result = (this.getType(type) !== null); //console.log('isLocalType ' + this.getNamespace() + ' ' + type + '=' + result ); return result; } /** * Returns true if the type is imported from another namespace * @param {string} type - the short name of the type * @return {boolean} - true if the type is imported from another namespace * @private */ isImportedType(type) { //console.log('isImportedType ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return true; } } return false; } /** * Returns the FQN for a type that is imported from another namespace * @param {string} type - the short name of the type * @return {string} - the FQN of the resolved import * @throws {Error} - if the type is not imported * @private */ resolveImport(type) { //console.log('resolveImport ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return importName; } } let formatter = Globalize('en').messageFormatter('modelfile-resolveimport-failfindimp'); throw new IllegalModelException(formatter({ 'type': type, 'imports': this.imports, 'namespace': this.getNamespace() })); } /** * Returns true if the type is defined in the model file * @param {string} type the name of the type * @return {boolean} true if the type (asset or transaction) is defined */ isDefined(type) { return this.getType(type) !== null; } /** * Returns the type with the specified name or null * @param {string} type the short OR FQN name of the type * @return {ClassDeclaration} the ClassDeclaration, or null if the type does not exist */ getType(type) { if(!type.startsWith(this.getNamespace())) { type = this.getNamespace() + '.' + type; } for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(type === this.getNamespace() + '.' + classDeclaration.getName() ) { return classDeclaration; } } return null; } /** * Get the AssetDeclarations defined in this ModelFile or null * @param {string} name the name of the type * @return {AssetDeclaration} the AssetDeclaration with the given short name */ getAssetDeclaration(name) { let classDeclaration = this.getType(name); if(classDeclaration instanceof AssetDeclaration) { return classDeclaration; } return null; } /** * Get the TransactionDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {TransactionDeclaration} the TransactionDeclaration with the given short name */ getTransactionDeclaration(name) { let classDeclaration = this.getType(name); if(classDeclaration instanceof TransactionDeclaration) { return classDeclaration; } return null; } /** * Get the ParticipantDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {ParticipantDeclaration} the ParticipantDeclaration with the given short name */ getParticipantDeclaration(name) { let classDeclaration = this.getType(name); if(classDeclaration instanceof ParticipantDeclaration) { return classDeclaration; } return null; } /** * Get the Namespace for this model file. * @return {string} The Namespace for this model file */ getNamespace() { return this.namespace; } /** * Get the AssetDeclarations defined in this ModelFile * @return {AssetDeclaration[]} the AssetDeclarations defined in the model file */ getAssetDeclarations() { return this.getDeclarations(AssetDeclaration); } /** * Get the TransactionDeclarations defined in this ModelFile * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model file */ getTransactionDeclarations() { return this.getDeclarations(TransactionDeclaration); } /** * Get the ParticipantDeclarations defined in this ModelFile * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model file */ getParticipantDeclarations() { return this.getDeclarations(ParticipantDeclaration); } /** * Get the instances of a given type in this ModelFile * @param {Function} type - the type of the declaration * @return {ClassDeclaration[]} the ClassDeclaration defined in the model file */ getDeclarations(type) { let result = []; for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(classDeclaration instanceof type) { result.push(classDeclaration); } } return result; } /** * Get all declarations in this ModelFile * @return {ClassDeclaration[]} the ClassDeclarations defined in the model file */ getAllDeclarations() { return this.declarations; } /** * Get the unique identifier of this model. * @return {string} The unique identifier of this model. */ getIdentifier() { return this.id; } /** * Get the name of this model. * @return {string} The name of this model. */ getName() { return this.name; } /** * Get the definitions for this model. * @return {string} The definitions for this model. */ getDefinitions() { return this.definitions; } /** * Convert this model file into an object that is suitable for converting * into a JSON string for serialization purposes. * @return {Object} An object suitable for converting into a JSON string. */ toJSON() { let result = JSON2.decycle(this); delete result.modelManager; return result; } /** * Convert this model file into a JSON string for serialization purposes. * @return {string} A JSON string. */ toJSONString() { return JSON2.stringify(this.toJSON()); } } module.exports = ModelFile; × Search results Close "},"lib_modelmanager.js.html":{"id":"lib_modelmanager.js.html","title":"Source: lib/modelmanager.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/modelmanager.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelUtil = require('./modelutil'); const ModelFile = require('./parser/modelfile'); const IllegalModelException = require('./parser/illegalmodelexception'); const Globalize = require('./globalize'); /** * The ModelManager manages a set of ModelFiles. Each ModelFile has a single * namespace and defines a set of classes (assets, transactions, participants). * &lt;p&gt;&lt;a href=&quot;diagrams/modelmanager.svg&quot;&gt;&lt;img src=&quot;diagrams/modelmanager.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class ModelManager { /** * Create the ModelUtil. This should only be called by the framework. * Instances should be retrieved from the Concerto module. */ constructor() { this.modelFiles = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an model from a DSL model file as a string. * @param {string} id - The unique identifier of the model * @param {string} name - The name of the model * @param {string} definitions - The model DSL as a string * @throws {InvalidModelException} */ addModelFile(id, name, definitions) { let m = new ModelFile(this, id, name, definitions); m.validate(); this.modelFiles[m.getNamespace()] = m; } /** * Add an existing set of model files to the model manager. * @param {ModelFile[]} modelFiles - The list of model files. */ addModelFiles(modelFiles) { let self = this; let originalModelFiles = {}; Object.assign(originalModelFiles, this.modelFiles); modelFiles.forEach((modelFile) =&gt; { self.modelFiles[modelFile.getNamespace()] = modelFile; }); try { for (let ns in this.modelFiles) { this.modelFiles[ns].validate(); } } catch (e) { this.modelFiles = originalModelFiles; throw e; } } /** * Get the array of model file instances * @return {ModelFile[]} The ModelFiles registered */ getModelFiles() { let keys = Object.keys(this.modelFiles); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.modelFiles[keys[n]]); } return result; } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - a short type name * @return {string} - the resolved type name (fully qualified) * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-nonsfortype'); throw new IllegalModelException(formatter({ type: type, context: context })); } if(!modelFile.isLocalType(type)) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-notypeinnsforcontext'); throw new IllegalModelException(formatter({ context: context, type: type, namespace: modelFile.getNamespace() })); } else { return modelFile.getNamespace() + '.' + type; } } else { return type; } } /** * Remove all registered model files */ clearModelFiles() { this.modelFiles = {}; } /** * Get the ModelFile associated with a namespace * @param {string} namespace - the namespace containing the ModelFile * @return {ModelFile} registered ModelFile for the namespace or null */ getModelFile(namespace) { return this.modelFiles[namespace]; } /** * Look up a type in all registered namespaces (ModelFiles). * * @param {string} type - the fully qualified name of a type * @return {ClassDeclaration} - the class declaration or null for primitive types * @throws {Error} - if the type cannot be found */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new Error(formatter({ type: type })); } let classDecl = modelFile.getType(type); if(!classDecl) { throw new Error( 'No type ' + type + ' in namespace ' + modelFile.getNamespace() ); } return classDecl; } else { return null; } } } module.exports = ModelManager; × Search results Close "},"lib_modelregistry.js.html":{"id":"lib_modelregistry.js.html","title":"Source: lib/modelregistry.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/modelregistry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelFile = require('./parser/modelfile'); const Registry = require('./registry'); const Util = require('./util'); const REGISTRY_TYPE = 'Model'; /** * The ModelRegistry is used to manage a set of models. * &lt;p&gt;&lt;a href=&quot;diagrams/modelregistry.svg&quot;&gt;&lt;img src=&quot;diagrams/modelregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry */ class ModelRegistry extends Registry { /** * Get a list of all existing model registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link ModelRegistry} * instances representing the asset registries. */ static getAllModelRegistries(securityContext, modelManager) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then(function (modelRegistries) { return modelRegistries.map(function (modelRegistry) { return new ModelRegistry(modelRegistry.id, modelRegistry.name, modelManager); }); }); } /** * Get an existing model registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. * @return {Promise} A promise that will be resolved with a {@link ModelRegistry} * instance representing the model registry. */ static getModelRegistry(securityContext, id, modelManager) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then(function (modelRegistry) { return new ModelRegistry(modelRegistry.id, modelRegistry.name, modelManager); }); } /** * Add a new model registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model registry. * @param {string} name The name of the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. * @return {Promise} A promise that will be resolved with a {@link ModelRegistry} * instance representing the new model registry. */ static addModelRegistry(securityContext, id, name, modelManager) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(function () { return new ModelRegistry(id, name, modelManager); }); } /** * Create an model registry. * * @protected * @param {string} id The unique identifier of the model registry. * @param {string} name The display name for the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. */ constructor(id, name, modelManager) { super(REGISTRY_TYPE, id, name); if (!modelManager) { throw new Error('modelManager not specified'); } this.modelManager = modelManager; } /** * Adds a model to the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelFile} model The model to be added to the model registry. * @return {Promise} A promise that is resolved when the model is added to * the model registry. */ add(securityContext, model) { Util.securityCheck(securityContext); return super.add(securityContext, model.getIdentifier(), model.toJSONString()); } /** * Updates an model in the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelFile} model The model to be updated in the model registry. * @return {Promise} A promise that is resolved when the model is updated * in the model registry. */ update(securityContext, model) { Util.securityCheck(securityContext); return super.update(securityContext, model.getIdentifier(), model.toJSONString()); } /** * Remove an model with a given type and id from the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {(ModelFile|string)} model The model, or the unique identifier of the model. * @return {Promise} A promise that is resolved when the element is removed * from the registry. */ remove(securityContext, model) { Util.securityCheck(securityContext); let id; if (model instanceof ModelFile) { id = model.getIdentifier(); } else { id = model; } return super.remove(securityContext, id); } /** * Get all of the models in the registry. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of {@link * ModelFile} instances representing the models. */ getAll(securityContext) { Util.securityCheck(securityContext); let self = this; return super.getAll(securityContext) .then(function (resources) { return resources.map(function (resource) { return ModelFile.fromJSON(self.modelManager, resource.data); }); }); } /** * Get a specific model in the registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model. * @return {Promise} A promise that will be resolved with a {@link ModelFile} * instance representing the model. */ get(securityContext, id) { Util.securityCheck(securityContext); let self = this; return super.get(securityContext, id) .then(function (resource) { return ModelFile.fromJSON(self.modelManager, resource.data); }); } } module.exports = ModelRegistry; × Search results Close "},"chaincode_src_concerto_vendor_github.com_hyperledger_fabric_sdk_node_index.js.html":{"id":"chaincode_src_concerto_vendor_github.com_hyperledger_fabric_sdk_node_index.js.html","title":"Source: chaincode/src/concerto/vendor/github.com/hyperledger/fabric/sdk/node/index.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: chaincode/src/concerto/vendor/github.com/hyperledger/fabric/sdk/node/index.js /** * Copyright 2016 IBM * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * Licensed Materials - Property of IBM * © Copyright IBM Corp. 2016 */ module.exports = require('./lib/hfc'); × Search results Close "},"lib_concerto.js.html":{"id":"lib_concerto.js.html","title":"Source: lib/concerto.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/concerto.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const AssetRegistry = require('./assetregistry'); const Factory = require('./factory'); const ModelManager = require('./modelmanager'); const ModelRegistry = require('./modelregistry'); const SecurityContext = require('./securitycontext'); const Serializer = require('./serializer'); const Util = require('./util'); const Globalize = require('./globalize'); const hfc = require('hfc'); /** * IBM Concerto module. Concerto is a framework for creating * blockchain digital networks and exchanging assets. * &lt;p&gt;&lt;a href=&quot;diagrams/concerto.svg&quot;&gt;&lt;img src=&quot;diagrams/concerto.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @module ibm-concerto */ /** * Main entry point into the Concerto solution framework. Use this class * to retrieve the services defined by the solution framework. */ class Concerto { /** * Create an instance of the Concerto class. * @param {Object} [options] - an optional set of options to configure the instance. * @param {boolean} [options.developmentMode] - specify whether or not the instance * is in development mode. Use only for testing purposes! * peer to connect to. */ constructor(options) { this.modelManager = new ModelManager(); this.factory = new Factory(this.modelManager); this.serializer = new Serializer(this.factory, this.modelManager); this.chain = null; this.developmentMode = false; if (options &amp;&amp; options.developmentMode) { this.developmentMode = true; } } /** * Returns the current version of the IBM Concerto library * @return {string} the version number in dotted Major.Minor.Micro */ getVersion() { return '0.0.1'; } /** * Get a list of all existing asset registries. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * asset registries */ getAllAssetRegistries(securityContext) { Util.securityCheck(securityContext); return AssetRegistry.getAllAssetRegistries(securityContext, this.modelManager, this.factory, this.serializer); } /** * Get an existing asset registry. * @param {SecurityContext} securityContext - The user's security context * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with the existing asset * registry, or rejected if the asset registry does not exist. */ getAssetRegistry(securityContext, id) { Util.securityCheck(securityContext); return AssetRegistry.getAssetRegistry(securityContext, id, this.modelManager, this.factory, this.serializer); } /** * Add a new asset registry. * @param {SecurityContext} securityContext - The user's security context * @param {string} id - The unique identifier of the asset registry * @param {string} name - The name of the asset registry * @return {Promise} - A promise that will be resolved with the new asset * registry after it has been added. */ addAssetRegistry(securityContext, id, name) { Util.securityCheck(securityContext); return AssetRegistry.addAssetRegistry(securityContext, id, name, this.modelManager, this.factory, this.serializer); } /** * Get the model registry. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with the model registry. */ getModelRegistry(securityContext) { Util.securityCheck(securityContext); return ModelRegistry .getAllModelRegistries(securityContext, this.modelManager) .then(function (modelRegistries) { if (modelRegistries.length &gt;= 1) { return modelRegistries[0]; } else { throw new Error('Failed to find the default model registry'); } }); } /** * Returns the Factory * @param {SecurityContext} securityContext - The user's security context * @return {Factory} the Factory */ getFactory(securityContext) { Util.securityCheck(securityContext); return this.factory; } /** * Returns the ModelManager * @param {SecurityContext} securityContext - The user's security context * @return {ModelManager} the ModelManager */ getModelManager(securityContext) { Util.securityCheck(securityContext); return this.modelManager; } /** * Returns the Serializer * @param {SecurityContext} securityContext - The user's security context * @return {Serializer} the Serializer */ getSerializer(securityContext) { Util.securityCheck(securityContext); return this.serializer; } /** * Connects to the Hyperledger Fabric. * @param {Object} connectOptions - The connection options. * @param {string} connectOptions.keyValStore - The local directory to store * user certificates in. * @param {string} connectOptions.membershipServicesURL - The URL of the * Hyperledger Fabric membership services to connect to. * @param {string} connectOptions.peerURL - The URL of the Hyperledger Fabric * peer to connect to. * @return {Promise} A promise that will be resolved when the connection is * established. */ connect(connectOptions) { let self = this; if (!connectOptions) { throw new Error(Globalize.formatMessage('concerto-connect-noconopts')); } else if (!connectOptions.keyValStore) { throw new Error(Globalize.formatMessage('concerto-connect-nokeyvalstore')); } else if (!connectOptions.membershipServicesURL) { throw new Error(Globalize.formatMessage('concerto-connect-nomembersrvcurl')); } else if (!connectOptions.peerURL) { throw new Error(Globalize.formatMessage('concerto-connect-nopeerurl')); } return new Promise(function (resolve, reject) { self.chain = hfc.newChain('Concerto'); self.chain.setKeyValStore(hfc.newFileKeyValStore(connectOptions.keyValStore)); self.chain.setMemberServicesUrl(connectOptions.membershipServicesURL); self.chain.addPeer(connectOptions.peerURL); if (connectOptions.deployWaitTime) { self.chain.setDeployWaitTime(connectOptions.deployWaitTime); } if (connectOptions.invokeWaitTime) { self.chain.setInvokeWaitTime(connectOptions.invokeWaitTime); } resolve(); }); } /** * Log in to the Hyperledger Fabric as the specified user * * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @return {Promise} A promise that will be resolved with a {SecurityContext} * when the the security context */ login(enrollmentID, enrollmentSecret) { let self = this; if (!enrollmentID) { throw new Error(Globalize.formatMessage('concerto-login-noenrollmentid')); } else if (!enrollmentSecret) { throw new Error(Globalize.formatMessage('concerto-login-noenrollmentsecret')); } return new Promise(function (resolve, reject) { self.chain.enroll(enrollmentID, enrollmentSecret, function (error, enrolledMember) { if (error) { return reject(error); } let result = new SecurityContext(enrollmentID, enrollmentSecret); result.setEnrolledMember(enrolledMember); resolve(result); }); }); } /** * Deploys the Concerto chain-code to the Hyperledger Fabric. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} A promise that will be fufilled when the chain-code has * been deployed. */ deploy(securityContext) { let self = this; if (!securityContext) { throw new Error(Globalize.formatMessage('concerto-deploy-nosecuritycontext')); } return Util .deployChainCode(securityContext, 'concerto', 'init', [this.developmentMode.toString()]) .then(function (result) { securityContext.setChaincodeID(result.chaincodeID); }) .then(function () { return ModelRegistry.getAllModelRegistries(securityContext, self.modelManager); }) .then(function (modelRegistries) { if (modelRegistries.length === 0) { return ModelRegistry.addModelRegistry(securityContext, 'default', 'Default Model Registry', self.modelManager); } }); } /** * Load all of the models from the model registry into the model manager. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} A promise that will be fufilled when the models have been * loaded into the model manager. */ loadModels(securityContext) { let self = this; Util.securityCheck(securityContext); return this .getModelRegistry(securityContext) .then((modelRegistry) =&gt; { return modelRegistry.getAll(securityContext); }) .then((models) =&gt; { self.modelManager.clearModelFiles(); self.modelManager.addModelFiles(models); }); } /** * Save all of the models in the model manager to the model registry. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} A promise that will be fufilled when the models have been * saved in the model registry. */ saveModels(securityContext) { let self = this; Util.securityCheck(securityContext); return this .getModelRegistry(securityContext) .then((modelRegistry) =&gt; { let promises = []; self.modelManager.getModelFiles().forEach((modelFile) =&gt; { promises.push(modelRegistry.add(securityContext, modelFile)); }); return Promise.all(promises); }); } } module.exports = Concerto; × Search results Close "},"lib_parser_participantdeclaration.js.html":{"id":"lib_parser_participantdeclaration.js.html","title":"Source: lib/parser/participantdeclaration.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/participantdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** Class representing the definition of a Participant. * @extends ClassDeclaration */ class ParticipantDeclaration extends ClassDeclaration { /** * Create an ParticipantDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } } module.exports = ParticipantDeclaration; × Search results Close "},"lib_registry.js.html":{"id":"lib_registry.js.html","title":"Source: lib/registry.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/registry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Util = require('./util'); /** * Class representing an Abstract Registry. * &lt;p&gt;&lt;a href=&quot;diagrams/registry.svg&quot;&gt;&lt;img src=&quot;diagrams/registry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract */ class Registry { /** * Get a list of all existing registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the registries. */ static getAllRegistries(securityContext, registryType) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } return Util.queryChainCode(securityContext, 'getAllRegistries', [registryType]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Get an existing registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static getRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getRegistry', [registryType, id]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static addRegistry(securityContext, registryType, id, name) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } return Util.invokeChainCode(securityContext, 'addRegistry', [registryType, id, name]) .then(function () { return { id: id, name: name }; }); } /** * Create a registry. * * @protected * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The display name for the registry. */ constructor(registryType, id, name) { if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } this.registryType = registryType; this.id = id; this.name = name; } /** * Adds a new resource to the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ add(securityContext, id, data) { Util.securityCheck(securityContext); return Util.invokeChainCode(securityContext, 'addResourceToRegistry', [this.registryType, this.id, id, data]); } /** * Updates a resource in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. * @return {Promise} A promise that will be resolved when the resource is * updated in the registry. */ update(securityContext, id, data) { Util.securityCheck(securityContext); return Util.invokeChainCode(securityContext, 'updateResourceInRegistry', [this.registryType, this.id, id, data]); } /** * Remove an asset with a given type and id from the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved when the resource is * removed from the registry. */ remove(securityContext, id) { Util.securityCheck(securityContext); return Util.invokeChainCode(securityContext, 'removeResourceFromRegistry', [this.registryType, this.id, id]); } /** * Get all of the resources in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the resources. */ getAll(securityContext) { Util.securityCheck(securityContext); return Util.queryChainCode(securityContext, 'getAllResourcesInRegistry', [this.registryType, this.id]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Get a specific resource in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with a JSON object * representing the resource. */ get(securityContext, id) { Util.securityCheck(securityContext); return Util.queryChainCode(securityContext, 'getResourceInRegistry', [this.registryType, this.id, id]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } } module.exports = Registry; × Search results Close "},"lib_parser_relationship.js.html":{"id":"lib_parser_relationship.js.html","title":"Source: lib/parser/relationship.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/relationship.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Property = require('./property'); /** * Class representing a relationship between model elements * @extends Property */ class Relationship extends Property { /** * Create a Relationship. * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(ast) { super(ast); } } module.exports = Relationship; × Search results Close "},"lib_serializer.js.html":{"id":"lib_serializer.js.html","title":"Source: lib/serializer.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/serializer.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const CObject = require('./model/cobject'); const JSON2 = require('JSON2'); const Globalize = require('./globalize'); /** * Replacer function that prevents the ModelManager from being serialized * into the JSON string. * @param {string} name - the name of the field. * @param {*} val - the value of the field. * @return {*} the value of the field, or undefined if it should be removed. */ function replacer(name, val) { // convert RegExp to string if ( val &amp;&amp; val.constructor === RegExp ) { return val.toString(); } else if ( name === 'modelManager' ) { // return undefined; // remove from result } else { return val; // return as is } } /** * Serialize CObject instances to/from various formats. * &lt;p&gt;&lt;a href=&quot;diagrams/serializer.svg&quot;&gt;&lt;img src=&quot;diagrams/serializer.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class Serializer { /** * Create a Serializer. This should only be called by framework code. * Use the Concerto class to get an instance. * @param {Factory} factory - The Factory to use to create instances * @param {ModelManager} modelManager - The ModelManager to use for validation etc. */ constructor(factory,modelManager) { if(!factory) { throw new Error(Globalize.formatMessage('serializer-constructor-factorynull')); } this.factory = factory; this.modelManager = modelManager; } /** * Convert the CObject to a JSON string. * @param {CObject} cObject - The instance to convert to JSON * @return {string} - The JSON serialization of the instance * @throws {Error} - throws an exception if cObject is not an instance of * CObject or fails validation. */ toJSON(cObject) { // correct instance type if(!(cObject instanceof CObject)) { throw new Error(Globalize.formatMessage('serializer-tojson-notcobject')); } // validate the instance against the model cObject.validate(); // TODO (DCS) replace with custom/validated JSON generation? return JSON2.stringify(cObject, replacer); } /** * Create a CObject from a serialized JSON text string * @param {string} jsonData The serialized JSON text string * @return {CObject} The new instance */ fromJSON(jsonData) { // TODO (DCS) replace with custom/validated JSON generation let temp = JSON2.parse(jsonData); let cObject = this.factory.newInstance( this.modelManager, temp.namespace, temp.type, temp.identifier ); // copy all the other fields return Object.assign(cObject, temp); } } module.exports = Serializer; × Search results Close "},"lib_securitycontext.js.html":{"id":"lib_securitycontext.js.html","title":"Source: lib/securitycontext.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/securitycontext.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * Class representing the SecurityContext. * &lt;p&gt;&lt;a href=&quot;diagrams/securitycontext.svg&quot;&gt;&lt;img src=&quot;diagrams/securitycontext.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class SecurityContext { /** * Create the UserContext. * @param {string} user - The user identifier. * @param {string} password - The password. */ constructor(user, password) { this.user = user; this.password = password; this.enrolledMember = null; this.chaincodeID = null; } /** * Get the current username. * @return {string} The username */ getUser() { return this.user; } /** * Get the user password * @return {string} The user password. */ getPassword() { return this.password; } /** * Get the enrolled member. * @return {hfc.Member} The enrolled member. */ getEnrolledMember() { return this.enrolledMember; } /** * Set the enrolled member. * @param {hfc.Member} enrolledMember - The enrolled member. */ setEnrolledMember(enrolledMember) { this.enrolledMember = enrolledMember; } /** * Get the chaincode ID. * @return {string} The chaincode ID. */ getChaincodeID() { return this.chaincodeID; } /** * Set the chaincode ID. * @param {string} chaincodeID - The chaincode ID. */ setChaincodeID(chaincodeID) { this.chaincodeID = chaincodeID; } } module.exports = SecurityContext; × Search results Close "},"lib_securityexception.js.html":{"id":"lib_securityexception.js.html","title":"Source: lib/securityexception.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/securityexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('./baseexception'); /** * Class representing a security exception * &lt;p&gt;&lt;a href=&quot;diagrams/securityexception.svg&quot;&gt;&lt;img src=&quot;diagrams/securityexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class SecurityException extends BaseException { /** * Create the SecurityException. * @param {string} message - The exception message. */ constructor(message) { super(message); } } module.exports = SecurityException; × Search results Close "},"systest_testutil.js.html":{"id":"systest_testutil.js.html","title":"Source: systest/testutil.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: systest/testutil.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Concerto = require('..').Concerto; const net = require('net'); const Util = require('../lib/util'); let concerto; let securityContext; /** * A class containing test utilities for use in Concerto system tests. */ class TestUtil { /** * Wait for the peer on the specified hostname and port to start listening * on the specified port. * @return {Promise} - a promise that will be resolved when the peer has * started listening on the specified port. */ static waitForPeer() { let waitTime = 30; if (process.env.CONCERTO_PEER_WAIT_SECS) { waitTime = parseInt(process.env.CONCERTO_PEER_WAIT_SECS); console.log('CONCERTO_PEER_WAIT_SECS set, using: ', waitTime); } return new Promise(function (resolve, reject) { let testConnect = function (count) { let s = new net.Socket(); s.on('error', function (error) { if (count &gt; waitTime) { console.error('Giving up waiting for vp0 to start'); return reject(error); } else { console.log('Waiting 1 second for vp0 to start ...'); setTimeout(function () { testConnect(count + 1); }, 1000); } }); s.on('connect', function () { console.log('vp0 has started'); s.end(); return resolve(); }); s.connect(7051, 'vp0'); }; testConnect(0); }); } /** * Get a configured and connected instance of Concerto. * @return {Promise} - a promise that wil be resolved with a configured and * connected instance of Concerto. */ static getConcerto() { if (concerto) { return Promise.resolve(concerto); } return TestUtil.waitForPeer() .then(function () { console.log('Calling Concerto.connect() ...'); concerto = new Concerto({ developmentMode: true }); let options = { keyValStore: '/tmp/keyValStore', membershipServicesURL: 'grpc://membersrvc:7054', peerURL: 'grpc://vp0:7051' }; if (process.env.CONCERTO_DEPLOY_WAIT_SECS) { options.deployWaitTime = parseInt(process.env.CONCERTO_DEPLOY_WAIT_SECS); console.log('CONCERTO_DEPLOY_WAIT_SECS set, using: ', options.deployWaitTime); } if (process.env.CONCERTO_INVOKE_WAIT_SECS) { options.invokeWaitTime = parseInt(process.env.CONCERTO_INVOKE_WAIT_SECS); console.log('CONCERTO_INVOKE_WAIT_SECS set, using: ', options.invokeWaitTime); } return concerto.connect(options); }) .then(function () { console.log('Called Concerto.connect()'); console.log('Calling Concerto.login() ...'); return concerto.login('WebAppAdmin', 'DJY27pEnl16d'); }) .then(function (result) { console.log('Called Concerto.login()'); securityContext = result; console.log('Calling Concerto.deploy() ...'); return concerto.deploy(securityContext); }) .then(function () { console.log('Called Concerto.deploy()'); return Promise.resolve(concerto); }); } /** * Get a logged in security context for interacting with Concerto. * @return {Promise} - a promise that will be resolved with a logged in * security context for interacting with Concerto. */ static getSecurityContext() { if (!concerto || !securityContext) { return Promise.reject(new Error('Must call getConcerto successfully before calling getSecurityContext')); } return Promise.resolve(securityContext); } /** * Invoke the chain-code to clear all of the world state so that any test * data is removed. Call in-between tests. * @return {Promise} - a promise that will be resolved once the chain-code * has been invoked. */ static clearWorldState() { if (!concerto || !securityContext) { return Promise.reject(new Error('Must call getConcerto successfully before calling clearWorldState')); } return Util.invokeChainCode(securityContext, 'clearWorldState', []); } } module.exports = TestUtil; × Search results Close "},"lib_parser_transactiondeclaration.js.html":{"id":"lib_parser_transactiondeclaration.js.html","title":"Source: lib/parser/transactiondeclaration.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/parser/transactiondeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** Class representing the definition of an Transaction. * @extends SubclassableDeclaration */ class TransactionDeclaration extends ClassDeclaration { /** * Create an TransactionDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns the id field for this entity * @private */ getIdentifierFieldName() { throw new Error('Transactions do not have an identifying field.'); } } module.exports = TransactionDeclaration; × Search results Close "},"lib_util.js.html":{"id":"lib_util.js.html","title":"Source: lib/util.js","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Source: lib/util.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const hfc = require('hfc'); const path = require('path'); const SecurityException = require('./securityexception'); const Globalize = require('./globalize'); /** * Internal Utility Class * &lt;p&gt;&lt;a href=&quot;diagrams/util.svg&quot;&gt;&lt;img src=&quot;diagrams/util.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @ignore */ class Util { /** * Internal method to check the security context * @param {SecurityContext} securityContext - The user's security context * @throws {SecurityException} if the user context is invalid * @ignore */ static securityCheck(securityContext) { if ((securityContext === undefined) || (securityContext === null)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } } /** * Submit a query request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static queryChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); let enrolledMember = securityContext.getEnrolledMember(); let queryRequest = { chaincodeID: securityContext.getChaincodeID(), fcn: functionName, args: args }; return new Promise(function (resolve, reject) { let transactionContext = enrolledMember.query(queryRequest); transactionContext.on('submitted', function () { // TODO: we should probably log this! }); transactionContext.on('complete', function (data) { resolve(data.result); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }); } /** * Submit an invoke request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static invokeChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); let enrolledMember = securityContext.getEnrolledMember(); let invokeRequest = { chaincodeID: securityContext.getChaincodeID(), fcn: functionName, args: args }; return new Promise(function (resolve, reject) { let transactionContext = enrolledMember.invoke(invokeRequest); transactionContext.on('submitted', function () { // TODO: we should probably log this! }); transactionContext.on('complete', function () { resolve(); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }); } /** * Submit an deploy request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} chaincodePath - The path of the chain-code to deploy. * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static deployChainCode(securityContext, chaincodePath, functionName, args) { Util.securityCheck(securityContext); if (!chaincodePath) { throw new Error('chaincodePath not specified'); } else if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return new Promise(function (resolve, reject) { // This is evil! I shouldn't need to set GOPATH in a node.js program. process.env.GOPATH = path.resolve(__dirname, '..', 'chaincode'); let deployRequest = { fcn: functionName, args: args, chaincodePath: chaincodePath }; let enrolledMember = securityContext.getEnrolledMember(); let transactionContext = enrolledMember.deploy(deployRequest); transactionContext.on('complete', function (result) { resolve(result); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }); } } module.exports = Util; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Global Methods directoryExists(path) Parameters: Name Type Description path string the file path to check Source: lib/codegen/filewriter.js, line 152 Returns: true if the directory exists Type boolean ensureDirectoryExistence(filePath) Parameters: Name Type Description filePath string the file path to check Source: lib/codegen/filewriter.js, line 138 Returns: true if the directory exists Type boolean findCommentBefore(rangeStart, rangeEnd, comments) Find the comments that is above and closest to the start of the range. Parameters: Name Type Description rangeStart integer the start of the range rangeEnd integer the end of the range comments Array.&lt;string&gt; the end of the range Source: lib/codegen/umlgen.js, line 179 Returns: the comment index or -1 if there are no comments Type integer getMethodArguments(comment) Extracts the method arguments from a comment block. Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 264 Returns: the the argument types Type string getReturnType(comment) Extracts the return type from a comment block. Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 245 Returns: the return type of the comment Type string getVisibility(comment) Extracts the method visibilty from a comment block Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 230 Returns: the return visibility (either + for public, or - for private) Type string processDirectory(path) Parameters: Name Type Description path string the path to process Source: lib/codegen/umlgen.js, line 40 processFile(file) Parameters: Name Type Description file string the file to process Source: lib/codegen/umlgen.js, line 62 replacer(name, val) Replacer function that prevents the ModelManager from being serialized into the JSON string. Parameters: Name Type Description name string the name of the field. val * the value of the field. Source: lib/serializer.js, line 24 Returns: the value of the field, or undefined if it should be removed. Type * toUMLFilename(inputDir, outputDir, filename) Parameters: Name Type Description inputDir string the fully qualified input directory outputDir string the fully qualified output directory filename string the fully qualified input file name (.js) Source: lib/codegen/umlgen.js, line 203 Returns: the UML file name to use Type string × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Modules Classes AssetDeclaration AssetRegistry BaseException CBase ClassDeclaration CObject CRelationship Factory Field FileWriter GoLangVisitor IllegalModelException ModelFile ModelManager ModelRegistry Concerto ParticipantDeclaration Property Registry Relationship SecurityContext SecurityException Serializer TestUtil TransactionDeclaration × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Classes Classes AssetDeclaration AssetRegistry BaseException CBase ClassDeclaration CObject CRelationship Factory Field FileWriter GoLangVisitor IllegalModelException ModelFile ModelManager ModelRegistry Concerto ParticipantDeclaration Property Registry Relationship SecurityContext SecurityException Serializer TestUtil TransactionDeclaration × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename × Search results Close "},"AssetDeclaration.html":{"id":"AssetDeclaration.html","title":"Class: AssetDeclaration","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: AssetDeclaration AssetDeclaration AssetDeclaration defines the schema (aka model or class) for an Asset. It extends ClassDeclaration which manages a set of fields, a super-type and the specification of an identifying field. new AssetDeclaration(modelFile, ast) Create an AssetDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/assetdeclaration.js, line 23 Extends ClassDeclaration Methods getField(name) Returns the field with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getField Source: lib/parser/classdeclaration.js, line 268 Returns: the field, or null if it does not exist Type Field getFields() Returns the fields defined in this class and all super classes. Inherited From: ClassDeclaration#getFields Source: lib/parser/classdeclaration.js, line 285 Returns: the array of fields Type Array.&lt;Field&gt; getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Inherited From: ClassDeclaration#getFullyQualifiedName Source: lib/parser/classdeclaration.js, line 184 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Inherited From: ClassDeclaration#getIdentifierFieldName Source: lib/parser/classdeclaration.js, line 199 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Inherited From: ClassDeclaration#getModelFile Source: lib/parser/classdeclaration.js, line 65 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Inherited From: ClassDeclaration#getName Source: lib/parser/classdeclaration.js, line 174 Returns: the short name of this class Type string getOwnField(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getOwnField Source: lib/parser/classdeclaration.js, line 231 Returns: the field definition or null if it does not exist. Type Field getOwnFields() Returns the fields directly defined by this class. Inherited From: ClassDeclaration#getOwnFields Source: lib/parser/classdeclaration.js, line 247 Returns: the array of fields Type Array.&lt;Field&gt; getSuperType() Returns the name of the super type for this class or null if this class does not have a super type. Inherited From: ClassDeclaration#getSuperType Source: lib/parser/classdeclaration.js, line 257 Returns: the name of the super type or null Type string × Search results Close "},"AssetRegistry.html":{"id":"AssetRegistry.html","title":"Class: AssetRegistry","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: AssetRegistry AssetRegistry The AssetRegistry is used to manage a set of assets. new AssetRegistry(id, name, modelManager, factory, serializer) Create an asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry. name string The display name for the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 24 Extends Registry Methods &lt;protected, static&gt; addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset registry. name string The name of the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 96 Returns: A promise that will be resolved with a AssetRegistry instance representing the new asset registry. Type Promise &lt;protected, static&gt; getAllAssetRegistries(securityContext, modelManager, factory, serializer) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 37 Returns: A promise that will be resolved with a list of AssetRegistry instances representing the asset registries. Type Promise &lt;protected, static&gt; getAssetRegistry(securityContext, id, modelManager, factory, serializer) Get an existing asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 66 Returns: A promise that will be resolved with a AssetRegistry instance representing the asset registry. Type Promise add(securityContext, asset) Adds an asset to the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset CObject The asset to be added to the asset registry. Overrides: Registry#add Source: lib/assetregistry.js, line 147 Returns: A promise that is resolved when the asset is added to the asset registry. Type Promise get(securityContext, id) Get a specific asset in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset. Overrides: Registry#get Source: lib/assetregistry.js, line 212 Returns: A promise that will be resolved with a CObject instance representing the asset. Type Promise getAll(securityContext) Get all of the assets in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Overrides: Registry#getAll Source: lib/assetregistry.js, line 193 Returns: A promise that will be resolved with an array of CObject instances representing the assets. Type Promise remove(securityContext, asset) Remove an asset with a given type and id from the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset CObject | string The asset, or the unique identifier of the asset. Overrides: Registry#remove Source: lib/assetregistry.js, line 175 Returns: A promise that is resolved when the element is removed from the registry. Type Promise update(securityContext, asset) Updates an asset in the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset CObject The asset to be updated in the asset registry. Overrides: Registry#update Source: lib/assetregistry.js, line 161 Returns: A promise that is resolved when the asset is updated in the asset registry. Type Promise × Search results Close "},"BaseException.html":{"id":"BaseException.html","title":"Class: BaseException","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: BaseException BaseException A base class for all exceptions new BaseException(message) Create the BaseException. Parameters: Name Type Description message string The exception message. Source: lib/baseexception.js, line 17 × Search results Close "},"CBase.html":{"id":"CBase.html","title":"Class: CBase","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: CBase CBase Base is an entity with a namespace, type and an identifier. It is used in Concerto to represent Assets and other classes that can be serialized for long-term persistent storage. This class is abstract. &lt;abstract&gt; new CBase(modelManager, ns, type, id) Use the Factory to create instances. Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/cbase.js, line 22 Methods getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance. (namespace '.' type '#' identifier) or (type '#' identifier). Source: lib/model/cbase.js, line 52 Returns: the fully qualified identifier of this instance Type string getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Source: lib/model/cbase.js, line 68 Returns: The fully-qualified type name of this object Type string getIdentifier() Get the identifier of this instance Source: lib/model/cbase.js, line 43 Returns: The identifier for this object Type string getNamespace() Get the namespace of the instance. Source: lib/model/cbase.js, line 81 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Source: lib/model/cbase.js, line 60 Returns: The type of this object Type string × Search results Close "},"ClassDeclaration.html":{"id":"ClassDeclaration.html","title":"Class: ClassDeclaration","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: ClassDeclaration ClassDeclaration ClassDeclaration defines the structure (model/schema) of composite data. It is composed of a set of Fields, may have an identifying field, and may have a super-type. A ClassDeclaration is conceptually owned with a ModelFile which defines all the classes that are part of a namespace. This class is abstract and should not be instantiated. &lt;abstract&gt; new ClassDeclaration(modelFile, ast) Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the result of parsing. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast string the AST created by the parser Source: lib/parser/classdeclaration.js, line 29 Methods getField(name) Returns the field with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Source: lib/parser/classdeclaration.js, line 268 Returns: the field, or null if it does not exist Type Field getFields() Returns the fields defined in this class and all super classes. Source: lib/parser/classdeclaration.js, line 285 Returns: the array of fields Type Array.&lt;Field&gt; getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Source: lib/parser/classdeclaration.js, line 184 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Source: lib/parser/classdeclaration.js, line 199 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Source: lib/parser/classdeclaration.js, line 65 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Source: lib/parser/classdeclaration.js, line 174 Returns: the short name of this class Type string getOwnField(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Source: lib/parser/classdeclaration.js, line 231 Returns: the field definition or null if it does not exist. Type Field getOwnFields() Returns the fields directly defined by this class. Source: lib/parser/classdeclaration.js, line 247 Returns: the array of fields Type Array.&lt;Field&gt; getSuperType() Returns the name of the super type for this class or null if this class does not have a super type. Source: lib/parser/classdeclaration.js, line 257 Returns: the name of the super type or null Type string × Search results Close "},"CObject.html":{"id":"CObject.html","title":"Class: CObject","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: CObject CObject CObject is an instance that is associated with a ClassDeclaration and that has a set of Fields that are defined by the ClassDeclaration. It is used in Concerto to represent Assets, Participants, Transactions and other domain classes that can be serialized for long-term persistent storage. new CObject(modelManager, ns, type, id) This constructor should not be called directly. Use the Factory class to create instances. Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/cobject.js, line 26 Extends Base Methods setFieldValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: lib/model/cobject.js, line 47 Throws: if the value is not compatible with the model definition for the field Type Error × Search results Close "},"CRelationship.html":{"id":"CRelationship.html","title":"Class: CRelationship","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: CRelationship CRelationship A Relationship is a typed pointer to an instance. I.e the relationship with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates a pointer that points at an instance of org.acme.Vehicle with the id ABC. new CRelationship(modelManager, ns, type, id) Create an asset. Use the Factory to create instances. Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/crelationship.js, line 23 Extends Base × Search results Close "},"Factory.html":{"id":"Factory.html","title":"Class: Factory","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Factory Factory Use the Factory to create instances of CObject. An instance of this class can be retrieved from the Concerto class. new Factory(modelManager) Create the factory. This class should not be called by solutions. Parameters: Name Type Description modelManager ModelManager The ModelManager to use for this registry Source: lib/factory.js, line 23 Methods newInstance(securityContext, ns, type, id) Create a new CObject with a given namespace, type name and id Parameters: Name Type Description securityContext SecurityContext The user's security context ns string the namespace of the CObject type string the type of the CObject id string the identifier Source: lib/factory.js, line 42 Throws: if the type is not registered with the ModelManager Type ModelException Returns: - the new instance Type CObject newRelationship(securityContext, ns, type, id) Create a new Relationship with a given namespace, type and identifier. ` * A relationship is a typed pointer to an instance. I.e the relationship with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` a pointer that points at an instance of org.acme.Vehicle with the id ABC. Parameters: Name Type Description securityContext SecurityContext The user's security context ns string the namespace of the CObject type string the type of the CObject id string the identifier Source: lib/factory.js, line 90 Throws: if the type is not registered with the ModelManager Type ModelException Returns: - the new relationship instance Type Relationship × Search results Close "},"Field.html":{"id":"Field.html","title":"Class: Field","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Field Field Class representing the definition of a Field. A Field is owned by a ClassDeclaration and has a name, type and additional metadata (see below). new Field(ast) Create an Field. Parameters: Name Type Description ast Object The AST created by the parser Source: lib/parser/field.js, line 21 Extends Property Methods getDefaultValue() Returns the default value for the field or null Source: lib/parser/field.js, line 76 Returns: the default value for the field or null Type string getName() Returns the name of a field Inherited From: Property#getName Source: lib/parser/property.js, line 70 Returns: the name of this field Type string getType() Returns the type of a field Inherited From: Property#getType Source: lib/parser/property.js, line 78 Returns: the type of this field Type string getValidator() Returns the validator string for this field Source: lib/parser/field.js, line 60 Returns: the validator for the field or null Type string isArray() Returns true if the field is declared as an array type Inherited From: Property#isArray Source: lib/parser/property.js, line 86 Returns: true if the field is an array type Type boolean isOptional() Returns true if the field is optional Source: lib/parser/field.js, line 68 Returns: true if the field is optional Type boolean × Search results Close "},"FileWriter.html":{"id":"FileWriter.html","title":"Class: FileWriter","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: FileWriter FileWriter Writes output to a file. new FileWriter(outputDirectory) Create a FileWriter. Parameters: Name Type Description outputDirectory string the ModelManager that manages this ModelFile Source: lib/codegen/filewriter.js, line 20 Methods closeFile() Closes the current open file Source: lib/codegen/filewriter.js, line 99 openFile(fileName) Opens a file for writing Parameters: Name Type Description fileName string the name of the file to open Source: lib/codegen/filewriter.js, line 45 openRelativeFile(relativeDir, fileName) Opens a file for writing Parameters: Name Type Description relativeDir string the relative directory to use fileName string the name of the file to open Source: lib/codegen/filewriter.js, line 55 writeBeforeLine(tabs, text) Writes text to the start of the current open file Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/filewriter.js, line 65 writeLine(tabs, text) Writes text to the current open file Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/filewriter.js, line 83 × Search results Close "},"GoLangVisitor.html":{"id":"GoLangVisitor.html","title":"Class: GoLangVisitor","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: GoLangVisitor GoLangVisitor Convert the contents of a ModelManager to Go Lang code. All generated code is placed into the 'main' package. Set a fileWriter property (instance of FileWriter) on the parameters object to control where the generated code is written to disk. new GoLangVisitor() Source: lib/codegen/golang/golangvisitor.js, line 28 × Search results Close "},"IllegalModelException.html":{"id":"IllegalModelException.html","title":"Class: IllegalModelException","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: IllegalModelException IllegalModelException Class throws when a model is invalid new IllegalModelException(message) Create an IllegalModelException Parameters: Name Type Description message string the message for the exception Source: lib/parser/illegalmodelexception.js, line 16 × Search results Close "},"ModelFile.html":{"id":"ModelFile.html","title":"Class: ModelFile","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: ModelFile ModelFile Class representing a Model File. A Model File contains a single namespace and a set of model elements: assets, transactions etc. new ModelFile(modelManager, id, name, definitions) Create a ModelFile. This should only be called by framework code. Use the ModelManager to manage ModelFiles. Parameters: Name Type Description modelManager ModelManager the ModelManager that manages this ModelFile id string The unique identifier of the model as a string. name string The name of the model as a string. definitions string The DSL model as a string. Source: lib/parser/modelfile.js, line 26 Methods &lt;static&gt; fromJSON(modelManager, json) Convert the specified JSON into an instance of a model file. Parameters: Name Type Description modelManager ModelManager the ModelManager that manages this ModelFile json string A serialized instance of a ModelFile. Source: lib/parser/modelfile.js, line 35 Returns: An instance of a model file. Type ModelFile getAllDeclarations() Get all declarations in this ModelFile Source: lib/parser/modelfile.js, line 348 Returns: the ClassDeclarations defined in the model file Type Array.&lt;ClassDeclaration&gt; getAssetDeclaration(name) Get the AssetDeclarations defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 258 Returns: the AssetDeclaration with the given short name Type AssetDeclaration getAssetDeclarations() Get the AssetDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 308 Returns: the AssetDeclarations defined in the model file Type Array.&lt;AssetDeclaration&gt; getDeclarations(type) Get the instances of a given type in this ModelFile Parameters: Name Type Description type function the type of the declaration Source: lib/parser/modelfile.js, line 333 Returns: the ClassDeclaration defined in the model file Type Array.&lt;ClassDeclaration&gt; getDefinitions() Get the definitions for this model. Source: lib/parser/modelfile.js, line 372 Returns: The definitions for this model. Type string getIdentifier() Get the unique identifier of this model. Source: lib/parser/modelfile.js, line 356 Returns: The unique identifier of this model. Type string getImports() Returns the types that have been imported into this ModelFile. Source: lib/parser/modelfile.js, line 121 Returns: The array of imports for this ModelFile Type Array.&lt;string&gt; getModelManager() Returns the ModelManager associated with this ModelFile Source: lib/parser/modelfile.js, line 112 Returns: The ModelManager for this ModelFile Type ModelManager getName() Get the name of this model. Source: lib/parser/modelfile.js, line 364 Returns: The name of this model. Type string getNamespace() Get the Namespace for this model file. Source: lib/parser/modelfile.js, line 300 Returns: The Namespace for this model file Type string getParticipantDeclaration(name) Get the ParticipantDeclaration defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 286 Returns: the ParticipantDeclaration with the given short name Type ParticipantDeclaration getParticipantDeclarations() Get the ParticipantDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 324 Returns: the ParticipantDeclaration defined in the model file Type Array.&lt;ParticipantDeclaration&gt; getTransactionDeclaration(name) Get the TransactionDeclaration defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 272 Returns: the TransactionDeclaration with the given short name Type TransactionDeclaration getTransactionDeclarations() Get the TransactionDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 316 Returns: the TransactionDeclarations defined in the model file Type Array.&lt;TransactionDeclaration&gt; getType(type) Returns the type with the specified name or null Parameters: Name Type Description type string the short OR FQN name of the type Source: lib/parser/modelfile.js, line 239 Returns: the ClassDeclaration, or null if the type does not exist Type ClassDeclaration isDefined(type) Returns true if the type is defined in the model file Parameters: Name Type Description type string the name of the type Source: lib/parser/modelfile.js, line 230 Returns: true if the type (asset or transaction) is defined Type boolean toJSON() Convert this model file into an object that is suitable for converting into a JSON string for serialization purposes. Source: lib/parser/modelfile.js, line 381 Returns: An object suitable for converting into a JSON string. Type Object toJSONString() Convert this model file into a JSON string for serialization purposes. Source: lib/parser/modelfile.js, line 391 Returns: A JSON string. Type string × Search results Close "},"ModelManager.html":{"id":"ModelManager.html","title":"Class: ModelManager","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: ModelManager ModelManager The ModelManager manages a set of ModelFiles. Each ModelFile has a single namespace and defines a set of classes (assets, transactions, participants). new ModelManager() Create the ModelUtil. This should only be called by the framework. Instances should be retrieved from the Concerto module. Source: lib/modelmanager.js, line 24 Methods addModelFile(id, name, definitions) Create an model from a DSL model file as a string. Parameters: Name Type Description id string The unique identifier of the model name string The name of the model definitions string The model DSL as a string Source: lib/modelmanager.js, line 51 Throws: InvalidModelException addModelFiles(modelFiles) Add an existing set of model files to the model manager. Parameters: Name Type Description modelFiles Array.&lt;ModelFile&gt; The list of model files. Source: lib/modelmanager.js, line 61 clearModelFiles() Remove all registered model files Source: lib/modelmanager.js, line 136 getModelFile(namespace) Get the ModelFile associated with a namespace Parameters: Name Type Description namespace string the namespace containing the ModelFile Source: lib/modelmanager.js, line 145 Returns: registered ModelFile for the namespace or null Type ModelFile getModelFiles() Get the array of model file instances Source: lib/modelmanager.js, line 82 Returns: The ModelFiles registered Type Array.&lt;ModelFile&gt; getType(type) Look up a type in all registered namespaces (ModelFiles). Parameters: Name Type Description type string the fully qualified name of a type Source: lib/modelmanager.js, line 156 Throws: - if the type cannot be found Type Error Returns: - the class declaration or null for primitive types Type ClassDeclaration × Search results Close "},"ModelRegistry.html":{"id":"ModelRegistry.html","title":"Class: ModelRegistry","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: ModelRegistry ModelRegistry The ModelRegistry is used to manage a set of models. new ModelRegistry(id, name, modelManager) Create an model registry. Parameters: Name Type Description id string The unique identifier of the model registry. name string The display name for the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 24 Extends Registry Methods &lt;protected, static&gt; addModelRegistry(securityContext, id, name, modelManager) Add a new model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model registry. name string The name of the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 82 Returns: A promise that will be resolved with a ModelRegistry instance representing the new model registry. Type Promise &lt;protected, static&gt; getAllModelRegistries(securityContext, modelManager) Get a list of all existing model registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this asset registry. Source: lib/modelregistry.js, line 35 Returns: A promise that will be resolved with a list of ModelRegistry instances representing the asset registries. Type Promise &lt;protected, static&gt; getModelRegistry(securityContext, id, modelManager) Get an existing model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 58 Returns: A promise that will be resolved with a ModelRegistry instance representing the model registry. Type Promise add(securityContext, model) Adds a model to the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile The model to be added to the model registry. Overrides: Registry#add Source: lib/modelregistry.js, line 121 Returns: A promise that is resolved when the model is added to the model registry. Type Promise get(securityContext, id) Get a specific model in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model. Overrides: Registry#get Source: lib/modelregistry.js, line 184 Returns: A promise that will be resolved with a ModelFile instance representing the model. Type Promise getAll(securityContext) Get all of the models in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Overrides: Registry#getAll Source: lib/modelregistry.js, line 165 Returns: A promise that will be resolved with an array of ModelFile instances representing the models. Type Promise remove(securityContext, model) Remove an model with a given type and id from the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile | string The model, or the unique identifier of the model. Overrides: Registry#remove Source: lib/modelregistry.js, line 147 Returns: A promise that is resolved when the element is removed from the registry. Type Promise update(securityContext, model) Updates an model in the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile The model to be updated in the model registry. Overrides: Registry#update Source: lib/modelregistry.js, line 134 Returns: A promise that is resolved when the model is updated in the model registry. Type Promise × Search results Close "},"module-ibm-concerto.html":{"id":"module-ibm-concerto.html","title":"Module: ibm-concerto","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Module: ibm-concerto IBM Concerto module. Concerto is a framework for creating blockchain digital networks and exchanging assets. Source: lib/concerto.js, line 24 Classes Concerto × Search results Close "},"module-ibm-concerto-Concerto.html":{"id":"module-ibm-concerto-Concerto.html","title":"Class: Concerto","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Concerto ibm-concerto~ Concerto Main entry point into the Concerto solution framework. Use this class to retrieve the services defined by the solution framework. new Concerto( [options]) Create an instance of the Concerto class. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description developmentMode boolean &lt;optional&gt; specify whether or not the instance is in development mode. Use only for testing purposes! peer to connect to. Source: lib/concerto.js, line 35 Methods addAssetRegistry(securityContext, id, name) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context id string The unique identifier of the asset registry name string The name of the asset registry Source: lib/concerto.js, line 94 Returns: - A promise that will be resolved with the new asset registry after it has been added. Type Promise connect(connectOptions) Connects to the Hyperledger Fabric. Parameters: Name Type Description connectOptions Object The connection options. Properties Name Type Description keyValStore string The local directory to store user certificates in. membershipServicesURL string The URL of the Hyperledger Fabric membership services to connect to. peerURL string The URL of the Hyperledger Fabric peer to connect to. Source: lib/concerto.js, line 159 Returns: A promise that will be resolved when the connection is established. Type Promise deploy(securityContext) Deploys the Concerto chain-code to the Hyperledger Fabric. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 218 Returns: A promise that will be fufilled when the chain-code has been deployed. Type Promise getAllAssetRegistries(securityContext) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 69 Returns: - A promise that will be resolved with a list of existing asset registries Type Promise getAssetRegistry(securityContext, id) Get an existing asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context id string The unique identifier of the asset registry Source: lib/concerto.js, line 81 Returns: - A promise that will be resolved with the existing asset registry, or rejected if the asset registry does not exist. Type Promise getFactory(securityContext) Returns the Factory Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 122 Returns: the Factory Type Factory getModelManager(securityContext) Returns the ModelManager Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 132 Returns: the ModelManager Type ModelManager getModelRegistry(securityContext) Get the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 104 Returns: - A promise that will be resolved with the model registry. Type Promise getSerializer(securityContext) Returns the Serializer Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 142 Returns: the Serializer Type Serializer getVersion() Returns the current version of the IBM Concerto library Source: lib/concerto.js, line 59 Returns: the version number in dotted Major.Minor.Micro Type string loadModels(securityContext) Load all of the models from the model registry into the model manager. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 244 Returns: A promise that will be fufilled when the models have been loaded into the model manager. Type Promise login(enrollmentID, enrollmentSecret) Log in to the Hyperledger Fabric as the specified user Parameters: Name Type Description enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user Source: lib/concerto.js, line 193 Returns: A promise that will be resolved with a {SecurityContext} when the the security context Type Promise saveModels(securityContext) Save all of the models in the model manager to the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 264 Returns: A promise that will be fufilled when the models have been saved in the model registry. Type Promise × Search results Close "},"ParticipantDeclaration.html":{"id":"ParticipantDeclaration.html","title":"Class: ParticipantDeclaration","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: ParticipantDeclaration ParticipantDeclaration Class representing the definition of a Participant. new ParticipantDeclaration(modelFile, ast) Create an ParticipantDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/participantdeclaration.js, line 18 Extends ClassDeclaration Methods getField(name) Returns the field with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getField Source: lib/parser/classdeclaration.js, line 268 Returns: the field, or null if it does not exist Type Field getFields() Returns the fields defined in this class and all super classes. Inherited From: ClassDeclaration#getFields Source: lib/parser/classdeclaration.js, line 285 Returns: the array of fields Type Array.&lt;Field&gt; getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Inherited From: ClassDeclaration#getFullyQualifiedName Source: lib/parser/classdeclaration.js, line 184 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Inherited From: ClassDeclaration#getIdentifierFieldName Source: lib/parser/classdeclaration.js, line 199 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Inherited From: ClassDeclaration#getModelFile Source: lib/parser/classdeclaration.js, line 65 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Inherited From: ClassDeclaration#getName Source: lib/parser/classdeclaration.js, line 174 Returns: the short name of this class Type string getOwnField(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getOwnField Source: lib/parser/classdeclaration.js, line 231 Returns: the field definition or null if it does not exist. Type Field getOwnFields() Returns the fields directly defined by this class. Inherited From: ClassDeclaration#getOwnFields Source: lib/parser/classdeclaration.js, line 247 Returns: the array of fields Type Array.&lt;Field&gt; getSuperType() Returns the name of the super type for this class or null if this class does not have a super type. Inherited From: ClassDeclaration#getSuperType Source: lib/parser/classdeclaration.js, line 257 Returns: the name of the super type or null Type string × Search results Close "},"Property.html":{"id":"Property.html","title":"Class: Property","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Property Property Property representing an attribute of a class declaration, either a Field or a Relationship. new Property(ast) Create a Property. Parameters: Name Type Description ast Object The AST created by the parser Source: lib/parser/property.js, line 17 Methods getName() Returns the name of a field Source: lib/parser/property.js, line 70 Returns: the name of this field Type string getType() Returns the type of a field Source: lib/parser/property.js, line 78 Returns: the type of this field Type string isArray() Returns true if the field is declared as an array type Source: lib/parser/property.js, line 86 Returns: true if the field is an array type Type boolean × Search results Close "},"Registry.html":{"id":"Registry.html","title":"Class: Registry","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Registry Registry Class representing an Abstract Registry. &lt;abstract&gt; new Registry(registryType, id, name) Create a registry. Parameters: Name Type Description registryType string The type of this registry. id string The unique identifier of the registry. name string The display name for the registry. Source: lib/registry.js, line 20 Methods &lt;protected, static&gt; addRegistry(securityContext, registryType, id, name) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. id string The unique identifier of the registry. name string The name of the registry. Source: lib/registry.js, line 76 Returns: A promise that will be resolved with a JSON object representing the registry. Type Promise &lt;protected, static&gt; getAllRegistries(securityContext, registryType) Get a list of all existing registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. Source: lib/registry.js, line 31 Returns: A promise that will be resolved with an array of JSON objects representing the registries. Type Promise &lt;protected, static&gt; getRegistry(securityContext, registryType, id) Get an existing registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. id string The unique identifier of the registry. Source: lib/registry.js, line 52 Returns: A promise that will be resolved with a JSON object representing the registry. Type Promise &lt;protected&gt; add(securityContext, id, data) Adds a new resource to the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. Source: lib/registry.js, line 125 Returns: A promise that will be resolved when the resource is added to the registry. Type Promise &lt;protected&gt; get(securityContext, id) Get a specific resource in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. Source: lib/registry.js, line 184 Returns: A promise that will be resolved with a JSON object representing the resource. Type Promise &lt;protected&gt; getAll(securityContext) Get all of the resources in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Source: lib/registry.js, line 167 Returns: A promise that will be resolved with an array of JSON objects representing the resources. Type Promise &lt;protected&gt; remove(securityContext, id) Remove an asset with a given type and id from the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. Source: lib/registry.js, line 154 Returns: A promise that will be resolved when the resource is removed from the registry. Type Promise &lt;protected&gt; update(securityContext, id, data) Updates a resource in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. Source: lib/registry.js, line 140 Returns: A promise that will be resolved when the resource is updated in the registry. Type Promise × Search results Close "},"Relationship.html":{"id":"Relationship.html","title":"Class: Relationship","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Relationship Relationship Class representing a relationship between model elements new Relationship(ast) Create a Relationship. Parameters: Name Type Description ast Object The AST created by the parser Source: lib/parser/relationship.js, line 19 Extends Property Methods getName() Returns the name of a field Inherited From: Property#getName Source: lib/parser/property.js, line 70 Returns: the name of this field Type string getType() Returns the type of a field Inherited From: Property#getType Source: lib/parser/property.js, line 78 Returns: the type of this field Type string isArray() Returns true if the field is declared as an array type Inherited From: Property#isArray Source: lib/parser/property.js, line 86 Returns: true if the field is an array type Type boolean × Search results Close "},"SecurityContext.html":{"id":"SecurityContext.html","title":"Class: SecurityContext","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: SecurityContext SecurityContext Class representing the SecurityContext. new SecurityContext(user, password) Create the UserContext. Parameters: Name Type Description user string The user identifier. password string The password. Source: lib/securitycontext.js, line 17 Methods getChaincodeID() Get the chaincode ID. Source: lib/securitycontext.js, line 67 Returns: The chaincode ID. Type string getEnrolledMember() Get the enrolled member. Source: lib/securitycontext.js, line 51 Returns: The enrolled member. Type hfc.Member getPassword() Get the user password Source: lib/securitycontext.js, line 43 Returns: The user password. Type string getUser() Get the current username. Source: lib/securitycontext.js, line 35 Returns: The username Type string setChaincodeID(chaincodeID) Set the chaincode ID. Parameters: Name Type Description chaincodeID string The chaincode ID. Source: lib/securitycontext.js, line 75 setEnrolledMember(enrolledMember) Set the enrolled member. Parameters: Name Type Description enrolledMember hfc.Member The enrolled member. Source: lib/securitycontext.js, line 59 × Search results Close "},"SecurityException.html":{"id":"SecurityException.html","title":"Class: SecurityException","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: SecurityException SecurityException Class representing a security exception new SecurityException(message) Create the SecurityException. Parameters: Name Type Description message string The exception message. Source: lib/securityexception.js, line 19 × Search results Close "},"Serializer.html":{"id":"Serializer.html","title":"Class: Serializer","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: Serializer Serializer Serialize CObject instances to/from various formats. new Serializer(factory, modelManager) Create a Serializer. This should only be called by framework code. Use the Concerto class to get an instance. Parameters: Name Type Description factory Factory The Factory to use to create instances modelManager ModelManager The ModelManager to use for validation etc. Source: lib/serializer.js, line 39 Methods fromJSON(jsonData) Create a CObject from a serialized JSON text string Parameters: Name Type Description jsonData string The serialized JSON text string Source: lib/serializer.js, line 82 Returns: The new instance Type CObject toJSON(cObject) Convert the CObject to a JSON string. Parameters: Name Type Description cObject CObject The instance to convert to JSON Source: lib/serializer.js, line 63 Throws: - throws an exception if cObject is not an instance of CObject or fails validation. Type Error Returns: - The JSON serialization of the instance Type string × Search results Close "},"TestUtil.html":{"id":"TestUtil.html","title":"Class: TestUtil","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: TestUtil TestUtil A class containing test utilities for use in Concerto system tests. new TestUtil() Source: systest/testutil.js, line 23 Methods &lt;static&gt; clearWorldState() Invoke the chain-code to clear all of the world state so that any test data is removed. Call in-between tests. Source: systest/testutil.js, line 127 Returns: - a promise that will be resolved once the chain-code has been invoked. Type Promise &lt;static&gt; getConcerto() Get a configured and connected instance of Concerto. Source: systest/testutil.js, line 67 Returns: - a promise that wil be resolved with a configured and connected instance of Concerto. Type Promise &lt;static&gt; getSecurityContext() Get a logged in security context for interacting with Concerto. Source: systest/testutil.js, line 114 Returns: - a promise that will be resolved with a logged in security context for interacting with Concerto. Type Promise &lt;static&gt; waitForPeer() Wait for the peer on the specified hostname and port to start listening on the specified port. Source: systest/testutil.js, line 31 Returns: - a promise that will be resolved when the peer has started listening on the specified port. Type Promise × Search results Close "},"TransactionDeclaration.html":{"id":"TransactionDeclaration.html","title":"Class: TransactionDeclaration","body":" DocStrap Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionCBaseClassDeclarationCObjectCRelationshipFactoryFieldFileWriterGoLangVisitorIllegalModelExceptionModelFileModelManagerModelRegistryibm-concerto~ConcertoParticipantDeclarationPropertyRegistryRelationshipSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclaration Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFilereplacertoUMLFilename Class: TransactionDeclaration TransactionDeclaration Class representing the definition of an Transaction. new TransactionDeclaration(modelFile, ast) Create an TransactionDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/transactiondeclaration.js, line 18 Extends SubclassableDeclaration × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
