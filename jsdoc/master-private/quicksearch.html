<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_parser_assetdeclaration.js.html":{"id":"lib_parser_assetdeclaration.js.html","title":"Source: lib/parser/assetdeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/assetdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * AssetDeclaration defines the schema (aka model or class) for * an Asset. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private */ class AssetDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } } module.exports = AssetDeclaration; Ã— Search results Close "},"lib_assetregistry.js.html":{"id":"lib_assetregistry.js.html","title":"Source: lib/assetregistry.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/assetregistry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Resource = require('./model/resource'); const Registry = require('./registry'); const Util = require('./util'); const REGISTRY_TYPE = 'Asset'; /** * The AssetRegistry is used to manage a set of assets stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;diagrams/assetregistry.svg&quot;&gt;&lt;img src=&quot;diagrams/assetregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry */ class AssetRegistry extends Registry { /** * Get a list of all existing asset registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link AssetRegistry} * instances representing the asset registries. */ static getAllAssetRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then(function (assetRegistries) { return assetRegistries.map(function (assetRegistry) { return new AssetRegistry(assetRegistry.id, assetRegistry.name, modelManager, factory, serializer); }); }); } /** * Get an existing asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the asset registry. */ static getAssetRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then(function (registry) { return new AssetRegistry(registry.id, registry.name, modelManager, factory, serializer); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {string} name The name of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the new asset registry. */ static addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(function () { return new AssetRegistry(id, name, modelManager, factory, serializer); }); } /** * Create an asset registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the asset registry. * @param {string} name The display name for the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. */ constructor(id, name, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; } /** * Adds an asset to the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {Resource} asset The asset to be added to the asset registry. * @return {Promise} A promise that is resolved when the asset is added to * the asset registry. */ add(securityContext, asset) { Util.securityCheck(securityContext); if (!asset) { throw new Error('asset not specified'); } let data = this.serializer.toJSON(asset); return super.add(securityContext, asset.getIdentifier(), JSON.stringify(data)); } /** * Updates an asset in the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {Resource} asset The asset to be updated in the asset registry. * @return {Promise} A promise that is resolved when the asset is updated * in the asset registry. */ update(securityContext, asset) { Util.securityCheck(securityContext); if (!asset) { throw new Error('asset not specified'); } let data = this.serializer.toJSON(asset); return super.update(securityContext, asset.getIdentifier(), JSON.stringify(data)); } /** * Remove an asset with a given type and id from the asset registry. * * @param {SecurityContext} securityContext The user's security context. * @param {(Resource|string)} asset The asset, or the unique identifier of the asset. * @return {Promise} A promise that is resolved when the element is removed * from the registry. */ remove(securityContext, asset) { Util.securityCheck(securityContext); if (!asset) { throw new Error('asset not specified'); } let id; if (asset instanceof Resource) { id = asset.getIdentifier(); } else { id = asset; } return super.remove(securityContext, id); } /** * Get all of the assets in the registry. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} instances representing the assets. */ getAll(securityContext) { Util.securityCheck(securityContext); let self = this; return Util.queryChainCode(securityContext, 'getAllAssetsInAssetRegistry', [this.id, 'false']) .then(function (buffer) { return JSON.parse(buffer.toString()); }) .then(function (resources) { return resources.map(function (resource) { return self.serializer.fromJSON(JSON.parse(resource.data)); }); }); } /** * Get all of the assets in the registry, and resolve all of their relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved asset. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the assets and all of their resolved relationships. */ resolveAll(securityContext) { Util.securityCheck(securityContext); return Util.queryChainCode(securityContext, 'getAllAssetsInAssetRegistry', [this.id, 'true']) .then(function (buffer) { return JSON.parse(buffer.toString()); }) .then(function (resources) { return resources.map(function (resource) { return JSON.parse(resource.data); }); }); } /** * Get a specific asset in the registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset. * @param {boolean} [options.resolve] Resolve all of the assets relationships. * @return {Promise} A promise that will be resolved with a {@link Resource} * instance representing the asset. */ get(securityContext, id) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } let self = this; return Util.queryChainCode(securityContext, 'getAssetInAssetRegistry', [this.id, id, 'false']) .then(function (buffer) { return JSON.parse(buffer.toString()); }) .then(function (resource) { return self.serializer.fromJSON(JSON.parse(resource.data)); }); } /** * Get a specific asset in the registry, and resolve all of its relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved asset. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset. * @return {Promise} A promise that will be resolved with a JavaScript object * representing the asset and all of its resolved relationships. */ resolve(securityContext, id) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getAssetInAssetRegistry', [this.id, id, 'true']) .then(function (buffer) { return JSON.parse(buffer.toString()); }) .then(function (resource) { return JSON.parse(resource.data); }); } } module.exports = AssetRegistry; Ã— Search results Close "},"lib_baseexception.js.html":{"id":"lib_baseexception.js.html","title":"Source: lib/baseexception.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/baseexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * A base class for all Concerto exceptions * &lt;p&gt;&lt;a href=&quot;diagrams/baseexception.svg&quot;&gt;&lt;img src=&quot;diagrams/baseexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Error */ class BaseException extends Error { /** * Create the BaseException. * @param {string} message - The exception message. */ constructor(message) { super(message); this.name = this.constructor.name; this.message = message; Error.captureStackTrace(this, this.constructor); } } module.exports = BaseException; Ã— Search results Close "},"lib_parser_classdeclaration.js.html":{"id":"lib_parser_classdeclaration.js.html","title":"Source: lib/parser/classdeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/classdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Field = require('./field'); const EnumValueDeclaration = require('./enumvaluedeclaration'); const RelationshipDeclaration = require('./relationshipdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); /** * ClassDeclaration defines the structure (model/schema) of composite data. * It is composed of a set of Properties, may have an identifying field, and may * have a super-type. * A ClassDeclaration is conceptually owned with a ModelFile which * defines all the classes that are part of a namespace. * * This class is abstract and should not be instantiated. * @private * @abstract */ class ClassDeclaration { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { if(!modelFile || !ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; this.modelFile = modelFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.properties = []; this.superType = null; this.idField = null; this.abstract = false; if(this.ast.abstract) { this.abstract = true; } if(this.ast.classExtension) { this.superType = this.ast.classExtension.class.name; } if(this.ast.idField) { this.idField = this.ast.idField.name; } for(let n=0; n &lt; this.ast.body.declarations.length; n++ ) { let thing = this.ast.body.declarations[n]; //console.log('Found: ' + thing.type + ' ' + thing.id.name); if(thing.type === 'FieldDeclaration') { this.properties.push( new Field(this, thing) ); } else if(thing.type === 'RelationshipDeclaration') { this.properties.push( new RelationshipDeclaration(this, thing) ); } else if(thing.type === 'EnumPropertyDeclaration') { this.properties.push( new EnumValueDeclaration(this, thing) ); } else { let formatter = Globalize.messageFormatter('classdeclaration-process-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type })); } } } /** * Semantic validation of the structure of this class. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {InvalidModelException} * @private */ validate() { // TODO (LG) check that all imported classes exist, rather than just // used imports // if we have a super type make sure it exists if(this.superType!==null) { let classDecl = null; if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } } // TODO (DCS) we need to validate that the super type is compatible // with this class. e.g. an asset cannot extend a transaction... if(this.idField) { const field = this.getProperty(this.idField); if(!field) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotproperty'); throw new IllegalModelException(formatter({ 'class': this.name, 'idField': this.idField })); } else { // check that identifiers are strings if(field.getType() !== 'String') { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotstring'); throw new IllegalModelException( formatter({ 'class': this.name, 'idField': this.idField })); } if(field.isOptional()) { throw new IllegalModelException('Identifying fields cannot be optional.'); } } } // we also have to check fields defined in super classes const properties = this.getProperties(); for(let n=0; n &lt; properties.length; n++) { let field = properties[n]; // check we don't have a field with the same name for(let i=n+1; i &lt; properties.length; i++) { let otherField = properties[i]; if(field.getName() === otherField.getName()) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-duplicatefieldname'); throw new IllegalModelException( formatter({ 'class': this.name, 'fieldName': field.getName() })); } } field.validate(this); } } /** * Returns true if this class is declared as abstract in the model file * * @return {boolean} true if the class is abstract */ isAbstract() { return this.abstract; } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return false; } /** * Returns the short name of a class. This name does not include the * namespace from the owning ModelFile. * * @return {string} the short name of this class */ getName() { return this.name; } /** * Returns the fully qualified name of this class. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this class */ getFullyQualifiedName() { return this.modelFile.getNamespace() + '.' + this.name; } /** * Returns the name of the identifying field for this class. Note * that the identifying field may come from a super type. * * @return {string} the name of the id field for this class */ getIdentifierFieldName() { if(this.idField) { return this.idField; } else { let classDecl = this.modelFile.getModelManager().getType(this.getSuperType()); return classDecl.getIdentifierFieldName(); } } /** * Returns the field with a given name or null if it does not exist. * The field must be directly owned by this class -- the super-type is * not introspected. * * @param {string} name the name of the field * @return {Property} the field definition or null if it does not exist. */ getOwnProperty(name) { for(let n=0; n &lt; this.properties.length; n++) { const field = this.properties[n]; if(field.getName() === name) { return field; } } return null; } /** * Returns the fields directly defined by this class. * * @return {Property[]} the array of fields */ getOwnProperties() { return this.properties; } /** * Returns the FQN of the super type for this class or null if this * class does not have a super type. * * @return {string} the FQN name of the super type or null */ getSuperType() { if(this.superType) { const type = this.getModelFile().getType(this.superType); if(type === null) { throw new Error('Could not find super type:' + this.superType ); } else { return type.getFullyQualifiedName(); } } return null; } /** * Returns the property with a given name or null if it does not exist. * Fields defined in super-types are also introspected. * * @param {string} name the name of the field * @return {Property} the field, or null if it does not exist */ getProperty(name) { let result = this.getOwnProperty(name); let classDecl = null; if(result === null &amp;&amp; this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } result = classDecl.getProperty(name); } return result; } /** * Returns the properties defined in this class and all super classes. * * @return {Property[]} the array of fields */ getProperties() { let result = this.getOwnProperties(); let classDecl = null; if(this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } // go get the fields from the super type result = result.concat(classDecl.getProperties()); } else { // console.log('No super type for ' + this.getName() ); } return result; } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { let result = { name: this.name, idField: this.idField, superType: this.superType, abstract: this.abstract }; result.fields = this.properties.filter((property) =&gt; { return property instanceof Field; }); result.relationships = this.properties.filter((property) =&gt; { return property instanceof RelationshipDeclaration; }); result.enumValues = this.properties.filter((property) =&gt; { return property instanceof EnumValueDeclaration; }); return result; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { let superType = ''; if(this.superType) { superType = ' super=' + this.superType; } return 'ClassDeclaration {id=' + this.getFullyQualifiedName() + superType + ' enum=' + this.isEnum() + ' abstract=' + this.isAbstract() + '}'; } } module.exports = ClassDeclaration; Ã— Search results Close "},"lib_concerto.js.html":{"id":"lib_concerto.js.html","title":"Source: lib/concerto.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/concerto.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const AssetRegistry = require('./assetregistry'); const Factory = require('./factory'); const ModelManager = require('./modelmanager'); const ModelRegistry = require('./modelregistry'); const SecurityContext = require('./securitycontext'); const Serializer = require('./serializer'); const TransactionDeclaration = require('./parser/transactiondeclaration'); const TransactionRegistry = require('./transactionregistry'); const Util = require('./util'); const Globalize = require('./globalize'); const hfc = require('hfc'); /** * Main entry point into the Concerto solution framework. Use this class * to retrieve the services defined by the solution framework and to interact * with the underlying Hyperledger fabric. This class is designed to be used in a * Node.js based middle-tier of a 3-tier application: * &lt;ol&gt; * &lt;li&gt;Presentation tier, e.g. Angular front-end&lt;/li&gt; * &lt;li&gt;Middle tier, exposes domain specific REST APIs to the presentation tier * and embeds the Concerto module to communicate with Hyperledger fabric.&lt;/li&gt; * &lt;li&gt;Hyperledger fabric, used to store assets and transaction on a blockchain&lt;/li&gt; * &lt;/ol&gt; * &lt;p&gt; * The Concerto class provides access to the major subsystems defined by the framework: * &lt;ul&gt; * &lt;li&gt;{@link ModelManager} to declare the structure of Resources for an application domain * &lt;li&gt;{@link Factory} to create instances of Resources (Assets, Transactions or Participants) * &lt;li&gt;{@link Serializer} to convert Resources to/from JavaScript Objects for long-term persistence * &lt;li&gt;{@link AssetRegistry} to store Assets on the blockchain * &lt;li&gt;{@link TransactionRegistry} to store Transactions on the blockchain * &lt;li&gt;{@link Concerto#submitTransaction submitTransaction} to submit Transaction for processing to the Hyperledger fabric. * &lt;/ul&gt; * &lt;/p&gt; * &lt;p&gt; * The {@link Concerto#connect connect} method is used to connect to a Hyperledger * fabric instance. * &lt;/p&gt; * &lt;p&gt; * The {@link Concerto#login login} method is used to authenticate a user/application * with the Hyperledger fabric and returns a {@link SecurityContext} that must be * passed to other Concerto APIs that require authentication. * &lt;/p&gt; * &lt;h4&gt;Bootstrapping the Concerto Framework&lt;/h4&gt; * &lt;p&gt; * The {@link Concerto#deploy deploy} method is used to deploy the Concerto Framework chaincode * to your Hyperledger instance. This only needs to be called once for all Concerto * based application that use a Hyperledger fabric instance. * &lt;/p&gt; * &lt;h4&gt;Bootstrapping your Application&lt;/h4&gt; * Bootrapping a Concerto-based application requires: * &lt;ol&gt; * &lt;li&gt;Connecting to the Hyperledger Fabric using the {@link Concerto.connect connect} method * &lt;li&gt;Login to the Hyperledger Fabric using the {@link Concerto.login login} method * &lt;li&gt;Load the application's domain specific Concerto files and add to the {@link ModelManager} * &lt;li&gt;Use the {@link Concerto#saveModels saveModels} method to store the contents of the {@link ModelManager} * on the blockchain. * &lt;/ol&gt; * Application bootstrap only needs to be performed once for a given Hyperledger fabric instance, * or when the Concerto files have been modified. */ class Concerto { /** * Create an instance of the Concerto class. * @param {Object} [options] - an optional set of options to configure the instance. * @param {boolean} [options.developmentMode] - specify whether or not the instance * is in development mode. Use only for testing purposes! */ constructor(options) { this.modelManager = new ModelManager(); this.factory = new Factory(this.modelManager); this.serializer = new Serializer(this.factory, this.modelManager); this.chain = null; this.developmentMode = false; if (options &amp;&amp; options.developmentMode) { this.developmentMode = true; } } /** * Get a list of all existing asset registries. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * asset registries */ getAllAssetRegistries(securityContext) { Util.securityCheck(securityContext); return AssetRegistry.getAllAssetRegistries(securityContext, this.modelManager, this.factory, this.serializer); } /** * Get an existing asset registry. * @param {SecurityContext} securityContext - The user's security context * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with the existing asset * registry, or rejected if the asset registry does not exist. */ getAssetRegistry(securityContext, id) { Util.securityCheck(securityContext); return AssetRegistry.getAssetRegistry(securityContext, id, this.modelManager, this.factory, this.serializer); } /** * Add a new asset registry. * @param {SecurityContext} securityContext - The user's security context * @param {string} id - The unique identifier of the asset registry * @param {string} name - The name of the asset registry * @return {Promise} - A promise that will be resolved with the new asset * registry after it has been added. */ addAssetRegistry(securityContext, id, name) { Util.securityCheck(securityContext); return AssetRegistry.addAssetRegistry(securityContext, id, name, this.modelManager, this.factory, this.serializer); } /** * Get the model registry. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with the model registry. * @private */ getModelRegistry(securityContext) { Util.securityCheck(securityContext); return ModelRegistry .getAllModelRegistries(securityContext, this.modelManager) .then(function (modelRegistries) { if (modelRegistries.length &gt;= 1) { return modelRegistries[0]; } else { throw new Error('Failed to find the default model registry'); } }); } /** * Get the transaction registry. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved to the {@link TransactionRegistry} */ getTransactionRegistry(securityContext) { Util.securityCheck(securityContext); return TransactionRegistry .getAllTransactionRegistries(securityContext, this.modelManager, this.factory, this.serializer) .then(function (transactionRegistries) { if (transactionRegistries.length &gt;= 1) { return transactionRegistries[0]; } else { throw new Error('Failed to find the default transaction registry'); } }); } /** * Returns the Factory, used to create instances of Resources, Relationships * and Transactions. * * @param {SecurityContext} securityContext - The user's security context * @return {Factory} the Factory */ getFactory(securityContext) { Util.securityCheck(securityContext); return this.factory; } /** * Returns the ModelManager, used to define the entities in an application domain. * @param {SecurityContext} securityContext - The user's security context * @return {ModelManager} the ModelManager */ getModelManager(securityContext) { Util.securityCheck(securityContext); return this.modelManager; } /** * Returns the Serializer * @param {SecurityContext} securityContext - The user's security context * @return {Serializer} the Serializer */ getSerializer(securityContext) { Util.securityCheck(securityContext); return this.serializer; } /** * Connects to the Hyperledger Fabric. * @param {Object} connectOptions - The connection options. * @param {string} connectOptions.keyValStore - The local directory to store * user certificates in. * @param {string} connectOptions.membershipServicesURL - The URL of the * Hyperledger Fabric membership services to connect to. * @param {string} connectOptions.peerURL - The URL of the Hyperledger Fabric * peer to connect to. * @param {string} connectOptions.eventHubURL - The URL of the Hyperledger Fabric * event hub to connect to. * @return {Promise} A promise that will be resolved when the connection is * established. */ connect(connectOptions) { let self = this; if (!connectOptions) { throw new Error(Globalize.formatMessage('concerto-connect-noconopts')); } else if (!connectOptions.keyValStore) { throw new Error(Globalize.formatMessage('concerto-connect-nokeyvalstore')); } else if (!connectOptions.membershipServicesURL) { throw new Error(Globalize.formatMessage('concerto-connect-nomembersrvcurl')); } else if (!connectOptions.peerURL) { throw new Error(Globalize.formatMessage('concerto-connect-nopeerurl')); } else if (!connectOptions.eventHubURL) { throw new Error(Globalize.formatMessage('concerto-connect-noeventhuburl')); } return new Promise(function (resolve, reject) { self.chain = hfc.newChain('Concerto'); self.chain.setKeyValStore(hfc.newFileKeyValStore(connectOptions.keyValStore)); self.chain.setMemberServicesUrl(connectOptions.membershipServicesURL); self.chain.addPeer(connectOptions.peerURL); if (connectOptions.deployWaitTime) { self.chain.setDeployWaitTime(connectOptions.deployWaitTime); } if (connectOptions.invokeWaitTime) { self.chain.setInvokeWaitTime(connectOptions.invokeWaitTime); } self.chain.eventHubConnect(connectOptions.eventHubURL); process.on('exit', () =&gt; { if (self.chain) { self.chain.eventHubDisconnect(); self.chain = null; } }); resolve(); }); } /** * Disconnects from the Hyperledger Fabric. * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { let self = this; return new Promise(function (resolve, reject) { if (self.chain) { self.chain.eventHubDisconnect(); self.chain = null; } resolve(); }); } /** * Log in to the Hyperledger Fabric as the specified user * * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @return {Promise} A promise that will be resolved with a {SecurityContext} * when the the security context */ login(enrollmentID, enrollmentSecret) { let self = this; if (!enrollmentID) { throw new Error(Globalize.formatMessage('concerto-login-noenrollmentid')); } else if (!enrollmentSecret) { throw new Error(Globalize.formatMessage('concerto-login-noenrollmentsecret')); } return new Promise(function (resolve, reject) { self.chain.enroll(enrollmentID, enrollmentSecret, function (error, enrolledMember) { if (error) { return reject(error); } let result = new SecurityContext(enrollmentID, enrollmentSecret); result.setEnrolledMember(enrolledMember); result.setEventHub(self.chain.getEventHub()); resolve(result); }); }); } /** * Deploys the Concerto chain-code to the Hyperledger Fabric. * @param {SecurityContext} securityContext - The user's security context * @param {boolean} [force] - Force a new instance of the chain-code to deploy. * @return {Promise} A promise that will be fufilled when the chain-code has * been deployed. */ deploy(securityContext, force) { let self = this; if (!securityContext) { throw new Error(Globalize.formatMessage('concerto-deploy-nosecuritycontext')); } return Util .deployChainCode(securityContext, 'concerto', 'init', [this.developmentMode.toString()], force) .then(function (result) { securityContext.setChaincodeID(result.chaincodeID); }) .then(function () { return ModelRegistry.getAllModelRegistries(securityContext, self.modelManager); }) .then(function (modelRegistries) { if (modelRegistries.length === 0) { return ModelRegistry.addModelRegistry(securityContext, 'default', 'Default Model Registry', self.modelManager); } }) .then(function () { return TransactionRegistry.getAllTransactionRegistries(securityContext, self.modelManager, self.factory, self.serializer); }) .then(function (transactionRegistries) { if (transactionRegistries.length === 0) { return TransactionRegistry.addTransactionRegistry(securityContext, 'default', 'Default Transaction Registry', self.modelManager, self.factory, self.serializer); } }); } /** * Load the models previously saved using {@link Concerto#saveModels saveModels} * from the blockchain back into the {@link ModelManager}. Note that any * existing models in the ModelManager will be cleared. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} A promise that will be fufilled when the models have been * loaded into the {@link ModelManager} */ loadModels(securityContext) { let self = this; Util.securityCheck(securityContext); return this .getModelRegistry(securityContext) .then((modelRegistry) =&gt; { return modelRegistry.getAll(securityContext); }) .then((models) =&gt; { self.modelManager.clearModelFiles(); self.modelManager.addModelFiles(models); }); } /** * Save all of the models in the {@link ModelManager} to the blockchain. * @param {SecurityContext} securityContext - The user's security context * @return {Promise} A promise that will be fufilled when the models have been * saved to the blockchain. */ saveModels(securityContext) { let self = this; Util.securityCheck(securityContext); return this .getModelRegistry(securityContext) .then((modelRegistry) =&gt; { let promises = []; self.modelManager.getModelFiles().forEach((modelFile) =&gt; { promises.push(modelRegistry.add(securityContext, modelFile)); }); return Promise.all(promises); }); } /** * Submit a transaction for processing to the Hyperledger fabric. * @param {SecurityContext} securityContext - The user's security context * @param {Resource} transaction - The transaction to submit. Use {@link * Factory#newTransaction newTransaction} to create this object. * @return {Promise} A promise that will be fufilled when the transaction has * been processed. */ submitTransaction(securityContext, transaction) { Util.securityCheck(securityContext); if (!transaction) { throw new Error('transaction not specified'); } else if (!(transaction.getClassDeclaration() instanceof TransactionDeclaration)) { throw new Error(transaction.getClassDeclaration().getFullyQualifiedName() + ' is not a transaction'); } let id = transaction.getIdentifier(); let data = this.serializer.toJSON(transaction); return this.getTransactionRegistry(securityContext) .then(function (transactionRegistry) { return Util.invokeChainCode(securityContext, 'submitTransaction', [transactionRegistry.id, id, JSON.stringify(data)]); }); } } module.exports = Concerto; Ã— Search results Close "},"lib_codegen_filewriter.js.html":{"id":"lib_codegen_filewriter.js.html","title":"Source: lib/codegen/filewriter.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/filewriter.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const fs = require('fs'); const path = require('path'); const Writer = require('./writer'); /** * FileWriter creates text files under a directory tree. It can be used * by code generators to create source files for example. * Basic usage is: openFile(fileName), writeLine(...), closeFile(). * * @private */ class FileWriter extends Writer { /** * Create a FileWriter. * * @param {string} outputDirectory - the path to an output directory * that will be used to store generated files. */ constructor(outputDirectory) { super(); this.outputDirectory = outputDirectory; this.relativeDir = null; this.fileName = null; ensureDirectoryExistence(outputDirectory); } /** * Opens a file for writing. The file will be created in the * root directory of this FileWriter. * * @param {string} fileName - the name of the file to open */ openFile(fileName) { this.fileName = fileName; this.relativeDir = null; } /** * Opens a file for writing, with a location relative to the * root directory of this FileWriter. * * @param {string} relativeDir - the relative directory to use * @param {string} fileName - the name of the file to open */ openRelativeFile(relativeDir, fileName) { this.relativeDir = relativeDir; this.fileName = fileName; } /** * Writes text to the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { if (this.fileName) { super.writeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Writes text to the start of the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { if (this.fileName) { super.writeBeforeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Closes the current open file */ closeFile() { if (!this.fileName) { throw new Error('No file open'); } let path = this.outputDirectory; if(!path.endsWith('/')) { path += '/'; } if (this.relativeDir) { path += this.relativeDir; } if(!path.endsWith('/')) { path += '/'; } path += this.fileName; ensureDirectoryExistence(path); //console.log('Writing to ' + path ); fs.writeFileSync(path, this.getBuffer()); this.fileName = null; this.relativeDir = null; this.clearBuffer(); } } /** * Checks that an entire directory tree exists, and creates * it if it does not. * * @param {string} filePath - the file path to check * @return {boolean} true if the directory exists * @private */ function ensureDirectoryExistence(filePath) { let dirname = path.dirname(filePath); if (directoryExists(dirname)) { return true; } ensureDirectoryExistence(dirname); fs.mkdirSync(dirname); return false; } /** * Returns true if the given directory exists. * * @param {string} path - the file path to check * @return {boolean} true if the directory exists * @private */ function directoryExists(path) { try { return fs.statSync(path).isDirectory(); } catch (err) { return false; } } module.exports = FileWriter; Ã— Search results Close "},"lib_parser_enumdeclaration.js.html":{"id":"lib_parser_enumdeclaration.js.html","title":"Source: lib/parser/enumdeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/enumdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * EnumDeclaration defines an enumeration of static values. * @private * @extends ClassDeclaration */ class EnumDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return true; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'EnumDeclaration {id=' + this.getFullyQualifiedName() + '}'; } } module.exports = EnumDeclaration; Ã— Search results Close "},"lib_parser_enumvaluedeclaration.js.html":{"id":"lib_parser_enumvaluedeclaration.js.html","title":"Source: lib/parser/enumvaluedeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/enumvaluedeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Property = require('./property'); /** * Class representing a value from a set of enumerated values * @private * @extends Property */ class EnumValueDeclaration extends Property { /** * Create a EnumValueDeclaration. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { super.validate(classDecl); } } module.exports = EnumValueDeclaration; Ã— Search results Close "},"lib_parser_property.js.html":{"id":"lib_parser_property.js.html","title":"Source: lib/parser/property.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/property.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelUtil = require('../modelutil'); /** * Property representing an attribute of a class declaration, * either a Field or a Relationship. * @private */ class Property { /** * Create a Property. * @param {ClassDeclaration} parent - the owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { this.ast = ast; this.parent = parent; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the owner of this property * @return {ClassDeclaration} the parent class declaration */ getParent() { return this.parent; } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; if(!this.name) { throw new Error('No name for type ' + this.ast ); } if(this.ast.propertyType) { this.type = this.ast.propertyType.name; } else { this.type = null; } this.array = false; if(this.ast.array) { this.array = true; } if(this.ast.optional) { this.optional = true; } else { this.optional = false; } } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { if(this.type) { classDecl.getModelFile().resolveType('Property type ' + this.name, this.type); } } /** * Returns the name of a property * @return {string} the name of this field */ getName() { return this.name; } /** * Returns the type of a property * @return {string} the type of this field */ getType() { return this.type; } /** * Returns true if the field is optional * @return {boolean} true if the field is optional */ isOptional() { return this.optional; } /** * Returns the fully qualified type name of a property * @return {string} the fully qualified type of this property */ getFullyQualifiedTypeName() { if(this.isPrimitive()) { return this.type; } const parent = this.getParent(); if(!parent) { throw new Error('Property ' + this.name + ' does not have a parent.'); } const modelFile = parent.getModelFile(); if(!modelFile) { throw new Error('Parent of property ' + this.name + ' does not have a ModelFile!'); } const result = modelFile.getFullyQualifiedTypeName(this.type); if(!result) { throw new Error('Failed to find fully qualified type name for property ' + this.name + ' with type ' + this.type ); } return result; } /** * Returns the namespace of the parent of this property * @return {string} the namespace of the parent of this property */ getNamespace() { return this.getParent().getModelFile().getNamespace(); } /** * Returns true if the field is declared as an array type * @return {boolean} true if the property is an array type */ isArray() { return this.array; } /** * Returns true if the field is declared as an enumerated value * @return {boolean} true if the property is an enumerated value */ isTypeEnum() { if(this.isPrimitive()) { return false; } else { const type = this.getParent().getModelFile().getType(this.getType()); return type.isEnum(); } } /** * Returns true if this property is a primitive type. *@return {boolean} true if the property is a primitive type. */ isPrimitive() { return ModelUtil.isPrimitiveType(this.getType()); } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { return { name: this.name, type: this.type, array: this.array, 'enum': (this.type === null) }; } } module.exports = Property; Ã— Search results Close "},"lib_factory.js.html":{"id":"lib_factory.js.html","title":"Source: lib/factory.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/factory.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Resource = require('./model/resource'); const ResourceValidator = require('./serializer/resourcevalidator'); const ValidatedResource = require('./model/validatedresource'); const Relationship = require('./model/relationship'); const debug = require('debug')('ibm-concerto'); const Globalize = require('./globalize'); const uuid = require('node-uuid'); const TransactionDeclaration = require('./parser/transactiondeclaration'); /** * Use the Factory to create instances of Resource: transactions, participants * and assets. * &lt;p&gt;&lt;a href=&quot;diagrams/factory.svg&quot;&gt;&lt;img src=&quot;diagrams/factory.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class Factory { /** * Create the factory. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this registry */ constructor(modelManager) { this.modelManager = modelManager; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @param {boolean} disableValidation - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @return {Resource} the new instance * @throws {ModelException} if the type is not registered with the ModelManager */ newInstance(ns, type, id, disableValidation) { let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newinstance-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let classDecl = modelFile.getType(type); if(classDecl.isAbstract()) { throw new Error('Cannot create abstract type ' + classDecl.getFullyQualifiedName()); } let newObj = null; if(disableValidation) { newObj = new Resource(this.modelManager,ns,type,id); } else { newObj = new ValidatedResource(this.modelManager,ns,type,id, new ResourceValidator()); } newObj.assignFieldDefaults(); // if we have an identifier, we set it now let idField = classDecl.getIdentifierFieldName(); if(idField) { newObj[idField] = id; } debug('Factory.newInstance created %s', id ); return newObj; } /** * Create a new Relationship with a given namespace, type and identifier. ` * A relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @return {Relationship} - the new relationship instance * @throws {ModelException} if the type is not registered with the ModelManager */ newRelationship(ns, type, id) { let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newrelationship-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let relationship = new Relationship(this.modelManager,ns,type,id); return relationship; } /** * Create a new transaction object. The identifier of the transaction is * set to a UUID. * @param {string} ns - the namespace of the transaction. * @param {string} type - the type of the transaction. * @return {Resource} A resource for the new transaction. */ newTransaction(ns, type) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } let id = uuid.v4(); let transaction = this.newInstance(ns, type, id); if (!(transaction.getClassDeclaration() instanceof TransactionDeclaration)) { throw new Error(transaction.getClassDeclaration().getFullyQualifiedName() + ' is not a transaction'); } return transaction; } } module.exports = Factory; Ã— Search results Close "},"lib_parser_field.js.html":{"id":"lib_parser_field.js.html","title":"Source: lib/parser/field.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/field.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Property = require('./property'); /** * Class representing the definition of a Field. A Field is owned * by a ClassDeclaration and has a name, type and additional metadata * (see below). * @private * @extends Property */ class Field extends Property { /** * Create an Field. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { super.process(); if(this.ast.validator) { this.validator = this.ast.validator.text.value; } else { this.validator = null; } if(this.ast.default) { this.defaultValue = this.ast.default.text.value; } else { this.defaultValue = null; } } /** * Returns the validator string for this field * @return {string} the validator for the field or null */ getValidator() { return this.validator; } /** * Returns the default value for the field or null * @return {string} the default value for the field or null */ getDefaultValue() { if(this.defaultValue) { return this.defaultValue; } else { return null; } } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { let result = super.toJSON(); result.validator = this.validator; result.defaultValue = this.defaultValue; result.optional = this.optional; return result; } /** * Returns a string representation of this propertyÂ§ * @return {String} the string version of the property. */ toString() { return 'Field {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; } } module.exports = Field; Ã— Search results Close "},"lib_codegen_umlgen.js.html":{"id":"lib_codegen_umlgen.js.html","title":"Source: lib/codegen/umlgen.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/umlgen.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const fs = require('fs'); const path = require('path'); const program = require('commander'); const acorn = require('acorn'); const FileWriter = require('./filewriter'); /** * Generates Plant UML files from Javascript source files * * node ./lib/codegen/umlgen.js * --outputDir &lt;location to write UML files&gt; * --inputDir &lt;location to recursively read .js files&gt; */ program .version('0.0.1') .description('Generates PlantUML model files from Javascript source') .usage('[options]') .option('-o, --outputDir &lt;outputDir&gt;', 'Output directory') .option('-i, --inputDir &lt;inputDir&gt;', 'Input source directory') .option('-p, --private', 'Include classes that have the @private JSDoc annotation') .parse(process.argv); // Loop through all the files in the input directory processDirectory(program.inputDir); /** * @param {string} path - the path to process * @private */ function processDirectory(path) { fs.readdir(path, function(err, files) { if (err) { console.error('Could not list the directory.', err); process.exit(1); } files.forEach(function(file, index) { let stats = fs.statSync(path + '/' + file); if (stats.isFile()) { processFile(path + '/' + file); } else if (stats.isDirectory()) { processDirectory(path + '/' + file); } }); }); } /** * @param {string} file - the file to process * @private */ function processFile(file) { let filePath = path.parse(file); if (filePath.ext === '.js') { console.log('%s is a file.', file); let fileContents = fs.readFileSync(file, 'utf8'); let comments = [], tokens = []; let ast = acorn.parse(fileContents, { // collect ranges for each node ranges: true, // collect comments in Esprima's format onComment: comments, // collect token ranges onToken: tokens }); const includes = []; const classes = []; const methods = []; for (let n = 0; n &lt; ast.body.length; n++) { let statement = ast.body[n]; if (statement.type === 'VariableDeclaration') { let variableDeclarations = statement.declarations; for (let n = 0; n &lt; variableDeclarations.length; n++) { let variableDeclaration = variableDeclarations[n]; if (variableDeclaration.init.type === 'CallExpression' &amp;&amp; variableDeclaration.init.callee.name === 'require') { let requireName = variableDeclaration.init.arguments[0].value; // we only care about the code we require with a relative path if (requireName.startsWith('./')) { includes.push(variableDeclaration.init.arguments[0].value + '.uml'); } } } } else if (statement.type === 'ClassDeclaration') { let closestComment = findCommentBefore(statement.start, statement.end, comments); let privateClass = false; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; privateClass = getVisibility(comment) === '-'; } if(privateClass === false || program.private) { const clazz = {}; clazz.header = 'class ' + statement.id.name + '{'; clazz.methods = []; for(let n=0; n &lt; statement.body.body.length; n++) { let thing = statement.body.body[n]; if (thing.type === 'MethodDefinition') { let closestComment = findCommentBefore(thing.key.start, thing.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = '()'; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = getReturnType(comment); visibility = getVisibility(comment); methodArgs = getMethodArguments(comment); } if(visibility === '+' || program.private) { clazz.methods.push(visibility + ' ' + returnType + ' ' + thing.key.name + methodArgs ); } } } clazz.footer = '}'; if (statement.superClass) { clazz.super = statement.id.name + ' --|&gt; ' + statement.superClass.name; } classes.push(clazz); } } else if (statement.type === 'MethodDefinition') { let closestComment = findCommentBefore(statement.key.start, statement.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = '()'; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = getReturnType(comment); visibility = getVisibility(comment); methodArgs = getMethodArguments(comment); } methods.push(visibility + ' ' + returnType + ' ' + statement.key.name + methodArgs ); } } // generate the output if(classes.length &gt; 0 || methods.length &gt; 0) { let fileWriter = new FileWriter(program.outputDir); console.log('open file: ' + toUMLFilename(program.inputDir, program.outputDir, file)); fileWriter.openFile(toUMLFilename(program.inputDir, program.outputDir, file)); fileWriter.writeLine(0, '@startuml'); for(let n=0; n &lt; includes.length; n++) { // only include files that exist // the file may not exist if it was empty if (fs.existsSync( program.outputDir + '/' + includes[n])) { fileWriter.writeLine(0, '!include ' + includes[n]); } } for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; fileWriter.writeLine(0, clazz.header); for(let i=0; i &lt; clazz.methods.length; i++) { fileWriter.writeLine(1, clazz.methods[i]); } fileWriter.writeLine(0, clazz.footer); if(clazz.super) { fileWriter.writeLine(0, clazz.super); } } for(let n=0; n &lt; methods.length; n++) { fileWriter.writeLine(0, methods[n]); } fileWriter.writeLine(0, '@enduml'); fileWriter.closeFile(); } } } /** * Find the comments that is above and closest to the start of the range. * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string[]} comments - the end of the range * @return {integer} the comment index or -1 if there are no comments * @private */ function findCommentBefore(rangeStart, rangeEnd, comments) { let foundIndex = -1; let distance = -1; for(let n=0; n &lt; comments.length; n++) { let comment = comments[n]; let endComment = comment.end; if(rangeStart &gt; endComment ) { if(distance === -1 || rangeStart - endComment &lt; distance) { distance = rangeStart - endComment; foundIndex = n; } } } return foundIndex; } /** * @param {string} inputDir - the fully qualified input directory * @param {string} outputDir - the fully qualified output directory * @param {string} filename - the fully qualified input file name (.js) * @return {string} the UML file name to use * @private */ function toUMLFilename(inputDir, outputDir, filename) { console.log('inputDir' + inputDir); console.log('outputDir' + outputDir); console.log('filename' + filename); let index = filename.indexOf(inputDir); console.log('index ' + index); let rest = filename.substr(index + 1 + inputDir.length); // let out = outputDir + '/' + rest; let i = rest.lastIndexOf('.'); // console.log('result' + out.substr(0, i) + '.uml' ); return (i &lt; 0) ? '' : rest.substr(0, i) + '.uml'; } /** * Extracts the visibilty from a comment block * @param {string} comment - the comment block * @return {string} the return visibility (either + for public, or - for private) * @private */ function getVisibility(comment) { const PRIVATE = '@private'; let result = '+'; let index = comment.indexOf(PRIVATE); if(index&gt;=0) { result = '-'; } return result; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ function getReturnType(comment) { const RETURN = '@return {'; let result = 'void'; let index = comment.indexOf(RETURN); if(index&gt;=0) { let end = comment.indexOf('}', index+RETURN.length+1); if(end &gt; index) { result = comment.substring(index + RETURN.length, end); } } return result; } /** * Extracts the method arguments from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ function getMethodArguments(comment) { const PARAM = '@param {'; let paramTypes = []; let index = comment.indexOf(PARAM); while(index&gt;=0) { let end = comment.indexOf('}', index+PARAM.length+1); if(end &gt; index) { let aParam = comment.substring(index + PARAM.length, end); paramTypes.push(aParam); } index = comment.indexOf(PARAM, end); } let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } Ã— Search results Close "},"lib_parser_functiondeclaration.js.html":{"id":"lib_parser_functiondeclaration.js.html","title":"Source: lib/parser/functiondeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/functiondeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); /** * FunctionDeclaration defines a function that has been defined * in a model file. If the name of the function starts with 'on' * then the name of the function denotes the name of a transaction * declaration that the function processes. * @private */ class FunctionDeclaration { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { if(!modelFile || !ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; this.modelFile = modelFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Returns the text of this function. * * @return {string} the text that defines the function */ getFunctionText() { return this.functionText; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.functionText = this.ast.functionText; this.params = []; for(let n=0; n &lt; this.ast.params.length;n++) { this.params.push(this.ast.params[n].name); } } /** * Semantic validation of the structure of this function. * * @throws {InvalidModelException} * @private */ validate() { if(this.name.startsWith('on')) { const transactionClassName = this.getTransactionDeclarationName(); let classDecl = null; if(this.getModelFile().isImportedType(transactionClassName)) { let fqnSuper = this.getModelFile().resolveImport(transactionClassName); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(transactionClassName); } if(classDecl===null) { throw new IllegalModelException('Could not find transaction type ' + transactionClassName + ' for transaction processing function ' + this.name ); } if(!(classDecl instanceof TransactionDeclaration)) { throw new IllegalModelException('Function ' + this.getName() + ' processes ' + transactionClassName + ' which is not a transaction.'); } } } /** * Returns the short name of the function (not including namespace). * * @return {string} the name of the function. */ getName() { return this.name; } /** * Returns the short name of the transaction declaration * that is being processed. This is calculated by removing * the 'on' prefix from the function name. * If the function name does not start with 'on' then null * * @return {string} the name of the transaction declaration. */ getTransactionDeclarationName() { if(this.name.startsWith('on')) { return this.name.substring(2); } else { return null; } } /** * Returns the names of the parameters processed by the function. * * @return {string[]} the names of the parameters. */ getParameters() { return this.params; } /** * Returns the fully qualified name of this function. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this function */ getFullyQualifiedName() { return this.modelFile.getNamespace() + '.' + this.name; } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { return { name: this.name, params: this.params, functionText: this.functionText }; } } module.exports = FunctionDeclaration; Ã— Search results Close "},"lib_codegen_golang_golangvisitor.js.html":{"id":"lib_codegen_golang_golangvisitor.js.html","title":"Source: lib/codegen/golang/golangvisitor.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/golang/golangvisitor.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelUtil = require('../../modelutil'); const ModelManager = require('../../modelmanager'); const ModelFile = require('../../parser/modelfile'); const ClassDeclaration = require('../../parser/classdeclaration'); const Field = require('../../parser/field'); const RelationshipDeclaration = require('../../parser/relationshipdeclaration'); const EnumDeclaration = require('../../parser/enumdeclaration'); const EnumValueDeclaration = require('../../parser/enumvaluedeclaration'); const FunctionDeclaration = require('../../parser/functiondeclaration'); const _ = require('underscore'); /** * Convert the contents of a ModelManager to Go Lang code. * All generated code is placed into the 'main' package. Set a * fileWriter property (instance of FileWriter) on the parameters * object to control where the generated code is written to disk. * * @private */ class GoLangVisitor { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ModelManager) { return this.visitModelManager(thing, parameters); } else if (thing instanceof ModelFile) { return this.visitModelFile(thing, parameters); } else if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationship(thing, parameters); } else if (thing instanceof EnumValueDeclaration) { return this.visitEnumValueDeclaration(thing, parameters); } else if (thing instanceof FunctionDeclaration) { // return this.visitEnum(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ModelManager} modelManager - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelManager(modelManager, parameters) { parameters.fileWriter.openFile('main.go'); parameters.fileWriter.writeLine(0, 'package main'); parameters.fileWriter.writeLine(0, 'import \\&quot;fmt\\&quot;'); parameters.fileWriter.writeLine(0, 'type Relationship struct {' ); parameters.fileWriter.writeLine(1, 'Namespace string `json:&quot;namespace&quot;`' ); parameters.fileWriter.writeLine(1, 'Type string `json:&quot;type&quot;`' ); parameters.fileWriter.writeLine(1, 'Identifier string `json:&quot;identifier&quot;`' ); parameters.fileWriter.writeLine(0, '}' ); parameters.fileWriter.writeLine(0, 'func main() {'); parameters.fileWriter.writeLine(1, 'fmt.Printf(\\&quot;Hello, world.\\&quot;)'); parameters.fileWriter.writeLine(0, '}'); parameters.fileWriter.closeFile(); let visitModelFile = function(modelFile) { modelFile.accept(this,parameters); }; _.each(modelManager.getModelFiles(), visitModelFile.bind(this)); return null; } /** * Visitor design pattern * @param {ModelFile} modelFile - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelFile(modelFile, parameters) { // we put all the code into the main package, but we // seperate out into multiple files using the namespaces let packageName = this.toGoPackageName(modelFile.getNamespace()); parameters.fileWriter.openFile(packageName + '.go'); parameters.fileWriter.writeLine(0, 'package main'); if(this.containsDateTimeField(modelFile)) { parameters.fileWriter.writeLine(0, 'import \\&quot;time&quot;' ); } let visitClass = function(classDeclaration) { classDeclaration.accept(this,parameters); }; _.each(modelFile.getAllDeclarations(), visitClass.bind(this)); parameters.fileWriter.closeFile(); return null; } /** * Visitor design pattern * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'type ' + enumDeclaration.getName() + ' int' ); parameters.fileWriter.writeLine(0, 'const (' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(enumDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, ')' ); return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'type ' + classDeclaration.getName() + ' struct {' ); //embed the super-type, because Go Lang does not have 'extends' if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(1, ModelUtil.getShortName(classDeclaration.getSuperType())); } let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { let array = ''; if(field.isArray()) { array = '[]'; } // we export all fields by capitalizing them parameters.fileWriter.writeLine(1, ModelUtil.capitalizeFirstLetter(field.getName()) + ' ' + array + this.toGoType(field.getType()) + ' `json:&quot;' + field.getName() + '&quot;`' ); return null; } /** * Visitor design pattern * @param {EnumValueDeclaration} enumValueDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumValueDeclaration(enumValueDeclaration, parameters) { // is this the first enum value? // if yes, we need to use 'iota' to set the value to zero const isFirstValue = enumValueDeclaration.getParent().getOwnProperties()[0].getName() === enumValueDeclaration.getName(); let iota = ''; if(isFirstValue) { iota = ' ' + enumValueDeclaration.getParent().getName() + ' = 1 + iota'; } // we export all fields by capitalizing them parameters.fileWriter.writeLine(1, ModelUtil.capitalizeFirstLetter(enumValueDeclaration.getName()) + iota ); return null; } /** * Visitor design pattern * @param {Relationship} relationship - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationship(relationship, parameters) { let array = ''; if(relationship.isArray()) { array = '[]'; } // we export all relationships by capitalizing them parameters.fileWriter.writeLine(1, ModelUtil.capitalizeFirstLetter(relationship.getName()) + ' ' + array + 'Relationship `json:&quot;' + relationship.getName() + '&quot;`' ); return null; } /** * Returns true if the ModelFile contains a class that has a DateTime * field. * @param {ModelFile} modelFile - the modelFile * @return {boolean} true if the modelFile contains a class that contains * a field of type DateTime. * @private */ containsDateTimeField(modelFile) { let classDeclarations = modelFile.getAllDeclarations(); for(let n=0; n &lt; classDeclarations.length; n++) { let classDecl = classDeclarations[n]; let fields = classDecl.getProperties(); for(let i=0; i &lt; fields.length; i++) { let field = fields[i]; if(field.getType() === 'DateTime') { return true; } } } return false; } /** * Converts a Concerto type to a Go Lang type. Primitive types are converted * everything else is passed through unchanged. * @param {string} type - the concerto type * @return {string} the corresponding type in Go Lang * @private */ toGoType(type) { switch(type) { case 'DateTime': return 'time.Time'; case 'Boolean': return 'bool'; case 'String': return 'string'; case 'Double': return 'float64'; case 'Long': return 'int64'; case 'Integer': return 'int32'; default: return type; } } /** * Converts a Concerto namespace to a Go package name. * @param {string} namespace - the concerto type * @return {string} the corresponding package name in Go Lang * @private */ toGoPackageName(namespace) { return namespace.replace('.', ''); } } module.exports = GoLangVisitor; Ã— Search results Close "},"lib_model_identifiable.js.html":{"id":"lib_model_identifiable.js.html","title":"Source: lib/model/identifiable.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/model/identifiable.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const IDENTIFIABLE_SYSTEM_PROPERTIES = ['$validator', '$class', '$modelManager', '$namespace', '$identifier', '$type']; /** * Identifiable is an entity with a namespace, type and an identifier. * * This class is abstract. * @abstract */ class Identifiable { /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { this.$modelManager = modelManager; this.$namespace = ns; this.$identifier = id; this.$type = type; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Get the ModelManager for this instance * @return {ModelManager} The ModelManager for this object * @private */ getModelManager() { return this.$modelManager; } /** * Get the identifier of this instance * @return {string} The identifier for this object */ getIdentifier() { return this.$identifier; } /** * Get the fully qualified identifier of this instance. * (namespace '.' type '#' identifier). * @return {string} the fully qualified identifier of this instance */ getFullyQualifiedIdentifier() { return this.getFullyQualifiedType() + '#' + this.$identifier; } /** * Get the type of the instance (a short name, not including namespace). * @return {string} The type of this object */ getType() { return this.$type; } /** * Get the fully-qualified type name of the instance (including namespace). * @return {string} The fully-qualified type name of this object */ getFullyQualifiedType() { return this.$namespace + '.' + this.$type; } /** * Get the namespace of the instance. * @return {string} The namespace of this object */ getNamespace() { return this.$namespace; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Identifiable {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Returns true if the property is a system * property. * @param {string} name - the name of the property * @return {boolean} true if the property is a system property * @private */ static isSystemProperty(name) { return IDENTIFIABLE_SYSTEM_PROPERTIES.indexOf(name) &gt;= 0; } } module.exports = Identifiable; Ã— Search results Close "},"lib_parser_illegalmodelexception.js.html":{"id":"lib_parser_illegalmodelexception.js.html","title":"Source: lib/parser/illegalmodelexception.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/illegalmodelexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception throws when a Concerto file is semantically invalid */ class IllegalModelException extends BaseException { /** * Create an IllegalModelException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = IllegalModelException; Ã— Search results Close "},"lib_serializer_jsongenerator.js.html":{"id":"lib_serializer_jsongenerator.js.html","title":"Source: lib/serializer/jsongenerator.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer/jsongenerator.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('../parser/classdeclaration'); const Field = require('../parser/field'); const RelationshipDeclaration = require('../parser/relationshipdeclaration'); const EnumValueDeclaration = require('../parser/enumvaluedeclaration'); const EnumDeclaration = require('../parser/enumdeclaration'); const Resource = require('../model/resource'); const Relationship = require('../model/relationship'); const ModelUtil = require('../modelutil'); const Util = require('../util'); /** * Converts the contents of a Resource to JSON. The parameters * object should contain the keys * 'writer' - the JSONWriter instance to use to accumulate the JSON text. * 'stack' - the TypedStack of objects being processed. It should * start with a Resource. * 'modelManager' - the ModelManager to use. * @private */ class JSONGenerator { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof EnumValueDeclaration) { return this.visitEnumValueDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.writer.openObject(); parameters.writer.writeKeyStringValue('$class', classDeclaration.getFullyQualifiedName()); const obj = parameters.stack.pop(Resource); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } } parameters.writer.closeObject(); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(field.getName()); if(field.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; if(!field.isPrimitive() &amp;&amp; !ModelUtil.isEnum(field)) { parameters.writer.writeComma(); parameters.stack.push(item, Resource); const classDecl = parameters.modelManager.getType(item.getFullyQualifiedType()); classDecl.accept(this, parameters); } else { parameters.writer.writeArrayValue(this.convertToJSON(field,item)); } } parameters.writer.closeArray(); } else if(field.isPrimitive() || ModelUtil.isEnum(field)) { parameters.writer.writeValue(this.convertToJSON(field,obj)); } else { parameters.stack.push(obj); const classDeclaration = parameters.modelManager.getType(field.getFullyQualifiedTypeName()); classDeclaration.accept(this, parameters); } return null; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} obj - the object to convert to text * @return {string} the text representation */ convertToJSON(field, obj) { if(field instanceof ClassDeclaration) { throw new Error( 'Cannot convert ' + field.getFullyQualifiedTypeName() + ' directly to JSON for object ' + obj ); } switch(field.getType()) { case 'DateTime': { return `&quot;${obj.toISOString()}&quot;`; } case 'Integer': case 'Long': case 'Double': case 'Boolean':{ return `${obj.toString()}`; } default: { return `&quot;${obj.toString()}&quot;`; } } } /** * Visitor design pattern * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeStringValue(obj.toString()); return null; } /** * Visitor design pattern * @param {EnumDeclaration} enumValueDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumValueDeclaration(enumValueDeclaration, parameters) { return null; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(relationshipDeclaration.getName()); if(relationshipDeclaration.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; let relationshipText = this.getRelationshipText(relationshipDeclaration, item ); parameters.writer.writeArrayStringValue(relationshipText); } parameters.writer.closeArray(); } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj ); parameters.writer.writeStringValue(relationshipText); } return null; } /** * * Returns the persistent format for a relationship. * @param {RelationshipDeclaration} relationshipDeclaration - the relationship being persisted * @param {Relationship} relationship - the text for the item * @returns {string} the text to use to persist the relationship */ getRelationshipText(relationshipDeclaration, relationship) { if(!(relationship instanceof Relationship)) { throw new Error('Did not find a relationship for ' + relationshipDeclaration.getFullyQualifiedTypeName() + ' found ' + relationship ); } let relationshipText = relationship.getIdentifier(); if(relationshipDeclaration.getNamespace() !== relationship.getNamespace() ) { relationshipText = relationship.getFullyQualifiedIdentifier(); } return relationshipText; } } module.exports = JSONGenerator; Ã— Search results Close "},"lib_serializer_jsonpopulator.js.html":{"id":"lib_serializer_jsonpopulator.js.html","title":"Source: lib/serializer/jsonpopulator.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer/jsonpopulator.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('../parser/classdeclaration'); const Field = require('../parser/field'); const RelationshipDeclaration = require('../parser/relationshipdeclaration'); const Util = require('../util'); const ModelUtil = require('../modelutil'); /** * Populates a Resource with data from a JSON object graph. The JSON objects * should be the result of calling Serializer.toJSON and then JSON.parse. * The parameters object should contain the keys * 'stack' - the TypedStack of objects being processed. It should * start with the root object from JSON.parse. * 'factory' - the Factory instance to use for creating objects. * 'modelManager' - the ModelManager instance to use to resolve classes * @private */ class JSONPopulator { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); const resourceObj = parameters.resourceStack.pop(); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = jsonObj[property.getName()]; if(!Util.isNull(value)) { parameters.jsonStack.push(value); resourceObj[property.getName()] = property.accept(this,parameters); } } return resourceObj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; if(field.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { const jsonItem = jsonObj[n]; result.push(this.convertItem(field,jsonItem, parameters)); } } else { result = this.convertItem(field,jsonObj, parameters); } return result; } /** * * @param {Field} field - the field of the item being converted * @param {Object} jsonItem - the JSON object of the item being converted * @param {Object} parameters - the parameters * @return {Object} - the populated object. */ convertItem(field, jsonItem, parameters) { let result = null; if(!field.isPrimitive() &amp;&amp; !field.isTypeEnum()) { if(!jsonItem.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonItem + ' for field ' + field ); } const classDeclaration = parameters.modelManager.getType(jsonItem.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonItem.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); result = subResource; parameters.resourceStack.push(subResource); parameters.jsonStack.push(jsonItem); classDeclaration.accept(this, parameters); } else { result = this.convertToObject(field,jsonItem); } return result; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} json - the JSON object to convert to a Concerto Object * @return {string} the text representation */ convertToObject(field, json) { let result = null; switch(field.getType()) { case 'DateTime': result = new Date(json); break; case 'Integer': case 'Long': result = parseInt(json); break; case 'Double': result = parseFloat(json); break; case 'Boolean': result = (json === true || json === 'true'); break; case 'String': result = json.toString(); break; default: // everything else should be an enumerated value... result = json; } return result; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; let typeFQN = relationshipDeclaration.getFullyQualifiedTypeName(); let namespace = ModelUtil.getNamespace(typeFQN); if(!namespace) { namespace = relationshipDeclaration.getNamespace(); } let type = ModelUtil.getShortName(typeFQN); if(relationshipDeclaration.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { let jsonItem = jsonObj[n]; if (typeof jsonItem === 'string') { result.push(parameters.factory.newRelationship(namespace, type, jsonItem)); } else { // this isn't a relationship, but it might be an object! if(!jsonItem.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonItem + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonItem.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonItem.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonItem); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result.push(subResource); } } } else { if (typeof jsonObj === 'string') { result = parameters.factory.newRelationship(namespace, type, jsonObj); } else { // this isn't a relationship, but it might be an object! if(!jsonObj.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonObj + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonObj.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonObj.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObj[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonObj); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result = subResource; } } return result; } } module.exports = JSONPopulator; Ã— Search results Close "},"lib_codegen_jsonwriter.js.html":{"id":"lib_codegen_jsonwriter.js.html","title":"Source: lib/codegen/jsonwriter.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/jsonwriter.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Writer = require('./writer'); /** * JSONWriter manages a text buffer for writing JSON data structures. * It tracks when a comma is needed to separate items. Commas are inserted * automatically based on context. * @private */ class JSONWriter extends Writer { /** * Create a JSONWriter. * */ constructor() { super(); this.indent = 0; this.firstItem = true; } /** * Opens an object declaration * @param {string} key - the key */ openObject() { this.write('{'); this.indent++; this.firstItem = true; this.log('{'); } /** * Close the current object declaration. */ closeObject() { this.write('}'); this.indent--; this.firstItem = false; this.log('}'); } /** * Writes a key, in the format * '&quot;key&quot; : ' * @param {string} key - the key */ writeKey(key) { this.writeComma(); this.write(`&quot;${key}&quot;:`); this.log('writeKey', key ); } /** * Writes a comma when this.firstItem === false */ writeComma() { if(this.firstItem === false) { this.write(','); this.log(','); } else { this.log(', (suppressed)'); } } /** * Writes a value, in the format: * '&quot;value&quot;' * @param {string} value - the value */ writeStringValue(value) { this.write(`&quot;${value}&quot;`); this.firstItem = false; this.log('writeStringValue', value); } /** * Writes a value, in the format: * 'value' * @param {string} value - the value */ writeValue(value) { this.write(`${value}`); this.firstItem = false; this.log('writeValue', value); } /** * Writes a key/value, in the format: * '&quot;key&quot; : &quot;value&quot;' * @param {string} key - the key * @param {string} value - the value */ writeKeyStringValue(key,value) { this.writeComma(); this.write(`&quot;${key}&quot;:&quot;${value}&quot;`); this.firstItem = false; this.log('writeKeyStringValue', (key + ':' + value)); } /** * Writes a key/value, in the format: * '&quot;key&quot; : value' * @param {string} key - the key * @param {string} value - the value */ writeKeyValue(key,value) { this.writeComma(); this.write(`&quot;${key}&quot;: ${value}`); this.firstItem = false; this.log('writeKeyValue', key + '=' + value); } /** * Writes an array value, in the format * '&quot;value&quot;' * @param {string} value - the value */ writeArrayStringValue(value) { this.writeComma(); this.write(`&quot;${value}&quot;`); this.firstItem = false; this.log('writeArrayStringValue', value); } /** * Writes an array value, in the format * 'value' * @param {string} value - the value */ writeArrayValue(value) { this.writeComma(); this.write(`${value}`); this.firstItem = false; this.log('writeArrayValue', value); } /** * Opens a new array */ openArray() { this.write('['); this.indent++; this.firstItem = true; this.log('['); } /** * Closes the current array */ closeArray() { this.write(']'); this.indent--; this.firstItem = false; this.log(']'); } /** * @return {String} a string represention of this class */ toString() { return 'indent ' + this.indent + ' firstItem ' + this.firstItem; } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { let spaces = ''; for(let n=0; n &lt; this.indent; n++) { spaces += ' '; } if(!message) { message = ''; } console.log(spaces + ' ' + message + ' ' + callSite ); } } } module.exports = JSONWriter; Ã— Search results Close "},"lib_parser_modelfile.js.html":{"id":"lib_parser_modelfile.js.html","title":"Source: lib/parser/modelfile.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/modelfile.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const parser = require('./parser'); const AssetDeclaration = require('./assetdeclaration'); const EnumDeclaration = require('./enumdeclaration'); const ParticipantDeclaration = require('./participantdeclaration'); const TransactionDeclaration = require('./transactiondeclaration'); const FunctionDeclaration = require('./functiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ParseException = require('./parseexception'); const ModelUtil = require('../modelutil'); const Globalize = require('../globalize'); /** * Class representing a Model File. A Model File contains a single namespace * and a set of model elements: assets, transactions etc. * @private */ class ModelFile { /** * Convert the specified JSON into an instance of a model file. * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} json - A serialized instance of a ModelFile. * @return {ModelFile} An instance of a model file. */ static fromJSON(modelManager, json) { let temp = JSON.parse(json); return new ModelFile(modelManager, temp.definitions); } /** * Create a ModelFile. This should only be called by framework code. * Use the ModelManager to manage ModelFiles. * * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} definitions - The DSL model as a string. * @throws {InvalidModelException} */ constructor(modelManager, definitions) { this.modelManager = modelManager; this.declarations = []; this.imports = []; this.functions = []; if(!definitions || typeof definitions !== 'string') { throw new Error('ModelFile expects a Concerto model as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column ); } else { throw err; } } this.namespace = this.ast.namespace; if(this.ast.imports) { this.imports = this.ast.imports; } for(let n=0; n &lt; this.ast.body.length; n++ ) { let thing = this.ast.body[n]; if(thing.type === 'AssetDeclaration') { this.declarations.push( new AssetDeclaration(this, thing) ); } else if(thing.type === 'TransactionDeclaration') { this.declarations.push( new TransactionDeclaration(this, thing) ); } else if(thing.type === 'ParticipantDeclaration') { this.declarations.push( new ParticipantDeclaration(this, thing) ); } else if(thing.type === 'EnumDeclaration') { this.declarations.push( new EnumDeclaration(this, thing) ); } else if(thing.type === 'FunctionDeclaration') { this.functions.push( new FunctionDeclaration(this,thing)); } else { let formatter = Globalize('en').messageFormatter('modelfile-constructor-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type, })); } } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this ModelFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Returns the types that have been imported into this ModelFile. * * @return {string[]} The array of imports for this ModelFile */ getImports() { return this.imports; } /** * Returns the FunctionDeclaration for all functions that have been defined in this * ModelFile. * * @return {FunctionDeclaration[]} The array of FunctionDeclarations */ getFunctions() { return this.functions; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; classDeclaration.validate(); } for(let n=0; n &lt; this.functions.length; n++) { const functionDeclaration = this.functions[n]; functionDeclaration.validate(); } } /** * Check that the type is valid. * @param {string} context - error reporting context * @param {string} type - a short type name * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { let formatter = Globalize('en').messageFormatter('modelfile-resolvetype-undecltype'); throw new IllegalModelException(formatter({ 'type': type, 'context': context })); } } else { // check whether type is defined in another file this.getModelManager().resolveType(context,this.resolveImport(type)); } } } /** * Returns true if the type is defined in this namespace. * @param {string} type - the short name of the type * @return {boolean} - true if the type is defined in this ModelFile * @private */ isLocalType(type) { let result = (type !== null &amp;&amp; this.getLocalType(type) !== null); //console.log('isLocalType ' + this.getNamespace() + ' ' + type + '=' + result ); return result; } /** * Returns true if the type is imported from another namespace * @param {string} type - the short name of the type * @return {boolean} - true if the type is imported from another namespace * @private */ isImportedType(type) { //console.log('isImportedType ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return true; } } return false; } /** * Returns the FQN for a type that is imported from another namespace * @param {string} type - the short name of the type * @return {string} - the FQN of the resolved import * @throws {Error} - if the type is not imported * @private */ resolveImport(type) { //console.log('resolveImport ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return importName; } } let formatter = Globalize('en').messageFormatter('modelfile-resolveimport-failfindimp'); throw new IllegalModelException(formatter({ 'type': type, 'imports': this.imports, 'namespace': this.getNamespace() })); } /** * Returns true if the type is defined in the model file * @param {string} type the name of the type * @return {boolean} true if the type (asset or transaction) is defined */ isDefined(type) { return ModelUtil.isPrimitiveType(type) || this.getLocalType(type) !== null; } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the type name is returned. * @param {string} type - a FQN or short type name * @return {string | ClassDeclaration} the class declaration for the type or null. * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); if (!modelFile) { return null; } else { return modelFile.getLocalType(fqn); } } } else { // for primitive types we just return the name return type; } } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the short type name is returned. * @param {string} type - a FQN or short type name * @return {string} the FQN type name or null * @private */ getFullyQualifiedTypeName(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type).getFullyQualifiedName(); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); return modelFile.getLocalType(fqn).getFullyQualifiedName(); } } else { // for primitive types we just return the name return type; } } /** * Returns the type with the specified name or null * @param {string} type the short OR FQN name of the type * @return {ClassDeclaration} the ClassDeclaration, or null if the type does not exist */ getLocalType(type) { if(!type.startsWith(this.getNamespace())) { type = this.getNamespace() + '.' + type; } for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(type === this.getNamespace() + '.' + classDeclaration.getName() ) { return classDeclaration; } } return null; } /** * Get the AssetDeclarations defined in this ModelFile or null * @param {string} name the name of the type * @return {AssetDeclaration} the AssetDeclaration with the given short name */ getAssetDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof AssetDeclaration) { return classDeclaration; } return null; } /** * Get the TransactionDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {TransactionDeclaration} the TransactionDeclaration with the given short name */ getTransactionDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof TransactionDeclaration) { return classDeclaration; } return null; } /** * Get the ParticipantDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {ParticipantDeclaration} the ParticipantDeclaration with the given short name */ getParticipantDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof ParticipantDeclaration) { return classDeclaration; } return null; } /** * Get the Namespace for this model file. * @return {string} The Namespace for this model file */ getNamespace() { return this.namespace; } /** * Get the AssetDeclarations defined in this ModelFile * @return {AssetDeclaration[]} the AssetDeclarations defined in the model file */ getAssetDeclarations() { return this.getDeclarations(AssetDeclaration); } /** * Get the TransactionDeclarations defined in this ModelFile * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model file */ getTransactionDeclarations() { return this.getDeclarations(TransactionDeclaration); } /** * Get the ParticipantDeclarations defined in this ModelFile * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model file */ getParticipantDeclarations() { return this.getDeclarations(ParticipantDeclaration); } /** * Get the EnumDeclarations defined in this ModelFile * @return {EnumDeclaration[]} the EnumDeclaration defined in the model file */ getEnumDeclarations() { return this.getDeclarations(EnumDeclaration); } /** * Get the instances of a given type in this ModelFile * @param {Function} type - the type of the declaration * @return {ClassDeclaration[]} the ClassDeclaration defined in the model file */ getDeclarations(type) { let result = []; for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(classDeclaration instanceof type) { result.push(classDeclaration); } } return result; } /** * Get all declarations in this ModelFile * @return {ClassDeclaration[]} the ClassDeclarations defined in the model file */ getAllDeclarations() { return this.declarations; } /** * Get the definitions for this model. * @return {string} The definitions for this model. */ getDefinitions() { return this.definitions; } /** * Convert this model file into an object that is suitable for converting * into a JSON string for serialization purposes. * @return {Object} An object suitable for converting into a JSON string. */ toJSON() { return { namespace: this.namespace, definitions: this.definitions, imports: this.imports, functions: this.functions, assets: this.getAssetDeclarations(), participants: this.getParticipantDeclarations(), transactions: this.getTransactionDeclarations(), enums: this.getEnumDeclarations() }; } } module.exports = ModelFile; Ã— Search results Close "},"lib_modelmanager.js.html":{"id":"lib_modelmanager.js.html","title":"Source: lib/modelmanager.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/modelmanager.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelUtil = require('./modelutil'); const ModelFile = require('./parser/modelfile'); const IllegalModelException = require('./parser/illegalmodelexception'); const Globalize = require('./globalize'); /** * &lt;p&gt; * The structure of {@link Resource}s (Assets, Transactions, Participants) is modelled * in a set of Concerto files. The contents of these files are managed * by the {@link ModelManager}. Each Concerto file has a single namespace and contains * a set of asset, transaction and participant type definitions. * &lt;/p&gt; * &lt;p&gt; * Concerto applications load their Concerto files and then call the {@link ModelManager#addModelFile addModelFile} * method to register the Concerto file(s) with the ModelManager. The ModelManager * parses the text of the Concerto file and will make all defined types available * to other Concerto services, such as the {@link Serializer} (to convert instances to/from JSON) * and {@link Factory} (to create instances). * &lt;/p&gt; * &lt;p&gt;&lt;a href=&quot;diagrams/modelmanager.svg&quot;&gt;&lt;img src=&quot;diagrams/modelmanager.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class ModelManager { /** * Create the ModelManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; */ constructor() { this.modelFiles = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Adds a Concerto file (as a string) to the ModelManager. * Concerto files have a single namespace. If a Concerto file with the * same namespace has already been added to the ModelManager then it * will be replaced. * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Concerto file as a string * @throws {InvalidModelException} * @returns {Object} The newly added model file (internal). */ addModelFile(modelFile) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Updates a Concerto file (as a string) on the ModelManager. * Concerto files have a single namespace. If a Concerto file with the * same namespace has already been added to the ModelManager then it * will be replaced. * @param {string} modelFile - The Concerto file as a string * @throws {InvalidModelException} * @returns {Object} The newly added model file (internal). */ updateModelFile(modelFile) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); if (!this.modelFiles[m.getNamespace()]) { throw new Error('model file does not exist'); } m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { if (!this.modelFiles[modelFile.getNamespace()]) { throw new Error('model file does not exist'); } modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Remove the Concerto file for a given namespace * @param {string} namespace - The namespace of the model file to * delete. */ deleteModelFile(namespace) { if (!this.modelFiles[namespace]) { throw new Error('model file does not exist'); } delete this.modelFiles[namespace]; } /** * Add a set of Concerto files to the model manager. * @param {string[]} modelFiles - An array of Concerto files as * strings. * @returns {Object[]} The newly added model files (internal). */ addModelFiles(modelFiles) { const originalModelFiles = {}; Object.assign(originalModelFiles, this.modelFiles); let newModelFiles = []; try { // create the model files modelFiles.forEach((modelFile) =&gt; { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); this.modelFiles[m.getNamespace()] = m; newModelFiles.push(m); } else { this.modelFiles[modelFile.getNamespace()] = modelFile; newModelFiles.push(modelFile); } }); // re-validate all the model files for (let ns in this.modelFiles) { this.modelFiles[ns].validate(); } // return the model files. return newModelFiles; } catch(err) { this.modelFiles = {}; Object.assign(this.modelFiles, originalModelFiles); throw err; } } /** * Get the array of model file instances * @return {ModelFile[]} The ModelFiles registered * @private */ getModelFiles() { let keys = Object.keys(this.modelFiles); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.modelFiles[keys[n]]); } return result; } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - a short type name * @return {string} - the resolved type name (fully qualified) * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-nonsfortype'); throw new IllegalModelException(formatter({ type: type, context: context })); } if(!modelFile.isLocalType(type)) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-notypeinnsforcontext'); throw new IllegalModelException(formatter({ context: context, type: type, namespace: modelFile.getNamespace() })); } else { return modelFile.getNamespace() + '.' + type; } } else { return type; } } /** * Remove all registered Concerto files */ clearModelFiles() { this.modelFiles = {}; } /** * Get the ModelFile associated with a namespace * @param {string} namespace - the namespace containing the ModelFile * @return {ModelFile} registered ModelFile for the namespace or null * @private */ getModelFile(namespace) { return this.modelFiles[namespace]; } /** * Get the namespaces registered with the ModelManager. * @return {string[]} namespaces - the namespaces that have been registered. */ getNamespaces() { return Object.keys(this.modelFiles); } /** * Look up a type in all registered namespaces. * * @param {string} type - the fully qualified name of a type * @return {ClassDeclaration} - the class declaration or null for primitive types * @throws {Error} - if the type cannot be found * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new Error(formatter({ type: type })); } let classDecl = modelFile.getType(type); if(!classDecl) { throw new Error( 'No type ' + type + ' in namespace ' + modelFile.getNamespace() ); } return classDecl; } else { return null; } } } module.exports = ModelManager; Ã— Search results Close "},"lib_modelregistry.js.html":{"id":"lib_modelregistry.js.html","title":"Source: lib/modelregistry.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/modelregistry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelFile = require('./parser/modelfile'); const Registry = require('./registry'); const Util = require('./util'); const REGISTRY_TYPE = 'Model'; /** * The ModelRegistry is used to manage a set of models. * &lt;p&gt;&lt;a href=&quot;diagrams/modelregistry.svg&quot;&gt;&lt;img src=&quot;diagrams/modelregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @private */ class ModelRegistry extends Registry { /** * Get a list of all existing model registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link ModelRegistry} * instances representing the asset registries. */ static getAllModelRegistries(securityContext, modelManager) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then(function (modelRegistries) { return modelRegistries.map(function (modelRegistry) { return new ModelRegistry(modelRegistry.id, modelRegistry.name, modelManager); }); }); } /** * Get an existing model registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. * @return {Promise} A promise that will be resolved with a {@link ModelRegistry} * instance representing the model registry. */ static getModelRegistry(securityContext, id, modelManager) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then(function (modelRegistry) { return new ModelRegistry(modelRegistry.id, modelRegistry.name, modelManager); }); } /** * Add a new model registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model registry. * @param {string} name The name of the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. * @return {Promise} A promise that will be resolved with a {@link ModelRegistry} * instance representing the new model registry. */ static addModelRegistry(securityContext, id, name, modelManager) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(function () { return new ModelRegistry(id, name, modelManager); }); } /** * Create an model registry. * * @protected * @param {string} id The unique identifier of the model registry. * @param {string} name The display name for the model registry. * @param {ModelManager} modelManager The ModelManager to use for this model registry. */ constructor(id, name, modelManager) { super(REGISTRY_TYPE, id, name); if (!modelManager) { throw new Error('modelManager not specified'); } this.modelManager = modelManager; } /** * Adds a model to the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelFile} model The model to be added to the model registry. * @return {Promise} A promise that is resolved when the model is added to * the model registry. */ add(securityContext, model) { Util.securityCheck(securityContext); return super.add(securityContext, model.getNamespace(), JSON.stringify(model), 'addModelToRegistry'); } /** * Updates an model in the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelFile} model The model to be updated in the model registry. * @return {Promise} A promise that is resolved when the model is updated * in the model registry. */ update(securityContext, model) { Util.securityCheck(securityContext); return super.update(securityContext, model.getNamespace(), JSON.stringify(model), 'updateModelInRegistry'); } /** * Remove an model with a given type and id from the model registry. * * @param {SecurityContext} securityContext The user's security context. * @param {(ModelFile|string)} model The model, or the unique identifier of the model. * @return {Promise} A promise that is resolved when the element is removed * from the registry. */ remove(securityContext, model) { Util.securityCheck(securityContext); let id; if (model instanceof ModelFile) { id = model.getNamespace(); } else { id = model; } return super.remove(securityContext, id, 'removeModelFromRegistry'); } /** * Get all of the models in the registry. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of {@link * ModelFile} instances representing the models. */ getAll(securityContext) { Util.securityCheck(securityContext); let self = this; return super.getAll(securityContext) .then(function (resources) { return resources.map(function (resource) { return ModelFile.fromJSON(self.modelManager, resource.data); }); }); } /** * Get a specific model in the registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the model. * @return {Promise} A promise that will be resolved with a {@link ModelFile} * instance representing the model. */ get(securityContext, id) { Util.securityCheck(securityContext); let self = this; return super.get(securityContext, id) .then(function (resource) { return ModelFile.fromJSON(self.modelManager, resource.data); }); } } module.exports = ModelRegistry; Ã— Search results Close "},"lib_modelutil.js.html":{"id":"lib_modelutil.js.html","title":"Source: lib/modelutil.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/modelutil.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Globalize = require('./globalize'); /** * Internal Model Utility Class * &lt;p&gt;&lt;a href=&quot;diagrams/modelutil.svg&quot;&gt;&lt;img src=&quot;diagrams/modelutil.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private */ class ModelUtil { /** * Returns everything after the last dot, if present, of the source string * @param {string} fqn - the source string * @return {string} - the string after the last dot * @private */ static getShortName(fqn) { //console.log('toShortName ' + name ); let result = fqn; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(dotIndex + 1); } //console.log('result ' + result ); return result; } /** * Returns the namespace for a the fully qualified name of a type * @param {string} fqn - the fully qualified identifier of a type * @return {string} - namespace of the type (everything before the last dot) * or the empty string if there is no dot * @private */ static getNamespace(fqn) { if (!fqn) { throw new Error(Globalize.formatMessage('modelutil-getnamespace-nofnq')); } let result = ''; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(0, dotIndex); } return result; } /** * Returns true if the type is a primitive type * @param {string} type - the name of the type * @return {boolean} - true if the type is a primitive * @private */ static isPrimitiveType(type) { const primitiveTypes = ['Boolean', 'String', 'DateTime', 'Double', 'Integer', 'Long']; return (primitiveTypes.indexOf(type) &gt;= 0); } /** * Returns true if the type is assignable to the propertyType. * * @param {ModelFile} modelFile - the ModelFile that owns the Property * @param {string} type - the FQN of the type we are trying to assign * @param {Property} property - the property that we'd like to store the * type in. * @return {boolean} - true if the type can be assigned to the property * @private */ static isAssignableTo(modelFile, type, property) { if(ModelUtil.isPrimitiveType(type)) { throw new Error('This method only works with complex types.'); } if(ModelUtil.isPrimitiveType(property.getName())) { return false; } // console.log( 'type ' + type ); // console.log( 'property ' + property.getFullyQualifiedName() ); // simple case if(type === property.getFullyQualifiedTypeName()) { return true; } // type = SuperType // property = BaseType // return = true const typeDeclaration = modelFile.getType(type); if(!typeDeclaration) { throw new Error('Cannot find type ' + type ); } let superTypeName = typeDeclaration.getSuperType(); let superType = modelFile.getType(superTypeName); while(superType) { if(superType.getFullyQualifiedName() === property.getFullyQualifiedTypeName()) { return true; } // console.log('superType ' + superType.getFullyQualifiedName() ); superTypeName = superType.getSuperType(); if(superTypeName) { superType = modelFile.getType(superTypeName); } else { superType = null; } } return false; } /** * Returns the passed string with the first character capitalized * @param {string} string - the string * @return {string} the string with the first letter capitalized * @private */ static capitalizeFirstLetter(string) { return string.charAt(0).toUpperCase() + string.slice(1); } /** * Returns the passed string with the first character capitalized * @param {Field} field - the string * @return {boolean} the string with the first letter capitalized * @private */ static isEnum(field) { const modelFile = field.getParent().getModelFile(); const typeDeclaration = modelFile.getType(field.getType()); return (typeDeclaration !== null &amp;&amp; typeDeclaration.isEnum()); } } module.exports = ModelUtil; Ã— Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: index.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * IBM Concerto module. IBM Concerto is a framework for creating * blockchain backed digital networks and exchanging assets between participants * via processing transactions. * &lt;p&gt; * Applications interact with the framework by instantiating the {@link Concerto} * class. * &lt;/p&gt; * &lt;p&gt;&lt;a href=&quot;diagrams/concerto.svg&quot;&gt;&lt;img src=&quot;diagrams/concerto.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @module ibm-concerto */ module.exports.Concerto = require('./lib/concerto'); Ã— Search results Close "},"lib_parser_parseexception.js.html":{"id":"lib_parser_parseexception.js.html","title":"Source: lib/parser/parseexception.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/parseexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception throws when a Concerto file is syntactically invalid */ class ParseException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ParseException; Ã— Search results Close "},"lib_parser_participantdeclaration.js.html":{"id":"lib_parser_participantdeclaration.js.html","title":"Source: lib/parser/participantdeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/participantdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** Class representing the definition of a Participant. * @extends ClassDeclaration * @private */ class ParticipantDeclaration extends ClassDeclaration { /** * Create an ParticipantDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } } module.exports = ParticipantDeclaration; Ã— Search results Close "},"lib_codegen_plantuml_plantumlvisitor.js.html":{"id":"lib_codegen_plantuml_plantumlvisitor.js.html","title":"Source: lib/codegen/plantuml/plantumlvisitor.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/plantuml/plantumlvisitor.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelManager = require('../../modelmanager'); const ModelFile = require('../../parser/modelfile'); const ClassDeclaration = require('../../parser/classdeclaration'); const TransactionDeclaration = require('../../parser/transactiondeclaration'); const AssetDeclaration = require('../../parser/assetdeclaration'); const ParticipantDeclaration = require('../../parser/participantdeclaration'); const EnumDeclaration = require('../../parser/enumdeclaration'); const Field = require('../../parser/field'); const RelationshipDeclaration = require('../../parser/relationshipdeclaration'); const EnumValueDeclaration = require('../../parser/enumvaluedeclaration'); const FunctionDeclaration = require('../../parser/functiondeclaration'); const _ = require('underscore'); /** * Convert the contents of a ModelManager to PlantUML format files. * Set a fileWriter property (instance of FileWriter) on the parameters * object to control where the generated code is written to disk. * * @private */ class PlantUMLVisitor { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ModelManager) { return this.visitModelManager(thing, parameters); } else if (thing instanceof ModelFile) { return this.visitModelFile(thing, parameters); } else if (thing instanceof ParticipantDeclaration) { return this.visitParticipantDeclaration(thing, parameters); } else if (thing instanceof TransactionDeclaration) { return this.visitTransactionDeclaration(thing, parameters); } else if (thing instanceof AssetDeclaration) { return this.visitAssetDeclaration(thing, parameters); } else if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationship(thing, parameters); } else if (thing instanceof EnumValueDeclaration) { return this.visitEnumValueDeclaration(thing, parameters); } else if (thing instanceof FunctionDeclaration) { return this.visitFunctionDeclaration(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ModelManager} modelManager - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelManager(modelManager, parameters) { parameters.fileWriter.openFile('model.uml'); parameters.fileWriter.writeLine(0, '@startuml'); let visitModelFile = function(modelFile) { modelFile.accept(this,parameters); }; _.each(modelManager.getModelFiles(), visitModelFile.bind(this)); parameters.fileWriter.writeLine(0, '@enduml'); parameters.fileWriter.closeFile(); return null; } /** * Visitor design pattern * @param {ModelFile} modelFile - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelFile(modelFile, parameters) { let visitClass = function(classDeclaration) { classDeclaration.accept(this,parameters); }; _.each(modelFile.getAllDeclarations(), visitClass.bind(this)); const txProcessor = modelFile.getNamespace() + '.TransactionProcessor'; parameters.fileWriter.writeLine(0, 'class ' + txProcessor + ' &lt;&lt; (X,brown) &gt;&gt; {' ); visitClass = function(functionDeclaration) { functionDeclaration.accept(this,parameters); }; _.each(modelFile.getFunctions(), visitClass.bind(this)); parameters.fileWriter.writeLine(0, '}' ); const functions = modelFile.getFunctions(); for(let n=0; n &lt; functions.length; n++ ) { const functionDeclaration = functions[n]; const txName = modelFile.getNamespace() + '.' + functionDeclaration.getTransactionDeclarationName(); if(txName) { parameters.fileWriter.writeLine(0, txProcessor + ' .. ' + txName ); } } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitAssetDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'class ' + classDeclaration.getFullyQualifiedName() + ' &lt;&lt; (A,green) &gt;&gt; {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(0, classDeclaration.getFullyQualifiedName() + ' --|&gt; ' + classDeclaration.getSuperType()); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'class ' + classDeclaration.getFullyQualifiedName() + ' &lt;&lt; (E,grey) &gt;&gt; {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(0, classDeclaration.getFullyQualifiedName() + ' --|&gt; ' + classDeclaration.getSuperType()); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitParticipantDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'class ' + classDeclaration.getFullyQualifiedName() + ' &lt;&lt; (P,lightblue) &gt;&gt; {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(0, classDeclaration.getFullyQualifiedName() + ' --|&gt; ' + classDeclaration.getSuperType()); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitTransactionDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'class ' + classDeclaration.getFullyQualifiedName() + ' &lt;&lt; (T,yellow) &gt;&gt; {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(0, classDeclaration.getFullyQualifiedName() + ' --|&gt; ' + classDeclaration.getSuperType()); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.fileWriter.writeLine(0, 'class ' + classDeclaration.getFullyQualifiedName() + ' {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(0, '}' ); if(classDeclaration.getSuperType()) { parameters.fileWriter.writeLine(0, classDeclaration.getFullyQualifiedName() + ' --|&gt; ' + classDeclaration.getSuperType()); } return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { let array = ''; if(field.isArray()) { array = '[]'; } parameters.fileWriter.writeLine(1, '+ ' + field.getType() + array + ' ' + field.getName()); return null; } /** * Visitor design pattern * @param {FunctionDeclaration} functionDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitFunctionDeclaration(functionDeclaration, parameters) { parameters.fileWriter.writeLine(1, '+ ' + functionDeclaration.getName() + '(' + functionDeclaration.getParameters() + ')'); return null; } /** * Visitor design pattern * @param {EnumValueDeclaration} enumValueDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumValueDeclaration(enumValueDeclaration, parameters) { parameters.fileWriter.writeLine(1, '+ ' + enumValueDeclaration.getName()); return null; } /** * Visitor design pattern * @param {Relationship} relationship - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationship(relationship, parameters) { let array = ''; if(relationship.isArray()) { array = '[]'; } // we export all relationships by capitalizing them parameters.fileWriter.writeLine(1, '+ ' + relationship.getType() + array + ' ' + relationship.getName()); return null; } } module.exports = PlantUMLVisitor; Ã— Search results Close "},"lib_registry.js.html":{"id":"lib_registry.js.html","title":"Source: lib/registry.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/registry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Util = require('./util'); /** * Class representing an Abstract Registry. * &lt;p&gt;&lt;a href=&quot;diagrams/registry.svg&quot;&gt;&lt;img src=&quot;diagrams/registry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract */ class Registry { /** * Get a list of all existing registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the registries. */ static getAllRegistries(securityContext, registryType) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } return Util.queryChainCode(securityContext, 'getAllRegistries', [registryType]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Get an existing registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static getRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getRegistry', [registryType, id]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static addRegistry(securityContext, registryType, id, name) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } return Util.invokeChainCode(securityContext, 'addRegistry', [registryType, id, name]) .then(function () { return { id: id, name: name }; }); } /** * Create a registry. * * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The display name for the registry. */ constructor(registryType, id, name) { if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } this.registryType = registryType; this.id = id; this.name = name; } /** * Adds a new resource to the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. * @param {string} [functionName] The optional chain-code function name to call. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ add(securityContext, id, data, functionName) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!data) { throw new Error('data not specified'); } return Util.invokeChainCode(securityContext, functionName ? functionName : 'addResourceToRegistry', [this.registryType, this.id, id, data]); } /** * Updates a resource in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. * @param {string} [functionName] The optional chain-code function name to call. * @return {Promise} A promise that will be resolved when the resource is * updated in the registry. */ update(securityContext, id, data, functionName) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!data) { throw new Error('data not specified'); } return Util.invokeChainCode(securityContext, functionName ? functionName : 'updateResourceInRegistry', [this.registryType, this.id, id, data]); } /** * Remove an asset with a given type and id from the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} [functionName] The optional chain-code function name to call. * @return {Promise} A promise that will be resolved when the resource is * removed from the registry. */ remove(securityContext, id, functionName) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } return Util.invokeChainCode(securityContext, functionName ? functionName : 'removeResourceFromRegistry', [this.registryType, this.id, id]); } /** * Get all of the resources in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {Object} [options] An optional set of options for the query. * @param {boolean} [options.resolve] Resolve all of the assets relationships. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the resources. */ getAll(securityContext, options) { Util.securityCheck(securityContext); let resolve = false; if (options) { resolve = options.resolve === true; } return Util.queryChainCode(securityContext, 'getAllResourcesInRegistry', [this.registryType, this.id, resolve.toString()]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } /** * Get a specific resource in the registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {Object} [options] An optional set of options for the query. * @param {boolean} [options.resolve] Resolve all of the assets relationships. * @return {Promise} A promise that will be resolved with a JSON object * representing the resource. */ get(securityContext, id, options) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } let resolve = false; if (options) { resolve = options.resolve === true; } return Util.queryChainCode(securityContext, 'getResourceInRegistry', [this.registryType, this.id, id, resolve.toString()]) .then(function (buffer) { return JSON.parse(buffer.toString()); }); } } module.exports = Registry; Ã— Search results Close "},"lib_model_relationship.js.html":{"id":"lib_model_relationship.js.html","title":"Source: lib/model/relationship.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/model/relationship.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Identifiable = require('./identifiable'); /** * A Relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * @extends Identifiable */ class Relationship extends Identifiable { /** * Create an asset. Use the Factory to create instances. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); // we use this metatag to identify the instance as a relationship this.$class = 'Relationship'; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Relationship {id=' + this.getFullyQualifiedIdentifier() +'}'; } } module.exports = Relationship; Ã— Search results Close "},"lib_parser_relationshipdeclaration.js.html":{"id":"lib_parser_relationshipdeclaration.js.html","title":"Source: lib/parser/relationshipdeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/relationshipdeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Property = require('./property'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * Class representing a relationship between model elements * @extends Property * @private */ class RelationshipDeclaration extends Property { /** * Create a Relationship. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { super.validate(classDecl); // relationship cannot point to primitive types if(!this.getType()) { throw new IllegalModelException('Relationship must have a type'); } if(ModelUtil.isPrimitiveType(this.getType())) { throw new IllegalModelException('Relationship cannot be to a primitive type'); } } /** * Returns a string representation of this propertyÂ§ * @return {String} the string version of the property. */ toString() { return 'RelationshipDeclaration {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; }} module.exports = RelationshipDeclaration; Ã— Search results Close "},"lib_model_resource.js.html":{"id":"lib_model_resource.js.html","title":"Source: lib/model/resource.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/model/resource.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Identifiable = require('./identifiable'); const Field = require('../parser/field'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Concerto is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Concerto to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable */ class Resource extends Identifiable { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } /** * Sets a property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ setPropertyValue(propName, value) { this[propName] = value; } /** * Adds a value to an array property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ addArrayValue(propName, value) { if(this[propName]) { this[propName].push(value); } else { this[propName] = [value]; } } /** * Sets the fields to their default values, based on the model * @private */ assignFieldDefaults() { let classDeclaration = this.getClassDeclaration(); let fields = classDeclaration.getProperties(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field) { let defaultValue = field.getDefaultValue(); if (defaultValue) { if (field.getType() === 'String') { this.setPropertyValue(field.getName(), defaultValue); } else if (field.getType() === 'Integer') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Long') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Double') { this.setPropertyValue(field.getName(), parseFloat(defaultValue)); } else if (field.getType() === 'Boolean') { this.setPropertyValue(field.getName(), (defaultValue === 'true')); } else if (field.getType() === 'DateTime') { const dateTime = new Date(); dateTime.setTime(Date.parse(defaultValue)); this.setPropertyValue(field.getName(), dateTime); } } } } } /** * Returns the class declaration for this instance object. * * @return {ClassDeclaration} - the class declaration for this Resource * @throws {Error} - if the class or namespace for the instance is not declared * @private */ getClassDeclaration() { // do we have a model file? let modelFile = this.getModelManager().getModelFile(this.getNamespace()); if (!modelFile) { throw new Error('No model for namespace ' + this.getNamespace() + ' is registered with the ModelManager'); } // do we have a class? let classDeclaration = modelFile.getType(this.getType()); if (!classDeclaration) { throw new Error('The namespace ' + this.getNamespace() + ' does not contain the type ' + this.getType()); } return classDeclaration; } /** * Overriden to prevent people accidentally converting a resource to JSON * without using the Serializer. * @private */ toJSON() { throw new Error('Use Serializer.toJSON to convert resource instances to JSON objects.'); } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Resource {id=' + this.getFullyQualifiedIdentifier() +'}'; } } module.exports = Resource; Ã— Search results Close "},"lib_serializer_resourcevalidator.js.html":{"id":"lib_serializer_resourcevalidator.js.html","title":"Source: lib/serializer/resourcevalidator.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer/resourcevalidator.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('../parser/classdeclaration'); const Field = require('../parser/field'); const RelationshipDeclaration = require('../parser/relationshipdeclaration'); const EnumDeclaration = require('../parser/enumdeclaration'); const Relationship = require('../model/relationship'); const Resource = require('../model/resource'); const Identifiable = require('../model/identifiable'); const Util = require('../util'); const ModelUtil = require('../modelutil'); const ValidationException = require('./validationexception'); const Globalize = require('../globalize'); /** * &lt;p&gt; * Validates a Resource or Field against the models defined in the ModelManager. * This class is used with the Visitor pattern and visits the class declarations * (etc) for the model, checking that the data in a Resource / Field is consistent * with the model. * &lt;/p&gt; * The parameters for the visit method must contain the following properties: * &lt;ul&gt; * &lt;li&gt; 'stack' - the TypedStack of objects being processed. It should * start as [Resource] or [Field]&lt;/li&gt; * &lt;li&gt; 'rootResourceIdentifier' - the identifier of the resource being validated &lt;/li&gt; * &lt;li&gt; 'modelManager' - the ModelManager instance to use for type checking&lt;/li&gt; * &lt;/ul&gt; * @private */ class ResourceValidator { /** * Visitor design pattern. * * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { const obj = parameters.stack.peek(); this.log('visit', thing.toString() + ' with value (' + obj + ')'); if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } } /** * Visitor design pattern * * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { const obj = parameters.stack.pop(); // now check that obj is one of the enum values const properties = enumDeclaration.getProperties(); let found = false; for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; if(property.getName() === obj) { found = true; } } if(!found) { ResourceValidator.reportInvalidEnumValue( parameters.rootResourceIdentifier, enumDeclaration, obj ); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); // are we dealing with a Resouce? if(!(obj instanceof Resource)) { ResourceValidator.reportNotResouceViolation(parameters.rootResourceIdentifier, classDeclaration, obj ); } parameters.rootResourceIdentifier = obj.getFullyQualifiedIdentifier(); const toBeAssignedClassDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); // is the type we are assigning to abstract? // the only way this can happen is if the type is non-abstract // and then gets redeclared as abstract if(toBeAssignedClassDeclaration.isAbstract()) { ResourceValidator.reportAbstractClass(toBeAssignedClassDeclaration); } // are there extra fields in the object? let props = Object.getOwnPropertyNames(obj); for (let n = 0; n &lt; props.length; n++) { let propName = props[n]; if(!Identifiable.isSystemProperty(propName)) { const field = toBeAssignedClassDeclaration.getProperty(propName); if (!field) { ResourceValidator.reportUndeclaredField(obj.getIdentifier(), propName, toBeAssignedClassDeclaration.getFullyQualifiedName()); } } } // now validate each property const properties = toBeAssignedClassDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } else { if(!property.isOptional()) { ResourceValidator.reportMissingRequiredProperty( parameters.rootResourceIdentifier, property); } } } return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); let dataType = typeof(obj); let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isTypeEnum()) { this.checkEnum(obj, field,parameters); } else { if(field.isArray()) { this.checkArray(obj, field,parameters); } else { this.checkItem(obj, field,parameters); } } return null; } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkEnum(obj,field,parameters) { if(field.isArray() &amp;&amp; !(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } const enumDeclaration = field.getParent().getModelFile().getType(field.getType()); if(field.isArray()) { for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } else { const item = obj; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkArray(obj,field,parameters) { if(!(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkItem(item, field, parameters); } } /** * Check a single (non-array) field. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkItem(obj,field, parameters) { let dataType = typeof obj; let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isPrimitive()) { let invalid = false; switch(field.getType()) { case 'String': if(dataType !== 'string') { invalid = true; } break; case 'Double': case 'Long': case 'Integer': if(dataType !== 'number') { invalid = true; } break; case 'Boolean': if(dataType !== 'boolean') { invalid = true; } break; case 'DateTime': if(!(obj instanceof Date)) { invalid = true; } break; } if (invalid) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } } else { // a field that points to a transaction, asset, participant... let classDeclaration = parameters.modelManager.getType(field.getFullyQualifiedTypeName()); if(obj instanceof Identifiable) { classDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); if(!classDeclaration) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } // is it compatible? if(!ModelUtil.isAssignableTo(classDeclaration.getModelFile(), classDeclaration.getFullyQualifiedName(), field)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, propName, obj, field); } } // recurse parameters.stack.push(obj); classDeclaration.accept(this, parameters); } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); if(relationshipDeclaration.isArray()) { if(!(obj instanceof Array)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkRelationship(parameters, relationshipDeclaration, item); } } else { this.checkRelationship(parameters, relationshipDeclaration, obj); } return null; } /** * Check a single relationship * @param {Object} parameters - the parameter * @param {relationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} obj - the object being validated * @private */ checkRelationship(parameters, relationshipDeclaration, obj) { if(!(obj instanceof Relationship)) { ResourceValidator.reportNotRelationshipViolation(parameters.rootResourceIdentifier, relationshipDeclaration, obj); } const relationshipType = parameters.modelManager.getType(obj.getFullyQualifiedType()); if(!ModelUtil.isAssignableTo(relationshipType.getModelFile(), obj.getFullyQualifiedType(), relationshipDeclaration)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { if(!message) { message = ''; } console.log('[' + callSite + '] ' + message ); } } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {string} propName - the name of the field. * @param {*} value - the value of the field. * @param {Field} field - the field * @throws {ValidationException} the exception * @private */ static reportFieldTypeViolation(id, propName, value, field) { let isArray = field.isArray() ? '[]' : ''; let typeOfValue = typeof value; if(value instanceof Identifiable) { typeOfValue = value.getFullyQualifiedType(); value = value.getFullyQualifiedIdentifier(); } else { if(value) { try { value = JSON.stringify(value); } catch(err) { value = value.toString(); } } } let formatter = Globalize.messageFormatter('resourcevalidator-fieldtypeviolation'); throw new ValidationException(formatter({ resourceId: id, propertyName: propName, fieldType: field.getType() + isArray, value: value, typeOfValue: typeOfValue })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {classDeclaration} classDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotResouceViolation(id, classDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notresource'); throw new ValidationException(formatter({ resourceId: id, classFQN: classDeclaration.getFullyQualifiedName(), invalidValue: value.toString() })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {RelationshipDeclaration} relationshipDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotRelationshipViolation(id, relationshipDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notrelationship'); throw new ValidationException(formatter({ resourceId: id, classFQN: relationshipDeclaration.getFullyQualifiedTypeName(), invalidValue: value.toString() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field/ * @private */ static reportMissingRequiredProperty(id, field) { let formatter = Globalize.messageFormatter('resourcevalidator-missingrequiredproperty'); throw new ValidationException(formatter({ resourceId: id, fieldName: field.getName() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field * @param {string} obj - the object value * @private */ static reportInvalidEnumValue(id, field, obj) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidenumvalue'); throw new ValidationException(formatter({ resourceId: id, value: obj, fieldName: field.getName() })); } /** * Throw a validation exception for an abstract class * @param {ClassDeclaration} classDeclaration - the class declaration * @throws {ValidationException} the validation exception * @private */ static reportAbstractClass(classDeclaration) { let formatter = Globalize.messageFormatter('resourcevalidator-abstractclass'); throw new ValidationException(formatter({ className: classDeclaration.getFullyQualifiedName(), })); } /** * Throw a validation exception for an abstract class * @param {string} resourceId - the id of the resouce being validated * @param {string} propertyName - the name of the property that is not declared * @param {string} fullyQualifiedTypeName - the fully qualified type being validated * @throws {ValidationException} the validation exception * @private */ static reportUndeclaredField(resourceId, propertyName, fullyQualifiedTypeName ) { let formatter = Globalize.messageFormatter('resourcevalidator-undeclaredfield'); throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propertyName, fullyQualifiedTypeName: fullyQualifiedTypeName })); } /** * Throw a validation exception for an invalid field assignment * @param {string} resourceId - the id of the resouce being validated * @param {string} propName - the name of the property that is being assigned * @param {*} obj - the Field * @param {Field} field - the Field * @throws {ValidationException} the validation exception * @private */ static reportInvalidFieldAssignment(resourceId, propName, obj, field) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidfieldassignment'); throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propName, objectType: obj.getFullyQualifiedType(), fieldType: field.getFullyQualifiedTypeName() })); } } module.exports = ResourceValidator; Ã— Search results Close "},"lib_securitycontext.js.html":{"id":"lib_securitycontext.js.html","title":"Source: lib/securitycontext.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/securitycontext.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * SecurityContext is used to authenticate and manage * user credentials to the underlying blockchain fabric. * &lt;p&gt;&lt;a href=&quot;diagrams/securitycontext.svg&quot;&gt;&lt;img src=&quot;diagrams/securitycontext.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class SecurityContext { /** * Create the SecurityContext. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances by calling {@link Concerto#login login}&lt;/strong&gt; * &lt;/p&gt; * @param {string} user - The user identifier. * @param {string} password - The password. */ constructor(user, password) { this.user = user; this.password = password; this.enrolledMember = null; this.chaincodeID = null; this.eventHub = null; } /** * Get the current username. * @return {string} The username */ getUser() { return this.user; } /** * Get the user password * @return {string} The user password. */ getPassword() { return this.password; } /** * Get the enrolled member. * @return {hfc.Member} The enrolled member. */ getEnrolledMember() { return this.enrolledMember; } /** * Set the enrolled member. * @param {hfc.Member} enrolledMember - The enrolled member. */ setEnrolledMember(enrolledMember) { this.enrolledMember = enrolledMember; } /** * Get the chaincode ID. * @return {string} The chaincode ID. */ getChaincodeID() { return this.chaincodeID; } /** * Set the chaincode ID. * @param {string} chaincodeID - The chaincode ID. */ setChaincodeID(chaincodeID) { this.chaincodeID = chaincodeID; } /** * Get the event hub. * @return {hfc.EventHub} The event hub. */ getEventHub() { return this.eventHub; } /** * Set the event hub. * @param {hfc.EventHub} eventHub - The event hub. */ setEventHub(eventHub) { this.eventHub = eventHub; } } module.exports = SecurityContext; Ã— Search results Close "},"lib_securityexception.js.html":{"id":"lib_securityexception.js.html","title":"Source: lib/securityexception.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/securityexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('./baseexception'); /** * Class representing a security exception * &lt;p&gt;&lt;a href=&quot;diagrams/securityexception.svg&quot;&gt;&lt;img src=&quot;diagrams/securityexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class SecurityException extends BaseException { /** * Create the SecurityException. * @param {string} message - The exception message. */ constructor(message) { super(message); } } module.exports = SecurityException; Ã— Search results Close "},"lib_serializer.js.html":{"id":"lib_serializer.js.html","title":"Source: lib/serializer.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Resource = require('./model/resource'); const JSON2 = require('JSON2'); const Globalize = require('./globalize'); const JSONGenerator = require('./serializer/jsongenerator'); const JSONPopulator = require('./serializer/jsonpopulator'); const ResourceValidator = require('./serializer/resourcevalidator'); const TypedStack = require('./serializer/typedstack'); const JSONWriter = require('./codegen/jsonwriter'); /** * Serialize Resources instances to/from various formats for long-term storage * (e.g. on the blockchain). * &lt;p&gt;&lt;a href=&quot;diagrams/serializer.svg&quot;&gt;&lt;img src=&quot;diagrams/serializer.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; */ class Serializer { /** * Create a Serializer. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; * @param {Factory} factory - The Factory to use to create instances * @param {ModelManager} modelManager - The ModelManager to use for validation etc. */ constructor(factory,modelManager) { if(!factory) { throw new Error(Globalize.formatMessage('serializer-constructor-factorynull')); } else if(!modelManager) { throw new Error(Globalize.formatMessage('serializer-constructor-modelmanagernull')); } this.factory = factory; this.modelManager = modelManager; } /** * &lt;p&gt; * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * &lt;/p&gt; * @param {Resource} resource - The instance to convert to JSON * @param {Object} options - the optional serialization options. * @param {boolean} options.validate - validate the structure of the Resource * with its model prior to serialization (default to true) * @return {Object} - The Javascript Object that represents the resource * @throws {Error} - throws an exception if resource is not an instance of * Resource or fails validation. */ toJSON(resource, options) { // correct instance type if(!(resource instanceof Resource)) { throw new Error(Globalize.formatMessage('serializer-tojson-notcobject')); } const parameters = {}; parameters.stack = new TypedStack(resource); parameters.modelManager = this.modelManager; const classDeclaration = this.modelManager.getType( resource.getFullyQualifiedType() ); if(!classDeclaration) { throw new Error( 'Failed to find type ' + resource.getFullyQualifiedType() + ' in ModelManager.' ); } // validate the resource against the model if(!options || options.validate === true) { const validator = new ResourceValidator(); classDeclaration.accept(validator, parameters); } const generator = new JSONGenerator(); const writer = new JSONWriter(); parameters.writer = writer; parameters.stack.clear(); parameters.stack.push(resource); // this writes the JSON into the parameters.writer classDeclaration.accept(generator, parameters); const jsonText = parameters.writer.getBuffer(); try { return JSON2.parse(jsonText); } catch(err) { throw new Error( 'Generated invalid JSON: ' + jsonText ); } } /** * Create a {@link Resource} from a JavaScript Object representation. * The JavaScript Object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * * The Resource is populated based on the JavaScript object. * * @param {Object} jsonObject The JavaScript Object for a Resource * @param {Object} options - the optional serialization options * @return {Resource} The new populated resource */ fromJSON(jsonObject, options) { if(!jsonObject.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier.'); } const classDeclaration = this.modelManager.getType(jsonObject.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonObject.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let resource = this.factory.newInstance( classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); // populate the resource based on the jsonObject // by walking the classDeclaration const parameters = {}; parameters.jsonStack = new TypedStack(jsonObject); parameters.resourceStack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.factory = this.factory; const populator = new JSONPopulator(); classDeclaration.accept(populator, parameters); return resource; } } module.exports = Serializer; Ã— Search results Close "},"systest_testutil.js.html":{"id":"systest_testutil.js.html","title":"Source: systest/testutil.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: systest/testutil.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Concerto = require('..').Concerto; const net = require('net'); const Util = require('../lib/util'); let concerto; let securityContext; /** * A class containing test utilities for use in Concerto system tests. * * @private */ class TestUtil { /** * Wait for the specified hostname to start listening on the specified port. * @param {string} hostname - the hostname. * @param {integer} port - the port. * @return {Promise} - a promise that will be resolved when the specified * hostname to start listening on the specified port. */ static waitForPort(hostname, port) { let waitTime = 30; if (process.env.CONCERTO_PORT_WAIT_SECS) { waitTime = parseInt(process.env.CONCERTO_PORT_WAIT_SECS); console.log('CONCERTO_PORT_WAIT_SECS set, using: ', waitTime); } return new Promise(function (resolve, reject) { let testConnect = function (count) { let s = new net.Socket(); s.on('error', function (error) { if (count &gt; waitTime) { console.error('Port has not started, giving up waiting'); return reject(error); } else { console.log('Port has not started, waiting 1 second ...'); setTimeout(function () { testConnect(count + 1); }, 1000); } }); s.on('connect', function () { console.log('Port has started'); s.end(); return resolve(); }); console.log('Testing if port ' + port + ' on host ' + hostname + ' has started ...'); s.connect(port, hostname); }; testConnect(0); }); } /** * Wait for the peer on the specified hostname and port to start listening * on the specified port. * @return {Promise} - a promise that will be resolved when the peer has * started listening on the specified port. */ static waitForPorts() { return TestUtil.waitForPort('vp0', 7051) .then(() =&gt; { return TestUtil.waitForPort('vp0', 7053); }) .then(() =&gt; { return TestUtil.waitForPort('membersrvc', 7054); }); } /** * Create a new Concerto object, connect, and deploy the chain-code. * @return {Promise} - a promise that wil be resolved with a configured and * connected instance of Concerto. */ static setUp() { return TestUtil.waitForPorts() .then(function () { console.log('Calling Concerto.connect() ...'); concerto = new Concerto({ developmentMode: true }); let options = { keyValStore: '/tmp/keyValStore', membershipServicesURL: 'grpc://membersrvc:7054', peerURL: 'grpc://vp0:7051', eventHubURL: 'vp0:7053' }; if (process.env.CONCERTO_DEPLOY_WAIT_SECS) { options.deployWaitTime = parseInt(process.env.CONCERTO_DEPLOY_WAIT_SECS); console.log('CONCERTO_DEPLOY_WAIT_SECS set, using: ', options.deployWaitTime); } if (process.env.CONCERTO_INVOKE_WAIT_SECS) { options.invokeWaitTime = parseInt(process.env.CONCERTO_INVOKE_WAIT_SECS); console.log('CONCERTO_INVOKE_WAIT_SECS set, using: ', options.invokeWaitTime); } return concerto.connect(options); }) .then(function () { console.log('Called Concerto.connect()'); console.log('Calling Concerto.login() ...'); return concerto.login('WebAppAdmin', 'DJY27pEnl16d'); }) .then(function (result) { console.log('Called Concerto.login()'); securityContext = result; console.log('Calling Concerto.deploy() ...'); return concerto.deploy(securityContext); }) .then(function () { console.log('Called Concerto.deploy()'); console.log(''); return Promise.resolve(concerto); }); } /** * Disconnect the Concerto object. * @return {Promise} - a promise that wil be resolved with a configured and * connected instance of Concerto. */ static tearDown() { if (!concerto) { throw new Error('Must call setUp successfully before calling tearDown'); } console.log('Calling Concerto.disconnect() ...'); return concerto.disconnect() .then(function () { console.log('Called Concerto.disconnect()'); }); } /** * Get a configured and connected instance of Concerto. * @return {Concerto} - a configured and connected instance of Concerto. */ static getConcerto() { if (!concerto) { throw new Error('Must call setUp successfully before calling getConcerto'); } return concerto; } /** * Get a logged in security context for interacting with Concerto. * @return {SecurityContext} - a logged in security context for interacting with Concerto. */ static getSecurityContext() { if (!concerto || !securityContext) { throw new Error('Must call getConcerto successfully before calling getSecurityContext'); } return securityContext; } /** * Invoke the chain-code to clear all of the world state so that any test * data is removed. Call in-between tests. * @return {Promise} - a promise that will be resolved once the chain-code * has been invoked. */ static clearWorldState() { if (!concerto || !securityContext) { return Promise.reject(new Error('Must call getConcerto successfully before calling clearWorldState')); } return Util.invokeChainCode(securityContext, 'clearWorldState', []); } } module.exports = TestUtil; Ã— Search results Close "},"lib_parser_transactiondeclaration.js.html":{"id":"lib_parser_transactiondeclaration.js.html","title":"Source: lib/parser/transactiondeclaration.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/parser/transactiondeclaration.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** Class representing the definition of an Transaction. * @extends ClassDeclaration * @private */ class TransactionDeclaration extends ClassDeclaration { /** * Create an TransactionDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } } module.exports = TransactionDeclaration; Ã— Search results Close "},"lib_transactionregistry.js.html":{"id":"lib_transactionregistry.js.html","title":"Source: lib/transactionregistry.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/transactionregistry.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Registry = require('./registry'); const Util = require('./util'); const REGISTRY_TYPE = 'Transaction'; /** * The TransactionRegistry is used to store a set of transactions on the blockchain. * &lt;p&gt;&lt;a href=&quot;diagrams/transactionregistry.svg&quot;&gt;&lt;img src=&quot;diagrams/transactionregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry */ class TransactionRegistry extends Registry { /** * Get a list of all existing transaction registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a list of {@link TransactionRegistry} * instances representing the transaction registries. */ static getAllTransactionRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then(function (transactionRegistries) { return transactionRegistries.map(function (transactionRegistry) { return new TransactionRegistry(transactionRegistry.id, transactionRegistry.name, modelManager, factory, serializer); }); }); } /** * Get an existing transaction registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the transaction registry. */ static getTransactionRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then(function (registry) { return new TransactionRegistry(registry.id, registry.name, modelManager, factory, serializer); }); } /** * Add a new transaction registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {string} name The name of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the new transaction registry. */ static addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(function () { return new TransactionRegistry(id, name, modelManager, factory, serializer); }); } /** * Create an transaction registry. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Concerto}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} id The unique identifier of the transaction registry. * @param {string} name The display name for the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. */ constructor(id, name, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. Call {@link Concerto.submitTransaction} to submit a transaction. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. */ add(securityContext, id, data) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. This method will always throw an exception when called. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. * @param {string} data The data for the resource. */ update(securityContext, id, data) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the resource. */ remove(securityContext, id) { throw new Error('cannot remove transactions from a transaction registry'); } /** * Get all of the transactions in the registry. * * @param {SecurityContext} securityContext The user's security context. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} instances representing the transactions. */ getAll(securityContext) { let self = this; Util.securityCheck(securityContext); return super.getAll(securityContext) .then(function (resources) { return resources.map(function (resource) { return self.serializer.fromJSON(JSON.parse(resource.data)); }); }); } /** * Get a specific transaction in the registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction. * @return {Promise} A promise that will be resolved with a {@link Resource} * instance representing the transaction. */ get(securityContext, id) { let self = this; Util.securityCheck(securityContext); return super.get(securityContext, id) .then(function (resource) { return self.serializer.fromJSON(JSON.parse(resource.data)); }); } } module.exports = TransactionRegistry; Ã— Search results Close "},"lib_serializer_typedstack.js.html":{"id":"lib_serializer_typedstack.js.html","title":"Source: lib/serializer/typedstack.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer/typedstack.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Util = require('../util'); /** * Tracks a stack of typed instances. The type information is used to detect * overflow / underflow bugs by the caller. It also performs basic sanity * checking on push/pop to make detecting bugs easier. * @private */ class TypedStack { /** * Create the Stack with the resource at the head. * @param {Object} resource - the resource to be put at the head of the stack */ constructor(resource) { this.stack = []; this.push(resource); } /** * Push a new object. * @param {Object} obj - the object being visited * @param {Object} expectedType - the expected type of the object being pushed */ push(obj, expectedType) { if(expectedType &amp;&amp; !(obj instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType.constructor.name + ' as argument to push. Found: ' + JSON.stringify(obj)); } if(Util.isNull(obj)) { throw new Error('Pushing null data!'); } this.stack.push(obj); //console.log('Push depth is: ' + this.stack.length + ', contents: ' + this.stack.toString() ); } /** * Push a new object. * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of pop */ pop(expectedType) { this.peek(expectedType); return this.stack.pop(); } /** * Peek the top of the stack * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of peek */ peek(expectedType) { //console.log( 'pop ' ); if(this.stack.length &lt; 1) { throw new Error('Stack is empty!'); } const result = this.stack[this.stack.length-1]; if(expectedType &amp;&amp; !(result instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType + ' on head of stack. Found: ' + JSON.stringify(result)); } if(Util.isNull(result)) { throw new Error('Pop returned invalid data'); } return result; } /** * Clears the stack */ clear() { this.stack = []; } } module.exports = TypedStack; Ã— Search results Close "},"lib_codegen_typescript_typescriptvisitor.js.html":{"id":"lib_codegen_typescript_typescriptvisitor.js.html","title":"Source: lib/codegen/typescript/typescriptvisitor.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/typescript/typescriptvisitor.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const ModelManager = require('../../modelmanager'); const ModelUtil = require('../../modelutil'); const ModelFile = require('../../parser/modelfile'); const ClassDeclaration = require('../../parser/classdeclaration'); const Field = require('../../parser/field'); const RelationshipDeclaration = require('../../parser/relationshipdeclaration'); const EnumDeclaration = require('../../parser/enumdeclaration'); const EnumValueDeclaration = require('../../parser/enumvaluedeclaration'); const FunctionDeclaration = require('../../parser/functiondeclaration'); const _ = require('underscore'); /** * Convert the contents of a ModelManager to Go Lang code. * All generated code is placed into the 'main' package. Set a * fileWriter property (instance of FileWriter) on the parameters * object to control where the generated code is written to disk. * * @private */ class TypescriptVisitor { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ModelManager) { return this.visitModelManager(thing, parameters); } else if (thing instanceof ModelFile) { return this.visitModelFile(thing, parameters); } else if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationship(thing, parameters); } else if (thing instanceof EnumValueDeclaration) { return this.visitEnumValueDeclaration(thing, parameters); } else if (thing instanceof FunctionDeclaration) { // return this.visitEnum(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ModelManager} modelManager - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelManager(modelManager, parameters) { let visitModelFile = function(modelFile) { modelFile.accept(this,parameters); }; _.each(modelManager.getModelFiles(), visitModelFile.bind(this)); return null; } /** * Visitor design pattern * @param {ModelFile} modelFile - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitModelFile(modelFile, parameters) { parameters.fileWriter.openFile(modelFile.getNamespace() + '.ts'); // TODO (DCS) don't yet understand namespaces... parameters.fileWriter.writeLine(0, '// export namespace ' + modelFile.getNamespace() + '{'); let visitClass = function(classDeclaration) { classDeclaration.accept(this,parameters); }; _.each(modelFile.getAllDeclarations(), visitClass.bind(this)); parameters.fileWriter.writeLine(0, '// }'); parameters.fileWriter.closeFile(); return null; } /** * Visitor design pattern * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { parameters.fileWriter.writeLine(1, 'export enum ' + enumDeclaration.getName() + ' {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(enumDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(1, '}' ); return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { let isAbstract = ''; if( classDeclaration.isAbstract() ) { isAbstract = 'export abstract '; } else { isAbstract = 'export '; } let superType = ''; if(classDeclaration.getSuperType()) { superType = ' extends ' + ModelUtil.getShortName(classDeclaration.getSuperType()); } parameters.fileWriter.writeLine(1, isAbstract + 'class ' + classDeclaration.getName() + superType + ' {' ); let visitProperty = function(property) { property.accept(this,parameters); }; _.each(classDeclaration.getOwnProperties(), visitProperty.bind(this)); parameters.fileWriter.writeLine(1, '}' ); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { let array = ''; if(field.isArray()) { array = '[]'; } parameters.fileWriter.writeLine(2, field.getName() + ': ' + this.toTsType(field.getType()) + array + ';' ); return null; } /** * Visitor design pattern * @param {EnumValueDeclaration} enumValueDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumValueDeclaration(enumValueDeclaration, parameters) { parameters.fileWriter.writeLine(2, enumValueDeclaration.getName() + ',' ); return null; } /** * Visitor design pattern * @param {Relationship} relationship - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationship(relationship, parameters) { let array = ''; if(relationship.isArray()) { array = '[]'; } // we export all relationships by capitalizing them parameters.fileWriter.writeLine(2, relationship.getName() + ': ' + this.toTsType(relationship.getType()) + array + ';' ); return null; } /** * Converts a Concerto type to a Typescript type. Primitive types are converted * everything else is passed through unchanged. * @param {string} type - the concerto type * @return {string} the corresponding type in Typescript * @private */ toTsType(type) { switch(type) { case 'DateTime': return 'Date'; case 'Boolean': return 'boolean'; case 'String': return 'string'; case 'Double': return 'number'; case 'Long': return 'number'; case 'Integer': return 'number'; default: return type; } } } module.exports = TypescriptVisitor; Ã— Search results Close "},"lib_util.js.html":{"id":"lib_util.js.html","title":"Source: lib/util.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/util.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const Globalize = require('./globalize'); const SecurityContext = require('./securitycontext'); const SecurityException = require('./securityexception'); const fs = require('fs-extra'); const hfc = require('hfc'); const path = require('path'); const temp = require('temp').track(); const uuid = require('node-uuid'); /** * Internal Utility Class * &lt;p&gt;&lt;a href=&quot;diagrams/util.svg&quot;&gt;&lt;img src=&quot;diagrams/util.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private */ class Util { /** * Internal method to check the security context * @param {SecurityContext} securityContext - The user's security context * @throws {SecurityException} if the user context is invalid */ static securityCheck(securityContext) { if (Util.isNull(securityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } else if (!(securityContext instanceof SecurityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } } /** * Submit a query request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static queryChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); let enrolledMember = securityContext.getEnrolledMember(); let queryRequest = { chaincodeID: securityContext.getChaincodeID(), fcn: functionName, args: args }; return new Promise(function (resolve, reject) { let transactionContext = enrolledMember.query(queryRequest); transactionContext.on('submitted', function () { // TODO: we should probably log this! }); transactionContext.on('complete', function (data) { resolve(data.result); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }); } /** * Submit an invoke request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static invokeChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); let enrolledMember = securityContext.getEnrolledMember(); let invokeRequest = { chaincodeID: securityContext.getChaincodeID(), fcn: functionName, args: args }; return new Promise(function (resolve, reject) { let transactionContext = enrolledMember.invoke(invokeRequest); transactionContext.on('submitted', function () { // TODO: we should probably log this! }); transactionContext.on('complete', function () { resolve(); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }); } /** * Returns true if the typeof the object === 'undefined' or * the object === null. * @param {Object} obj - the object to be tested * @returns {boolean} true if the object is null or undefined */ static isNull(obj) { return(typeof(obj) === 'undefined' || obj === null); } /** * Submit an deploy request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} chaincodePath - The path of the chain-code to deploy. * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @param {boolean} force - Force a new instance of the chain-code to deploy. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static deployChainCode(securityContext, chaincodePath, functionName, args, force) { Util.securityCheck(securityContext); if (!chaincodePath) { throw new Error('chaincodePath not specified'); } else if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); // Because hfc needs to write a Dockerfile to the chaincode directory, we // must copy the chaincode to a temporary directory. We need to do this // to handle the case where Concerto is installed into the global directory // (npm install -g) and is therefore owned by the root user. return new Promise((resolve, reject) =&gt; { // Create a temporary directory to contain the chaincode. temp.mkdir('concerto', (err, tempDirectoryPath) =&gt; { if (err) { return reject(err); } resolve(tempDirectoryPath); }); }) .then((tempDirectoryPath) =&gt; { // Copy the chaincode from source directory to temporary directory. return new Promise((resolve, reject) =&gt; { let sourceDirectoryPath = path.resolve(__dirname, '..', 'chaincode', 'src', chaincodePath); let targetDirectoryPath = path.resolve(tempDirectoryPath, 'src', chaincodePath); fs.copy(sourceDirectoryPath, targetDirectoryPath, (err) =&gt; { if (err) { return reject(err); } resolve(tempDirectoryPath); }); }); }) .then((tempDirectoryPath) =&gt; { // If force is specified, then we want to write a unique file into // the chaincode to trick hfc into deploying a new instance. if (force) { return new Promise((resolve, reject) =&gt; { let targetFilePath = path.resolve(tempDirectoryPath, 'src', chaincodePath, 'cc_unique_id.go'); let targetUUID = uuid.v4(); let targetFileContents = ` package main // The unique ID for this chaincode. const chaincodeUniqueID = &quot;${targetUUID}&quot; `; fs.outputFile(targetFilePath, targetFileContents, (err) =&gt; { if (err) { return reject(err); } resolve(tempDirectoryPath); }); }); } else { return tempDirectoryPath; } }) .then((tempDirectoryPath) =&gt; { // Now we can ask hfc to deploy the chaincode. return new Promise((resolve, reject) =&gt; { // This is evil! I shouldn't need to set GOPATH in a node.js program. process.env.GOPATH = tempDirectoryPath; let deployRequest = { fcn: functionName, args: args, chaincodePath: chaincodePath }; let enrolledMember = securityContext.getEnrolledMember(); let transactionContext = enrolledMember.deploy(deployRequest); transactionContext.on('complete', function (result) { resolve(result); }); transactionContext.on('error', function (error) { if (error instanceof hfc.EventTransactionError) { reject(new Error(error.msg)); } else { reject(error); } }); }) // On failure, we need to delete the temporary directory. .catch((err) =&gt; { return new Promise((resolve, reject) =&gt; { fs.remove(tempDirectoryPath, (err2) =&gt; { if (err2) { return reject(err2); } return resolve(); }); }) .catch((err2) =&gt; { // We want to throw the original exception! throw err; }) .then(() =&gt; { // We want to throw the original exception! throw err; }); }) // On success, we also need to delete the temporary directory. .then((result) =&gt; { return new Promise((resolve, reject) =&gt; { fs.remove(tempDirectoryPath, (err) =&gt; { if (err) { return reject(err); } resolve(result); }); }); }); }); } } module.exports = Util; Ã— Search results Close "},"lib_model_validatedresource.js.html":{"id":"lib_model_validatedresource.js.html","title":"Source: lib/model/validatedresource.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/model/validatedresource.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const TypedStack = require('../serializer/typedstack'); const Resource = require('./resource'); /** * ValidatedResource is a Resource that can validate that property * changes (or the whole instance) do not violate the structure of * the type information associated with the instance. * @extends ValidatedResource */ class ValidatedResource extends Resource { /** * This constructor should not be called directly. * Use the Factory class to create instances. * * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, id,resourceValidator) { super(modelManager, ns, type, id); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedResource; Ã— Search results Close "},"lib_serializer_validationexception.js.html":{"id":"lib_serializer_validationexception.js.html","title":"Source: lib/serializer/validationexception.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/serializer/validationexception.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception thrown when a resource fails to model against the model */ class ValidationException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ValidationException; Ã— Search results Close "},"lib_codegen_writer.js.html":{"id":"lib_codegen_writer.js.html","title":"Source: lib/codegen/writer.js","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Source: lib/codegen/writer.js /* * IBM Confidential * OCO Source Materials * IBM Concerto - Blockchain Solution Framework * Copyright IBM Corp. 2016 * The source code for this program is not published or otherwise * divested of its trade secrets, irrespective of what has * been deposited with the U.S. Copyright Office. */ 'use strict'; /** * Writer buffers text to be written in memory. It handles simple * indentation and tracks the number of lines written. * @private */ class Writer { /** * Create a FileWriter. * */ constructor() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } /** * Writes text to the start of the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.beforeBuffer += ' '; } this.beforeBuffer += text; this.beforeBuffer += '\\n'; this.linesWritten++; } /** * Append text to the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); this.write('\\n'); this.linesWritten++; } /** * Returns the number of lines that have been written to the buffer. * @return {int} the number of lines written to the buffer. */ getLineCount() { return this.linesWritten; } /** * Append text to the buffer, prepending tabs * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeIndented(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); } /** * Append text to the buffer (no automatic newline). The * text may contain newline, and these will increment the linesWritten * counter. * @param {string} msg - the text to write */ write(msg) { if(typeof msg !== 'string' ) { throw new Error('Can only append strings. Argument ' + msg + ' has type ' + typeof msg); } this.buffer += msg; this.linesWritten += msg.split(/\\r\\n|\\r|\\n/).length; } /** * Returns the text that has been buffered in this Writer. * @return {string} the buffered text. */ getBuffer() { return this.beforeBuffer + this.buffer; } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } } module.exports = Writer; Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Global Methods &lt;private&gt; directoryExists(path) Returns true if the given directory exists. Parameters: Name Type Description path string the file path to check Source: lib/codegen/filewriter.js, line 149 Returns: true if the directory exists Type boolean &lt;private&gt; ensureDirectoryExistence(filePath) Checks that an entire directory tree exists, and creates it if it does not. Parameters: Name Type Description filePath string the file path to check Source: lib/codegen/filewriter.js, line 132 Returns: true if the directory exists Type boolean &lt;private&gt; findCommentBefore(rangeStart, rangeEnd, comments) Find the comments that is above and closest to the start of the range. Parameters: Name Type Description rangeStart integer the start of the range rangeEnd integer the end of the range comments Array.&lt;string&gt; the end of the range Source: lib/codegen/umlgen.js, line 207 Returns: the comment index or -1 if there are no comments Type integer &lt;private&gt; getMethodArguments(comment) Extracts the method arguments from a comment block. Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 288 Returns: the the argument types Type string &lt;private&gt; getReturnType(comment) Extracts the return type from a comment block. Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 268 Returns: the return type of the comment Type string &lt;private&gt; getVisibility(comment) Extracts the visibilty from a comment block Parameters: Name Type Description comment string the comment block Source: lib/codegen/umlgen.js, line 252 Returns: the return visibility (either + for public, or - for private) Type string &lt;private&gt; processDirectory(path) Parameters: Name Type Description path string the path to process Source: lib/codegen/umlgen.js, line 42 &lt;private&gt; processFile(file) Parameters: Name Type Description file string the file to process Source: lib/codegen/umlgen.js, line 64 &lt;private&gt; toUMLFilename(inputDir, outputDir, filename) Parameters: Name Type Description inputDir string the fully qualified input directory outputDir string the fully qualified output directory filename string the fully qualified input file name (.js) Source: lib/codegen/umlgen.js, line 232 Returns: the UML file name to use Type string Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Modules Classes AssetDeclaration AssetRegistry BaseException ClassDeclaration Concerto EnumDeclaration EnumValueDeclaration Factory Field FileWriter FunctionDeclaration GoLangVisitor Identifiable IllegalModelException JSONGenerator JSONPopulator JSONWriter ModelFile ModelManager ModelRegistry ModelUtil ParseException ParticipantDeclaration PlantUMLVisitor Property Registry Relationship RelationshipDeclaration Resource ResourceValidator SecurityContext SecurityException Serializer TestUtil TransactionDeclaration TransactionRegistry TypedStack TypescriptVisitor Util ValidatedResource ValidationException Writer Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Classes Classes AssetDeclaration AssetRegistry BaseException ClassDeclaration Concerto EnumDeclaration EnumValueDeclaration Factory Field FileWriter FunctionDeclaration GoLangVisitor Identifiable IllegalModelException JSONGenerator JSONPopulator JSONWriter ModelFile ModelManager ModelRegistry ModelUtil ParseException ParticipantDeclaration PlantUMLVisitor Property Registry Relationship RelationshipDeclaration Resource ResourceValidator SecurityContext SecurityException Serializer TestUtil TransactionDeclaration TransactionRegistry TypedStack TypescriptVisitor Util ValidatedResource ValidationException Writer Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Ã— Search results Close "},"AssetDeclaration.html":{"id":"AssetDeclaration.html","title":"Class: AssetDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: AssetDeclaration AssetDeclaration AssetDeclaration defines the schema (aka model or class) for an Asset. It extends ClassDeclaration which manages a set of fields, a super-type and the specification of an identifying field. &lt;private&gt; new AssetDeclaration(modelFile, ast) Create an AssetDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/assetdeclaration.js, line 22 Ã— Search results Close "},"AssetRegistry.html":{"id":"AssetRegistry.html","title":"Class: AssetRegistry","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: AssetRegistry AssetRegistry The AssetRegistry is used to manage a set of assets stored on the blockchain. new AssetRegistry(id, name, modelManager, factory, serializer) Create an asset registry. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Parameters: Name Type Description id string The unique identifier of the asset registry. name string The display name for the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 24 Extends Registry Methods &lt;protected, static&gt; addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset registry. name string The name of the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 96 Returns: A promise that will be resolved with a AssetRegistry instance representing the new asset registry. Type Promise &lt;protected, static&gt; getAllAssetRegistries(securityContext, modelManager, factory, serializer) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 37 Returns: A promise that will be resolved with a list of AssetRegistry instances representing the asset registries. Type Promise &lt;protected, static&gt; getAssetRegistry(securityContext, id, modelManager, factory, serializer) Get an existing asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: lib/assetregistry.js, line 66 Returns: A promise that will be resolved with a AssetRegistry instance representing the asset registry. Type Promise add(securityContext, asset) Adds an asset to the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset Resource The asset to be added to the asset registry. Overrides: Registry#add Source: lib/assetregistry.js, line 150 Returns: A promise that is resolved when the asset is added to the asset registry. Type Promise get(securityContext, id) Get a specific asset in the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset. options.resolve boolean &lt;optional&gt; Resolve all of the assets relationships. Overrides: Registry#get Source: lib/assetregistry.js, line 251 Returns: A promise that will be resolved with a Resource instance representing the asset. Type Promise getAll(securityContext) Get all of the assets in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Overrides: Registry#getAll Source: lib/assetregistry.js, line 205 Returns: A promise that will be resolved with an array of Resource instances representing the assets. Type Promise remove(securityContext, asset) Remove an asset with a given type and id from the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset Resource | string The asset, or the unique identifier of the asset. Overrides: Registry#remove Source: lib/assetregistry.js, line 184 Returns: A promise that is resolved when the element is removed from the registry. Type Promise resolve(securityContext, id) Get a specific asset in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved asset. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the asset. Source: lib/assetregistry.js, line 277 Returns: A promise that will be resolved with a JavaScript object representing the asset and all of its resolved relationships. Type Promise resolveAll(securityContext) Get all of the assets in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved asset. Parameters: Name Type Description securityContext SecurityContext The user's security context. Source: lib/assetregistry.js, line 229 Returns: A promise that will be resolved with an array of JavaScript objects representing the assets and all of their resolved relationships. Type Promise update(securityContext, asset) Updates an asset in the asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. asset Resource The asset to be updated in the asset registry. Overrides: Registry#update Source: lib/assetregistry.js, line 167 Returns: A promise that is resolved when the asset is updated in the asset registry. Type Promise Ã— Search results Close "},"BaseException.html":{"id":"BaseException.html","title":"Class: BaseException","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: BaseException BaseException A base class for all Concerto exceptions new BaseException(message) Create the BaseException. Parameters: Name Type Description message string The exception message. Source: lib/baseexception.js, line 18 Extends Error Ã— Search results Close "},"ClassDeclaration.html":{"id":"ClassDeclaration.html","title":"Class: ClassDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ClassDeclaration ClassDeclaration ClassDeclaration defines the structure (model/schema) of composite data. It is composed of a set of Properties, may have an identifying field, and may have a super-type. A ClassDeclaration is conceptually owned with a ModelFile which defines all the classes that are part of a namespace. This class is abstract and should not be instantiated. &lt;abstract, private&gt; new ClassDeclaration(modelFile, ast) Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the result of parsing. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast string the AST created by the parser Source: lib/parser/classdeclaration.js, line 30 Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/parser/classdeclaration.js, line 57 Returns: the result of visiting or null Type Object getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Source: lib/parser/classdeclaration.js, line 229 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Source: lib/parser/classdeclaration.js, line 239 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Source: lib/parser/classdeclaration.js, line 66 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Source: lib/parser/classdeclaration.js, line 219 Returns: the short name of this class Type string getOwnProperties() Returns the fields directly defined by this class. Source: lib/parser/classdeclaration.js, line 274 Returns: the array of fields Type Array.&lt;Property&gt; getOwnProperty(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Source: lib/parser/classdeclaration.js, line 258 Returns: the field definition or null if it does not exist. Type Property getProperties() Returns the properties defined in this class and all super classes. Source: lib/parser/classdeclaration.js, line 328 Returns: the array of fields Type Array.&lt;Property&gt; getProperty(name) Returns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Source: lib/parser/classdeclaration.js, line 305 Returns: the field, or null if it does not exist Type Property getSuperType() Returns the FQN of the super type for this class or null if this class does not have a super type. Source: lib/parser/classdeclaration.js, line 284 Returns: the FQN name of the super type or null Type string isAbstract() Returns true if this class is declared as abstract in the model file Source: lib/parser/classdeclaration.js, line 200 Returns: true if the class is abstract Type boolean isEnum() Returns true if this class is an enumeration. Source: lib/parser/classdeclaration.js, line 209 Returns: true if the class is an enumerated type Type boolean &lt;private&gt; process() Process the AST and build the model Source: lib/parser/classdeclaration.js, line 76 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Source: lib/parser/classdeclaration.js, line 359 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns the string representation of this class Source: lib/parser/classdeclaration.js, line 382 Returns: the string representation of the class Type String &lt;private&gt; validate() Semantic validation of the structure of this class. Subclasses should override this method to impose additional semantic constraints on the contents/relations of fields. Source: lib/parser/classdeclaration.js, line 126 Throws: InvalidModelException Ã— Search results Close "},"Concerto.html":{"id":"Concerto.html","title":"Class: Concerto","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Concerto Concerto Main entry point into the Concerto solution framework. Use this class to retrieve the services defined by the solution framework and to interact with the underlying Hyperledger fabric. This class is designed to be used in a Node.js based middle-tier of a 3-tier application: Presentation tier, e.g. Angular front-end Middle tier, exposes domain specific REST APIs to the presentation tier and embeds the Concerto module to communicate with Hyperledger fabric. Hyperledger fabric, used to store assets and transaction on a blockchain The Concerto class provides access to the major subsystems defined by the framework: ModelManager to declare the structure of Resources for an application domain Factory to create instances of Resources (Assets, Transactions or Participants) Serializer to convert Resources to/from JavaScript Objects for long-term persistence AssetRegistry to store Assets on the blockchain TransactionRegistry to store Transactions on the blockchain submitTransaction to submit Transaction for processing to the Hyperledger fabric. The connect method is used to connect to a Hyperledger fabric instance. The login method is used to authenticate a user/application with the Hyperledger fabric and returns a SecurityContext that must be passed to other Concerto APIs that require authentication. Bootstrapping the Concerto Framework The deploy method is used to deploy the Concerto Framework chaincode to your Hyperledger instance. This only needs to be called once for all Concerto based application that use a Hyperledger fabric instance. Bootstrapping your Application Bootrapping a Concerto-based application requires: Connecting to the Hyperledger Fabric using the connect method Login to the Hyperledger Fabric using the login method Load the application's domain specific Concerto files and add to the ModelManager Use the saveModels method to store the contents of the ModelManager on the blockchain. Application bootstrap only needs to be performed once for a given Hyperledger fabric instance, or when the Concerto files have been modified. new Concerto( [options]) Create an instance of the Concerto class. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description developmentMode boolean &lt;optional&gt; specify whether or not the instance is in development mode. Use only for testing purposes! Source: lib/concerto.js, line 75 Methods addAssetRegistry(securityContext, id, name) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context id string The unique identifier of the asset registry name string The name of the asset registry Source: lib/concerto.js, line 125 Returns: - A promise that will be resolved with the new asset registry after it has been added. Type Promise connect(connectOptions) Connects to the Hyperledger Fabric. Parameters: Name Type Description connectOptions Object The connection options. Properties Name Type Description keyValStore string The local directory to store user certificates in. membershipServicesURL string The URL of the Hyperledger Fabric membership services to connect to. peerURL string The URL of the Hyperledger Fabric peer to connect to. eventHubURL string The URL of the Hyperledger Fabric event hub to connect to. Source: lib/concerto.js, line 213 Returns: A promise that will be resolved when the connection is established. Type Promise deploy(securityContext [, force]) Deploys the Concerto chain-code to the Hyperledger Fabric. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context force boolean &lt;optional&gt; Force a new instance of the chain-code to deploy. Source: lib/concerto.js, line 299 Returns: A promise that will be fufilled when the chain-code has been deployed. Type Promise disconnect() Disconnects from the Hyperledger Fabric. Source: lib/concerto.js, line 253 Returns: A promise that will be resolved when the connection is terminated. Type Promise getAllAssetRegistries(securityContext) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 100 Returns: - A promise that will be resolved with a list of existing asset registries Type Promise getAssetRegistry(securityContext, id) Get an existing asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context id string The unique identifier of the asset registry Source: lib/concerto.js, line 112 Returns: - A promise that will be resolved with the existing asset registry, or rejected if the asset registry does not exist. Type Promise getFactory(securityContext) Returns the Factory, used to create instances of Resources, Relationships and Transactions. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 174 Returns: the Factory Type Factory getModelManager(securityContext) Returns the ModelManager, used to define the entities in an application domain. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 184 Returns: the ModelManager Type ModelManager &lt;private&gt; getModelRegistry(securityContext) Get the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 136 Returns: - A promise that will be resolved with the model registry. Type Promise getSerializer(securityContext) Returns the Serializer Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 194 Returns: the Serializer Type Serializer getTransactionRegistry(securityContext) Get the transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 154 Returns: - A promise that will be resolved to the TransactionRegistry Type Promise loadModels(securityContext) Load the models previously saved using saveModels from the blockchain back into the ModelManager. Note that any existing models in the ModelManager will be cleared. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 336 Returns: A promise that will be fufilled when the models have been loaded into the ModelManager Type Promise login(enrollmentID, enrollmentSecret) Log in to the Hyperledger Fabric as the specified user Parameters: Name Type Description enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user Source: lib/concerto.js, line 272 Returns: A promise that will be resolved with a {SecurityContext} when the the security context Type Promise saveModels(securityContext) Save all of the models in the ModelManager to the blockchain. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/concerto.js, line 356 Returns: A promise that will be fufilled when the models have been saved to the blockchain. Type Promise submitTransaction(securityContext, transaction) Submit a transaction for processing to the Hyperledger fabric. Parameters: Name Type Description securityContext SecurityContext The user's security context transaction Resource The transaction to submit. Use newTransaction to create this object. Source: lib/concerto.js, line 378 Returns: A promise that will be fufilled when the transaction has been processed. Type Promise Ã— Search results Close "},"EnumDeclaration.html":{"id":"EnumDeclaration.html","title":"Class: EnumDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: EnumDeclaration EnumDeclaration EnumDeclaration defines an enumeration of static values. &lt;private&gt; new EnumDeclaration(modelFile, ast) Create an AssetDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/enumdeclaration.js, line 20 Extends ClassDeclaration Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: ClassDeclaration#accept Source: lib/parser/classdeclaration.js, line 57 Returns: the result of visiting or null Type Object getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Inherited From: ClassDeclaration#getFullyQualifiedName Source: lib/parser/classdeclaration.js, line 229 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Inherited From: ClassDeclaration#getIdentifierFieldName Source: lib/parser/classdeclaration.js, line 239 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Inherited From: ClassDeclaration#getModelFile Source: lib/parser/classdeclaration.js, line 66 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Inherited From: ClassDeclaration#getName Source: lib/parser/classdeclaration.js, line 219 Returns: the short name of this class Type string getOwnProperties() Returns the fields directly defined by this class. Inherited From: ClassDeclaration#getOwnProperties Source: lib/parser/classdeclaration.js, line 274 Returns: the array of fields Type Array.&lt;Property&gt; getOwnProperty(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getOwnProperty Source: lib/parser/classdeclaration.js, line 258 Returns: the field definition or null if it does not exist. Type Property getProperties() Returns the properties defined in this class and all super classes. Inherited From: ClassDeclaration#getProperties Source: lib/parser/classdeclaration.js, line 328 Returns: the array of fields Type Array.&lt;Property&gt; getProperty(name) Returns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getProperty Source: lib/parser/classdeclaration.js, line 305 Returns: the field, or null if it does not exist Type Property getSuperType() Returns the FQN of the super type for this class or null if this class does not have a super type. Inherited From: ClassDeclaration#getSuperType Source: lib/parser/classdeclaration.js, line 284 Returns: the FQN name of the super type or null Type string isAbstract() Returns true if this class is declared as abstract in the model file Inherited From: ClassDeclaration#isAbstract Source: lib/parser/classdeclaration.js, line 200 Returns: true if the class is abstract Type boolean isEnum() Returns true if this class is an enumeration. Overrides: ClassDeclaration#isEnum Source: lib/parser/enumdeclaration.js, line 37 Returns: true if the class is an enumerated type Type boolean &lt;private&gt; process() Process the AST and build the model Inherited From: ClassDeclaration#process Source: lib/parser/classdeclaration.js, line 76 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Inherited From: ClassDeclaration#toJSON Source: lib/parser/classdeclaration.js, line 359 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns the string representation of this class Overrides: ClassDeclaration#toString Source: lib/parser/enumdeclaration.js, line 45 Returns: the string representation of the class Type String &lt;private&gt; validate() Semantic validation of the structure of this class. Subclasses should override this method to impose additional semantic constraints on the contents/relations of fields. Inherited From: ClassDeclaration#validate Source: lib/parser/classdeclaration.js, line 126 Throws: InvalidModelException Ã— Search results Close "},"EnumValueDeclaration.html":{"id":"EnumValueDeclaration.html","title":"Class: EnumValueDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: EnumValueDeclaration EnumValueDeclaration Class representing a value from a set of enumerated values &lt;private&gt; new EnumValueDeclaration(parent, ast) Create a EnumValueDeclaration. Parameters: Name Type Description parent ClassDeclaration The owner of this property ast Object The AST created by the parser Source: lib/parser/enumvaluedeclaration.js, line 20 Extends Property Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: Property#accept Source: lib/parser/property.js, line 41 Returns: the result of visiting or null Type Object getFullyQualifiedTypeName() Returns the fully qualified type name of a property Inherited From: Property#getFullyQualifiedTypeName Source: lib/parser/property.js, line 126 Returns: the fully qualified type of this property Type string getName() Returns the name of a property Inherited From: Property#getName Source: lib/parser/property.js, line 102 Returns: the name of this field Type string getNamespace() Returns the namespace of the parent of this property Inherited From: Property#getNamespace Source: lib/parser/property.js, line 153 Returns: the namespace of the parent of this property Type string getParent() Returns the owner of this property Inherited From: Property#getParent Source: lib/parser/property.js, line 49 Returns: the parent class declaration Type ClassDeclaration getType() Returns the type of a property Inherited From: Property#getType Source: lib/parser/property.js, line 110 Returns: the type of this field Type string isArray() Returns true if the field is declared as an array type Inherited From: Property#isArray Source: lib/parser/property.js, line 161 Returns: true if the property is an array type Type boolean isOptional() Returns true if the field is optional Inherited From: Property#isOptional Source: lib/parser/property.js, line 118 Returns: true if the field is optional Type boolean isPrimitive() Returns true if this property is a primitive type. Inherited From: Property#isPrimitive Source: lib/parser/property.js, line 184 Returns: true if the property is a primitive type. Type boolean isTypeEnum() Returns true if the field is declared as an enumerated value Inherited From: Property#isTypeEnum Source: lib/parser/property.js, line 170 Returns: true if the property is an enumerated value Type boolean &lt;private&gt; process() Process the AST and build the model Inherited From: Property#process Source: lib/parser/property.js, line 58 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Inherited From: Property#toJSON Source: lib/parser/property.js, line 193 Returns: A new object suitable for serializing as JSON. Type Object &lt;private&gt; validate(classDecl) Validate the property Parameters: Name Type Description classDecl ClassDeclaration the class declaration of the property Overrides: Property#validate Source: lib/parser/enumvaluedeclaration.js, line 38 Throws: InvalidModelException Ã— Search results Close "},"Factory.html":{"id":"Factory.html","title":"Class: Factory","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Factory Factory Use the Factory to create instances of Resource: transactions, participants and assets. new Factory(modelManager) Create the factory. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Parameters: Name Type Description modelManager ModelManager The ModelManager to use for this registry Source: lib/factory.js, line 27 Methods newInstance(ns, type, id, disableValidation) Create a new Resource with a given namespace, type name and id Parameters: Name Type Description ns string the namespace of the Resource type string the type of the Resource id string the identifier disableValidation boolean pass true if you want the factory to return a Resource instead of a ValidatedResource. Defaults to false. Source: lib/factory.js, line 51 Throws: if the type is not registered with the ModelManager Type ModelException Returns: the new instance Type Resource newRelationship(ns, type, id) Create a new Relationship with a given namespace, type and identifier. ` * A relationship is a typed pointer to an instance. I.e the relationship with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` a pointer that points at an instance of org.acme.Vehicle with the id ABC. Parameters: Name Type Description ns string the namespace of the Resource type string the type of the Resource id string the identifier Source: lib/factory.js, line 107 Throws: if the type is not registered with the ModelManager Type ModelException Returns: - the new relationship instance Type Relationship newTransaction(ns, type) Create a new transaction object. The identifier of the transaction is set to a UUID. Parameters: Name Type Description ns string the namespace of the transaction. type string the type of the transaction. Source: lib/factory.js, line 137 Returns: A resource for the new transaction. Type Resource Ã— Search results Close "},"Field.html":{"id":"Field.html","title":"Class: Field","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Field Field Class representing the definition of a Field. A Field is owned by a ClassDeclaration and has a name, type and additional metadata (see below). &lt;private&gt; new Field(parent, ast) Create an Field. Parameters: Name Type Description parent ClassDeclaration The owner of this property ast Object The AST created by the parser Source: lib/parser/field.js, line 22 Extends Property Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: Property#accept Source: lib/parser/property.js, line 41 Returns: the result of visiting or null Type Object getDefaultValue() Returns the default value for the field or null Source: lib/parser/field.js, line 67 Returns: the default value for the field or null Type string getFullyQualifiedTypeName() Returns the fully qualified type name of a property Inherited From: Property#getFullyQualifiedTypeName Source: lib/parser/property.js, line 126 Returns: the fully qualified type of this property Type string getName() Returns the name of a property Inherited From: Property#getName Source: lib/parser/property.js, line 102 Returns: the name of this field Type string getNamespace() Returns the namespace of the parent of this property Inherited From: Property#getNamespace Source: lib/parser/property.js, line 153 Returns: the namespace of the parent of this property Type string getParent() Returns the owner of this property Inherited From: Property#getParent Source: lib/parser/property.js, line 49 Returns: the parent class declaration Type ClassDeclaration getType() Returns the type of a property Inherited From: Property#getType Source: lib/parser/property.js, line 110 Returns: the type of this field Type string getValidator() Returns the validator string for this field Source: lib/parser/field.js, line 59 Returns: the validator for the field or null Type string isArray() Returns true if the field is declared as an array type Inherited From: Property#isArray Source: lib/parser/property.js, line 161 Returns: true if the property is an array type Type boolean isOptional() Returns true if the field is optional Inherited From: Property#isOptional Source: lib/parser/property.js, line 118 Returns: true if the field is optional Type boolean isPrimitive() Returns true if this property is a primitive type. Inherited From: Property#isPrimitive Source: lib/parser/property.js, line 184 Returns: true if the property is a primitive type. Type boolean isTypeEnum() Returns true if the field is declared as an enumerated value Inherited From: Property#isTypeEnum Source: lib/parser/property.js, line 170 Returns: true if the property is an enumerated value Type boolean &lt;private&gt; process() Process the AST and build the model Overrides: Property#process Source: lib/parser/field.js, line 39 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Overrides: Property#toJSON Source: lib/parser/field.js, line 81 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns a string representation of this propertyÂ§ Source: lib/parser/field.js, line 93 Returns: the string version of the property. Type String &lt;private&gt; validate(classDecl) Validate the property Parameters: Name Type Description classDecl ClassDeclaration the class declaration of the property Inherited From: Property#validate Source: lib/parser/property.js, line 91 Throws: InvalidModelException Ã— Search results Close "},"FileWriter.html":{"id":"FileWriter.html","title":"Class: FileWriter","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: FileWriter FileWriter FileWriter creates text files under a directory tree. It can be used by code generators to create source files for example. Basic usage is: openFile(fileName), writeLine(...), closeFile(). &lt;private&gt; new FileWriter(outputDirectory) Create a FileWriter. Parameters: Name Type Description outputDirectory string the path to an output directory that will be used to store generated files. Source: lib/codegen/filewriter.js, line 24 Methods closeFile() Closes the current open file Source: lib/codegen/filewriter.js, line 92 openFile(fileName) Opens a file for writing. The file will be created in the root directory of this FileWriter. Parameters: Name Type Description fileName string the name of the file to open Source: lib/codegen/filewriter.js, line 46 openRelativeFile(relativeDir, fileName) Opens a file for writing, with a location relative to the root directory of this FileWriter. Parameters: Name Type Description relativeDir string the relative directory to use fileName string the name of the file to open Source: lib/codegen/filewriter.js, line 58 writeBeforeLine(tabs, text) Writes text to the start of the current open file Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/filewriter.js, line 81 writeLine(tabs, text) Writes text to the current open file Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/filewriter.js, line 68 Ã— Search results Close "},"FunctionDeclaration.html":{"id":"FunctionDeclaration.html","title":"Class: FunctionDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: FunctionDeclaration FunctionDeclaration FunctionDeclaration defines a function that has been defined in a model file. If the name of the function starts with 'on' then the name of the function denotes the name of a transaction declaration that the function processes. &lt;private&gt; new FunctionDeclaration(modelFile, ast) Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the result of parsing. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast string the AST created by the parser Source: lib/parser/functiondeclaration.js, line 24 Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/parser/functiondeclaration.js, line 51 Returns: the result of visiting or null Type Object getFullyQualifiedName() Returns the fully qualified name of this function. The name will include the namespace if present. Source: lib/parser/functiondeclaration.js, line 159 Returns: the fully-qualified name of this function Type string getFunctionText() Returns the text of this function. Source: lib/parser/functiondeclaration.js, line 69 Returns: the text that defines the function Type string getModelFile() Returns the ModelFile that defines this class. Source: lib/parser/functiondeclaration.js, line 60 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of the function (not including namespace). Source: lib/parser/functiondeclaration.js, line 123 Returns: the name of the function. Type string getParameters() Returns the names of the parameters processed by the function. Source: lib/parser/functiondeclaration.js, line 149 Returns: the names of the parameters. Type Array.&lt;string&gt; getTransactionDeclarationName() Returns the short name of the transaction declaration that is being processed. This is calculated by removing the 'on' prefix from the function name. If the function name does not start with 'on' then null Source: lib/parser/functiondeclaration.js, line 135 Returns: the name of the transaction declaration. Type string &lt;private&gt; process() Process the AST and build the model Source: lib/parser/functiondeclaration.js, line 79 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Source: lib/parser/functiondeclaration.js, line 168 Returns: A new object suitable for serializing as JSON. Type Object &lt;private&gt; validate() Semantic validation of the structure of this function. Source: lib/parser/functiondeclaration.js, line 95 Throws: InvalidModelException Ã— Search results Close "},"GoLangVisitor.html":{"id":"GoLangVisitor.html","title":"Class: GoLangVisitor","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: GoLangVisitor GoLangVisitor Convert the contents of a ModelManager to Go Lang code. All generated code is placed into the 'main' package. Set a fileWriter property (instance of FileWriter) on the parameters object to control where the generated code is written to disk. &lt;private&gt; new GoLangVisitor() Source: lib/codegen/golang/golangvisitor.js, line 33 Methods &lt;private&gt; containsDateTimeField(modelFile) Returns true if the ModelFile contains a class that has a DateTime field. Parameters: Name Type Description modelFile ModelFile the modelFile Source: lib/codegen/golang/golangvisitor.js, line 234 Returns: true if the modelFile contains a class that contains a field of type DateTime. Type boolean &lt;private&gt; toGoPackageName(namespace) Converts a Concerto namespace to a Go package name. Parameters: Name Type Description namespace string the concerto type Source: lib/codegen/golang/golangvisitor.js, line 281 Returns: the corresponding package name in Go Lang Type string &lt;private&gt; toGoType(type) Converts a Concerto type to a Go Lang type. Primitive types are converted everything else is passed through unchanged. Parameters: Name Type Description type string the concerto type Source: lib/codegen/golang/golangvisitor.js, line 256 Returns: the corresponding type in Go Lang Type string &lt;private&gt; visit(thing, parameters) Visitor design pattern Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 41 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 148 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumDeclaration(enumDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumDeclaration EnumDeclaration the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 126 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumValueDeclaration(enumValueDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumValueDeclaration EnumValueDeclaration the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 191 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 172 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelFile(modelFile, parameters) Visitor design pattern Parameters: Name Type Description modelFile ModelFile the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 98 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelManager(modelManager, parameters) Visitor design pattern Parameters: Name Type Description modelManager ModelManager the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 70 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationship(relationship, parameters) Visitor design pattern Parameters: Name Type Description relationship Relationship the object being visited parameters Object the parameter Source: lib/codegen/golang/golangvisitor.js, line 214 Returns: the result of visiting or null Type Object Ã— Search results Close "},"Identifiable.html":{"id":"Identifiable.html","title":"Class: Identifiable","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Identifiable Identifiable Identifiable is an entity with a namespace, type and an identifier. This class is abstract. &lt;abstract&gt; new Identifiable(modelManager, ns, type, id) Create an instance. Note: Only to be called by framework code. Applications should retrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/identifiable.js, line 21 Methods &lt;private, static&gt; isSystemProperty(name) Returns true if the property is a system property. Parameters: Name Type Description name string the name of the property Source: lib/model/identifiable.js, line 118 Returns: true if the property is a system property Type boolean &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/model/identifiable.js, line 49 Returns: the result of visiting or null Type Object getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance. (namespace '.' type '#' identifier). Source: lib/model/identifiable.js, line 75 Returns: the fully qualified identifier of this instance Type string getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Source: lib/model/identifiable.js, line 91 Returns: The fully-qualified type name of this object Type string getIdentifier() Get the identifier of this instance Source: lib/model/identifiable.js, line 66 Returns: The identifier for this object Type string &lt;private&gt; getModelManager() Get the ModelManager for this instance Source: lib/model/identifiable.js, line 58 Returns: The ModelManager for this object Type ModelManager getNamespace() Get the namespace of the instance. Source: lib/model/identifiable.js, line 99 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Source: lib/model/identifiable.js, line 83 Returns: The type of this object Type string toString() Returns the string representation of this class Source: lib/model/identifiable.js, line 107 Returns: the string representation of the class Type String Ã— Search results Close "},"IllegalModelException.html":{"id":"IllegalModelException.html","title":"Class: IllegalModelException","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: IllegalModelException IllegalModelException Exception throws when a Concerto file is semantically invalid new IllegalModelException(message) Create an IllegalModelException Parameters: Name Type Description message string the message for the exception Source: lib/parser/illegalmodelexception.js, line 18 Ã— Search results Close "},"JSONGenerator.html":{"id":"JSONGenerator.html","title":"Class: JSONGenerator","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: JSONGenerator JSONGenerator Converts the contents of a Resource to JSON. The parameters object should contain the keys 'writer' - the JSONWriter instance to use to accumulate the JSON text. 'stack' - the TypedStack of objects being processed. It should start with a Resource. 'modelManager' - the ModelManager to use. &lt;private&gt; new JSONGenerator() Source: lib/serializer/jsongenerator.js, line 32 Methods convertToJSON(field, obj) Converts a primtive object to JSON text. Parameters: Name Type Description field Field the field declaration of the object obj Object the object to convert to text Source: lib/serializer/jsongenerator.js, line 128 Returns: the text representation Type string getRelationshipText(relationshipDeclaration, relationship) Returns the persistent format for a relationship. Parameters: Name Type Description relationshipDeclaration RelationshipDeclaration the relationship being persisted relationship Relationship the text for the item Source: lib/serializer/jsongenerator.js, line 207 Returns: the text to use to persist the relationship Type string &lt;private&gt; visit(thing, parameters) Visitor design pattern Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 40 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 63 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumDeclaration(enumDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumDeclaration EnumDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 156 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumValueDeclaration(enumValueDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumValueDeclaration EnumDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 169 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 89 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationshipDeclaration(relationshipDeclaration, parameters) Visitor design pattern Parameters: Name Type Description relationshipDeclaration RelationshipDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsongenerator.js, line 180 Returns: the result of visiting or null Type Object Ã— Search results Close "},"JSONPopulator.html":{"id":"JSONPopulator.html","title":"Class: JSONPopulator","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: JSONPopulator JSONPopulator Populates a Resource with data from a JSON object graph. The JSON objects should be the result of calling Serializer.toJSON and then JSON.parse. The parameters object should contain the keys 'stack' - the TypedStack of objects being processed. It should start with the root object from JSON.parse. 'factory' - the Factory instance to use for creating objects. 'modelManager' - the ModelManager instance to use to resolve classes &lt;private&gt; new JSONPopulator() Source: lib/serializer/jsonpopulator.js, line 29 Methods convertItem(field, jsonItem, parameters) Parameters: Name Type Description field Field the field of the item being converted jsonItem Object the JSON object of the item being converted parameters Object the parameters Source: lib/serializer/jsonpopulator.js, line 105 Returns: - the populated object. Type Object convertToObject(field, json) Converts a primtive object to JSON text. Parameters: Name Type Description field Field the field declaration of the object json Object the JSON object to convert to a Concerto Object Source: lib/serializer/jsonpopulator.js, line 141 Returns: the text representation Type string &lt;private&gt; visit(thing, parameters) Visitor design pattern Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/serializer/jsonpopulator.js, line 37 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsonpopulator.js, line 56 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/serializer/jsonpopulator.js, line 79 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationshipDeclaration(relationshipDeclaration, parameters) Visitor design pattern Parameters: Name Type Description relationshipDeclaration RelationshipDeclaration the object being visited parameters Object the parameter Source: lib/serializer/jsonpopulator.js, line 176 Returns: the result of visiting or null Type Object Ã— Search results Close "},"JSONWriter.html":{"id":"JSONWriter.html","title":"Class: JSONWriter","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: JSONWriter JSONWriter JSONWriter manages a text buffer for writing JSON data structures. It tracks when a comma is needed to separate items. Commas are inserted automatically based on context. &lt;private&gt; new JSONWriter() Create a JSONWriter. Source: lib/codegen/jsonwriter.js, line 21 Methods closeArray() Closes the current array Source: lib/codegen/jsonwriter.js, line 163 closeObject() Close the current object declaration. Source: lib/codegen/jsonwriter.js, line 47 log(callSite, message) Parameters: Name Type Description callSite String the location message String the message to log. Source: lib/codegen/jsonwriter.js, line 181 openArray() Opens a new array Source: lib/codegen/jsonwriter.js, line 153 openObject(key) Opens an object declaration Parameters: Name Type Description key string the key Source: lib/codegen/jsonwriter.js, line 37 toString() Source: lib/codegen/jsonwriter.js, line 173 Returns: a string represention of this class Type String writeArrayStringValue(value) Writes an array value, in the format '&quot;value&quot;' Parameters: Name Type Description value string the value Source: lib/codegen/jsonwriter.js, line 131 writeArrayValue(value) Writes an array value, in the format 'value' Parameters: Name Type Description value string the value Source: lib/codegen/jsonwriter.js, line 143 writeComma() Writes a comma when this.firstItem === false Source: lib/codegen/jsonwriter.js, line 68 writeKey(key) Writes a key, in the format '&quot;key&quot; : ' Parameters: Name Type Description key string the key Source: lib/codegen/jsonwriter.js, line 59 writeKeyStringValue(key, value) Writes a key/value, in the format: '&quot;key&quot; : &quot;value&quot;' Parameters: Name Type Description key string the key value string the value Source: lib/codegen/jsonwriter.js, line 106 writeKeyValue(key, value) Writes a key/value, in the format: '&quot;key&quot; : value' Parameters: Name Type Description key string the key value string the value Source: lib/codegen/jsonwriter.js, line 119 writeStringValue(value) Writes a value, in the format: '&quot;value&quot;' Parameters: Name Type Description value string the value Source: lib/codegen/jsonwriter.js, line 83 writeValue(value) Writes a value, in the format: 'value' Parameters: Name Type Description value string the value Source: lib/codegen/jsonwriter.js, line 94 Ã— Search results Close "},"ModelFile.html":{"id":"ModelFile.html","title":"Class: ModelFile","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ModelFile ModelFile Class representing a Model File. A Model File contains a single namespace and a set of model elements: assets, transactions etc. &lt;private&gt; new ModelFile(modelManager, definitions) Create a ModelFile. This should only be called by framework code. Use the ModelManager to manage ModelFiles. Parameters: Name Type Description modelManager ModelManager the ModelManager that manages this ModelFile definitions string The DSL model as a string. Source: lib/parser/modelfile.js, line 29 Methods &lt;static&gt; fromJSON(modelManager, json) Convert the specified JSON into an instance of a model file. Parameters: Name Type Description modelManager ModelManager the ModelManager that manages this ModelFile json string A serialized instance of a ModelFile. Source: lib/parser/modelfile.js, line 38 Returns: An instance of a model file. Type ModelFile &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/parser/modelfile.js, line 116 Returns: the result of visiting or null Type Object getAllDeclarations() Get all declarations in this ModelFile Source: lib/parser/modelfile.js, line 449 Returns: the ClassDeclarations defined in the model file Type Array.&lt;ClassDeclaration&gt; getAssetDeclaration(name) Get the AssetDeclarations defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 351 Returns: the AssetDeclaration with the given short name Type AssetDeclaration getAssetDeclarations() Get the AssetDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 401 Returns: the AssetDeclarations defined in the model file Type Array.&lt;AssetDeclaration&gt; getDeclarations(type) Get the instances of a given type in this ModelFile Parameters: Name Type Description type function the type of the declaration Source: lib/parser/modelfile.js, line 434 Returns: the ClassDeclaration defined in the model file Type Array.&lt;ClassDeclaration&gt; getDefinitions() Get the definitions for this model. Source: lib/parser/modelfile.js, line 457 Returns: The definitions for this model. Type string getEnumDeclarations() Get the EnumDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 425 Returns: the EnumDeclaration defined in the model file Type Array.&lt;EnumDeclaration&gt; &lt;private&gt; getFullyQualifiedTypeName(type) Returns the FQN of the type or null if the type could not be resolved. For primitive types the short type name is returned. Parameters: Name Type Description type string a FQN or short type name Source: lib/parser/modelfile.js, line 301 Returns: the FQN type name or null Type string getFunctions() Returns the FunctionDeclaration for all functions that have been defined in this ModelFile. Source: lib/parser/modelfile.js, line 144 Returns: The array of FunctionDeclarations Type Array.&lt;FunctionDeclaration&gt; getImports() Returns the types that have been imported into this ModelFile. Source: lib/parser/modelfile.js, line 134 Returns: The array of imports for this ModelFile Type Array.&lt;string&gt; getLocalType(type) Returns the type with the specified name or null Parameters: Name Type Description type string the short OR FQN name of the type Source: lib/parser/modelfile.js, line 332 Returns: the ClassDeclaration, or null if the type does not exist Type ClassDeclaration getModelManager() Returns the ModelManager associated with this ModelFile Source: lib/parser/modelfile.js, line 125 Returns: The ModelManager for this ModelFile Type ModelManager getNamespace() Get the Namespace for this model file. Source: lib/parser/modelfile.js, line 393 Returns: The Namespace for this model file Type string getParticipantDeclaration(name) Get the ParticipantDeclaration defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 379 Returns: the ParticipantDeclaration with the given short name Type ParticipantDeclaration getParticipantDeclarations() Get the ParticipantDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 417 Returns: the ParticipantDeclaration defined in the model file Type Array.&lt;ParticipantDeclaration&gt; getTransactionDeclaration(name) Get the TransactionDeclaration defined in this ModelFile or null Parameters: Name Type Description name string the name of the type Source: lib/parser/modelfile.js, line 365 Returns: the TransactionDeclaration with the given short name Type TransactionDeclaration getTransactionDeclarations() Get the TransactionDeclarations defined in this ModelFile Source: lib/parser/modelfile.js, line 409 Returns: the TransactionDeclarations defined in the model file Type Array.&lt;TransactionDeclaration&gt; &lt;private&gt; getType(type) Returns the FQN of the type or null if the type could not be resolved. For primitive types the type name is returned. Parameters: Name Type Description type string a FQN or short type name Source: lib/parser/modelfile.js, line 264 Returns: the class declaration for the type or null. Type string | ClassDeclaration isDefined(type) Returns true if the type is defined in the model file Parameters: Name Type Description type string the name of the type Source: lib/parser/modelfile.js, line 253 Returns: true if the type (asset or transaction) is defined Type boolean &lt;private&gt; isImportedType(type) Returns true if the type is imported from another namespace Parameters: Name Type Description type string the short name of the type Source: lib/parser/modelfile.js, line 212 Returns: - true if the type is imported from another namespace Type boolean &lt;private&gt; isLocalType(type) Returns true if the type is defined in this namespace. Parameters: Name Type Description type string the short name of the type Source: lib/parser/modelfile.js, line 200 Returns: - true if the type is defined in this ModelFile Type boolean &lt;private&gt; resolveImport(type) Returns the FQN for a type that is imported from another namespace Parameters: Name Type Description type string the short name of the type Source: lib/parser/modelfile.js, line 230 Throws: - if the type is not imported Type Error Returns: - the FQN of the resolved import Type string &lt;private&gt; resolveType(context, type) Check that the type is valid. Parameters: Name Type Description context string error reporting context type string a short type name Source: lib/parser/modelfile.js, line 173 Throws: - if the type is not defined Type IllegalModelException toJSON() Convert this model file into an object that is suitable for converting into a JSON string for serialization purposes. Source: lib/parser/modelfile.js, line 466 Returns: An object suitable for converting into a JSON string. Type Object &lt;private&gt; validate() Validates the ModelFile. Source: lib/parser/modelfile.js, line 154 Throws: if the model is invalid Type IllegalModelException Ã— Search results Close "},"ModelManager.html":{"id":"ModelManager.html","title":"Class: ModelManager","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ModelManager ModelManager The structure of Resources (Assets, Transactions, Participants) is modelled in a set of Concerto files. The contents of these files are managed by the ModelManager. Each Concerto file has a single namespace and contains a set of asset, transaction and participant type definitions. Concerto applications load their Concerto files and then call the addModelFile method to register the Concerto file(s) with the ModelManager. The ModelManager parses the text of the Concerto file and will make all defined types available to other Concerto services, such as the Serializer (to convert instances to/from JSON) and Factory (to create instances). new ModelManager() Create the ModelManager. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Source: lib/modelmanager.js, line 34 Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/modelmanager.js, line 53 Returns: the result of visiting or null Type Object addModelFile(modelFile) Adds a Concerto file (as a string) to the ModelManager. Concerto files have a single namespace. If a Concerto file with the same namespace has already been added to the ModelManager then it will be replaced. Note that if there are dependencies between multiple files the files must be added in dependency order, or the addModelFiles method can be used to add a set of files irrespective of dependencies. Parameters: Name Type Description modelFile string The Concerto file as a string Source: lib/modelmanager.js, line 69 Throws: InvalidModelException Returns: The newly added model file (internal). Type Object addModelFiles(modelFiles) Add a set of Concerto files to the model manager. Parameters: Name Type Description modelFiles Array.&lt;string&gt; An array of Concerto files as strings. Source: lib/modelmanager.js, line 128 Returns: The newly added model files (internal). Type Array.&lt;Object&gt; clearModelFiles() Remove all registered Concerto files Source: lib/modelmanager.js, line 220 deleteModelFile(namespace) Remove the Concerto file for a given namespace Parameters: Name Type Description namespace string The namespace of the model file to delete. Source: lib/modelmanager.js, line 115 &lt;private&gt; getModelFile(namespace) Get the ModelFile associated with a namespace Parameters: Name Type Description namespace string the namespace containing the ModelFile Source: lib/modelmanager.js, line 230 Returns: registered ModelFile for the namespace or null Type ModelFile &lt;private&gt; getModelFiles() Get the array of model file instances Source: lib/modelmanager.js, line 166 Returns: The ModelFiles registered Type Array.&lt;ModelFile&gt; getNamespaces() Get the namespaces registered with the ModelManager. Source: lib/modelmanager.js, line 238 Returns: namespaces - the namespaces that have been registered. Type Array.&lt;string&gt; &lt;private&gt; getType(type) Look up a type in all registered namespaces. Parameters: Name Type Description type string the fully qualified name of a type Source: lib/modelmanager.js, line 250 Throws: - if the type cannot be found Type Error Returns: - the class declaration or null for primitive types Type ClassDeclaration &lt;private&gt; resolveType(context, type) Check that the type is valid and returns the FQN of the type. Parameters: Name Type Description context string error reporting context type string a short type name Source: lib/modelmanager.js, line 185 Throws: - if the type is not defined Type IllegalModelException Returns: - the resolved type name (fully qualified) Type string updateModelFile(modelFile) Updates a Concerto file (as a string) on the ModelManager. Concerto files have a single namespace. If a Concerto file with the same namespace has already been added to the ModelManager then it will be replaced. Parameters: Name Type Description modelFile string The Concerto file as a string Source: lib/modelmanager.js, line 91 Throws: InvalidModelException Returns: The newly added model file (internal). Type Object Ã— Search results Close "},"ModelRegistry.html":{"id":"ModelRegistry.html","title":"Class: ModelRegistry","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ModelRegistry ModelRegistry The ModelRegistry is used to manage a set of models. &lt;private&gt; new ModelRegistry(id, name, modelManager) Create an model registry. Parameters: Name Type Description id string The unique identifier of the model registry. name string The display name for the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 25 Extends Registry Methods &lt;protected, static&gt; addModelRegistry(securityContext, id, name, modelManager) Add a new model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model registry. name string The name of the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 83 Returns: A promise that will be resolved with a ModelRegistry instance representing the new model registry. Type Promise &lt;protected, static&gt; getAllModelRegistries(securityContext, modelManager) Get a list of all existing model registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this asset registry. Source: lib/modelregistry.js, line 36 Returns: A promise that will be resolved with a list of ModelRegistry instances representing the asset registries. Type Promise &lt;protected, static&gt; getModelRegistry(securityContext, id, modelManager) Get an existing model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model registry. modelManager ModelManager The ModelManager to use for this model registry. Source: lib/modelregistry.js, line 59 Returns: A promise that will be resolved with a ModelRegistry instance representing the model registry. Type Promise add(securityContext, model) Adds a model to the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile The model to be added to the model registry. Overrides: Registry#add Source: lib/modelregistry.js, line 122 Returns: A promise that is resolved when the model is added to the model registry. Type Promise get(securityContext, id) Get a specific model in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the model. Overrides: Registry#get Source: lib/modelregistry.js, line 185 Returns: A promise that will be resolved with a ModelFile instance representing the model. Type Promise getAll(securityContext) Get all of the models in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Overrides: Registry#getAll Source: lib/modelregistry.js, line 166 Returns: A promise that will be resolved with an array of ModelFile instances representing the models. Type Promise remove(securityContext, model) Remove an model with a given type and id from the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile | string The model, or the unique identifier of the model. Overrides: Registry#remove Source: lib/modelregistry.js, line 148 Returns: A promise that is resolved when the element is removed from the registry. Type Promise update(securityContext, model) Updates an model in the model registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. model ModelFile The model to be updated in the model registry. Overrides: Registry#update Source: lib/modelregistry.js, line 135 Returns: A promise that is resolved when the model is updated in the model registry. Type Promise Ã— Search results Close "},"ModelUtil.html":{"id":"ModelUtil.html","title":"Class: ModelUtil","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ModelUtil ModelUtil Internal Model Utility Class &lt;private&gt; new ModelUtil() Source: lib/modelutil.js, line 20 Methods &lt;private, static&gt; capitalizeFirstLetter(string) Returns the passed string with the first character capitalized Parameters: Name Type Description string string the string Source: lib/modelutil.js, line 133 Returns: the string with the first letter capitalized Type string &lt;private, static&gt; getNamespace(fqn) Returns the namespace for a the fully qualified name of a type Parameters: Name Type Description fqn string the fully qualified identifier of a type Source: lib/modelutil.js, line 47 Returns: - namespace of the type (everything before the last dot) or the empty string if there is no dot Type string &lt;private, static&gt; getShortName(fqn) Returns everything after the last dot, if present, of the source string Parameters: Name Type Description fqn string the source string Source: lib/modelutil.js, line 28 Returns: - the string after the last dot Type string &lt;private, static&gt; isAssignableTo(modelFile, type, property) Returns true if the type is assignable to the propertyType. Parameters: Name Type Description modelFile ModelFile the ModelFile that owns the Property type string the FQN of the type we are trying to assign property Property the property that we'd like to store the type in. Source: lib/modelutil.js, line 82 Returns: - true if the type can be assigned to the property Type boolean &lt;private, static&gt; isEnum(field) Returns the passed string with the first character capitalized Parameters: Name Type Description field Field the string Source: lib/modelutil.js, line 143 Returns: the string with the first letter capitalized Type boolean &lt;private, static&gt; isPrimitiveType(type) Returns true if the type is a primitive type Parameters: Name Type Description type string the name of the type Source: lib/modelutil.js, line 67 Returns: - true if the type is a primitive Type boolean Ã— Search results Close "},"module-ibm-concerto.html":{"id":"module-ibm-concerto.html","title":"Module: ibm-concerto","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Module: ibm-concerto IBM Concerto module. IBM Concerto is a framework for creating blockchain backed digital networks and exchanging assets between participants via processing transactions. Applications interact with the framework by instantiating the Concerto class. Source: index.js, line 13 Ã— Search results Close "},"ParseException.html":{"id":"ParseException.html","title":"Class: ParseException","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ParseException ParseException Exception throws when a Concerto file is syntactically invalid new ParseException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: lib/parser/parseexception.js, line 18 Ã— Search results Close "},"ParticipantDeclaration.html":{"id":"ParticipantDeclaration.html","title":"Class: ParticipantDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ParticipantDeclaration ParticipantDeclaration Class representing the definition of a Participant. &lt;private&gt; new ParticipantDeclaration(modelFile, ast) Create an ParticipantDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/participantdeclaration.js, line 19 Extends ClassDeclaration Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: ClassDeclaration#accept Source: lib/parser/classdeclaration.js, line 57 Returns: the result of visiting or null Type Object getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Inherited From: ClassDeclaration#getFullyQualifiedName Source: lib/parser/classdeclaration.js, line 229 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Inherited From: ClassDeclaration#getIdentifierFieldName Source: lib/parser/classdeclaration.js, line 239 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Inherited From: ClassDeclaration#getModelFile Source: lib/parser/classdeclaration.js, line 66 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Inherited From: ClassDeclaration#getName Source: lib/parser/classdeclaration.js, line 219 Returns: the short name of this class Type string getOwnProperties() Returns the fields directly defined by this class. Inherited From: ClassDeclaration#getOwnProperties Source: lib/parser/classdeclaration.js, line 274 Returns: the array of fields Type Array.&lt;Property&gt; getOwnProperty(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getOwnProperty Source: lib/parser/classdeclaration.js, line 258 Returns: the field definition or null if it does not exist. Type Property getProperties() Returns the properties defined in this class and all super classes. Inherited From: ClassDeclaration#getProperties Source: lib/parser/classdeclaration.js, line 328 Returns: the array of fields Type Array.&lt;Property&gt; getProperty(name) Returns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getProperty Source: lib/parser/classdeclaration.js, line 305 Returns: the field, or null if it does not exist Type Property getSuperType() Returns the FQN of the super type for this class or null if this class does not have a super type. Inherited From: ClassDeclaration#getSuperType Source: lib/parser/classdeclaration.js, line 284 Returns: the FQN name of the super type or null Type string isAbstract() Returns true if this class is declared as abstract in the model file Inherited From: ClassDeclaration#isAbstract Source: lib/parser/classdeclaration.js, line 200 Returns: true if the class is abstract Type boolean isEnum() Returns true if this class is an enumeration. Inherited From: ClassDeclaration#isEnum Source: lib/parser/classdeclaration.js, line 209 Returns: true if the class is an enumerated type Type boolean &lt;private&gt; process() Process the AST and build the model Inherited From: ClassDeclaration#process Source: lib/parser/classdeclaration.js, line 76 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Inherited From: ClassDeclaration#toJSON Source: lib/parser/classdeclaration.js, line 359 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns the string representation of this class Inherited From: ClassDeclaration#toString Source: lib/parser/classdeclaration.js, line 382 Returns: the string representation of the class Type String &lt;private&gt; validate() Semantic validation of the structure of this class. Subclasses should override this method to impose additional semantic constraints on the contents/relations of fields. Inherited From: ClassDeclaration#validate Source: lib/parser/classdeclaration.js, line 126 Throws: InvalidModelException Ã— Search results Close "},"PlantUMLVisitor.html":{"id":"PlantUMLVisitor.html","title":"Class: PlantUMLVisitor","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: PlantUMLVisitor PlantUMLVisitor Convert the contents of a ModelManager to PlantUML format files. Set a fileWriter property (instance of FileWriter) on the parameters object to control where the generated code is written to disk. &lt;private&gt; new PlantUMLVisitor() Source: lib/codegen/plantuml/plantumlvisitor.js, line 35 Methods &lt;private&gt; visit(thing, parameters) Visitor design pattern Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 43 Returns: the result of visiting or null Type Object &lt;private&gt; visitAssetDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 133 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 230 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 157 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumValueDeclaration(enumValueDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumValueDeclaration EnumValueDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 284 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 254 Returns: the result of visiting or null Type Object &lt;private&gt; visitFunctionDeclaration(functionDeclaration, parameters) Visitor design pattern Parameters: Name Type Description functionDeclaration FunctionDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 272 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelFile(modelFile, parameters) Visitor design pattern Parameters: Name Type Description modelFile ModelFile the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 100 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelManager(modelManager, parameters) Visitor design pattern Parameters: Name Type Description modelManager ModelManager the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 78 Returns: the result of visiting or null Type Object &lt;private&gt; visitParticipantDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 181 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationship(relationship, parameters) Visitor design pattern Parameters: Name Type Description relationship Relationship the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 296 Returns: the result of visiting or null Type Object &lt;private&gt; visitTransactionDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/plantuml/plantumlvisitor.js, line 205 Returns: the result of visiting or null Type Object Ã— Search results Close "},"Property.html":{"id":"Property.html","title":"Class: Property","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Property Property Property representing an attribute of a class declaration, either a Field or a Relationship. &lt;private&gt; new Property(parent, ast) Create a Property. Parameters: Name Type Description parent ClassDeclaration the owner of this property ast Object The AST created by the parser Source: lib/parser/property.js, line 20 Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Source: lib/parser/property.js, line 41 Returns: the result of visiting or null Type Object getFullyQualifiedTypeName() Returns the fully qualified type name of a property Source: lib/parser/property.js, line 126 Returns: the fully qualified type of this property Type string getName() Returns the name of a property Source: lib/parser/property.js, line 102 Returns: the name of this field Type string getNamespace() Returns the namespace of the parent of this property Source: lib/parser/property.js, line 153 Returns: the namespace of the parent of this property Type string getParent() Returns the owner of this property Source: lib/parser/property.js, line 49 Returns: the parent class declaration Type ClassDeclaration getType() Returns the type of a property Source: lib/parser/property.js, line 110 Returns: the type of this field Type string isArray() Returns true if the field is declared as an array type Source: lib/parser/property.js, line 161 Returns: true if the property is an array type Type boolean isOptional() Returns true if the field is optional Source: lib/parser/property.js, line 118 Returns: true if the field is optional Type boolean isPrimitive() Returns true if this property is a primitive type. Source: lib/parser/property.js, line 184 Returns: true if the property is a primitive type. Type boolean isTypeEnum() Returns true if the field is declared as an enumerated value Source: lib/parser/property.js, line 170 Returns: true if the property is an enumerated value Type boolean &lt;private&gt; process() Process the AST and build the model Source: lib/parser/property.js, line 58 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Source: lib/parser/property.js, line 193 Returns: A new object suitable for serializing as JSON. Type Object &lt;private&gt; validate(classDecl) Validate the property Parameters: Name Type Description classDecl ClassDeclaration the class declaration of the property Source: lib/parser/property.js, line 91 Throws: InvalidModelException Ã— Search results Close "},"Registry.html":{"id":"Registry.html","title":"Class: Registry","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Registry Registry Class representing an Abstract Registry. &lt;abstract&gt; new Registry(registryType, id, name) Create a registry. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Parameters: Name Type Description registryType string The type of this registry. id string The unique identifier of the registry. name string The display name for the registry. Source: lib/registry.js, line 20 Methods &lt;protected, static&gt; addRegistry(securityContext, registryType, id, name) Add a new asset registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. id string The unique identifier of the registry. name string The name of the registry. Source: lib/registry.js, line 76 Returns: A promise that will be resolved with a JSON object representing the registry. Type Promise &lt;protected, static&gt; getAllRegistries(securityContext, registryType) Get a list of all existing registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. Source: lib/registry.js, line 31 Returns: A promise that will be resolved with an array of JSON objects representing the registries. Type Promise &lt;protected, static&gt; getRegistry(securityContext, registryType, id) Get an existing registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. registryType string The type of this registry. id string The unique identifier of the registry. Source: lib/registry.js, line 52 Returns: A promise that will be resolved with a JSON object representing the registry. Type Promise &lt;protected&gt; add(securityContext, id, data [, functionName]) Adds a new resource to the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. functionName string &lt;optional&gt; The optional chain-code function name to call. Source: lib/registry.js, line 130 Returns: A promise that will be resolved when the resource is added to the registry. Type Promise &lt;protected&gt; get(securityContext, id [, options]) Get a specific resource in the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. options Object &lt;optional&gt; An optional set of options for the query. Properties Name Type Argument Description resolve boolean &lt;optional&gt; Resolve all of the assets relationships. Source: lib/registry.js, line 212 Returns: A promise that will be resolved with a JSON object representing the resource. Type Promise &lt;protected&gt; getAll(securityContext [, options]) Get all of the resources in the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. options Object &lt;optional&gt; An optional set of options for the query. Properties Name Type Argument Description resolve boolean &lt;optional&gt; Resolve all of the assets relationships. Source: lib/registry.js, line 189 Returns: A promise that will be resolved with an array of JSON objects representing the resources. Type Promise &lt;protected&gt; remove(securityContext, id [, functionName]) Remove an asset with a given type and id from the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. functionName string &lt;optional&gt; The optional chain-code function name to call. Source: lib/registry.js, line 171 Returns: A promise that will be resolved when the resource is removed from the registry. Type Promise &lt;protected&gt; update(securityContext, id, data [, functionName]) Updates a resource in the registry. Parameters: Name Type Argument Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. functionName string &lt;optional&gt; The optional chain-code function name to call. Source: lib/registry.js, line 151 Returns: A promise that will be resolved when the resource is updated in the registry. Type Promise Ã— Search results Close "},"Relationship.html":{"id":"Relationship.html","title":"Class: Relationship","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Relationship Relationship A Relationship is a typed pointer to an instance. I.e the relationship with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates a pointer that points at an instance of org.acme.Vehicle with the id ABC. new Relationship(modelManager, ns, type, id) Create an asset. Use the Factory to create instances. Note: Only to be called by framework code. Applications should retrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/relationship.js, line 22 Extends Identifiable Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: Identifiable#accept Source: lib/model/identifiable.js, line 49 Returns: the result of visiting or null Type Object getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance. (namespace '.' type '#' identifier). Inherited From: Identifiable#getFullyQualifiedIdentifier Source: lib/model/identifiable.js, line 75 Returns: the fully qualified identifier of this instance Type string getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Inherited From: Identifiable#getFullyQualifiedType Source: lib/model/identifiable.js, line 91 Returns: The fully-qualified type name of this object Type string getIdentifier() Get the identifier of this instance Inherited From: Identifiable#getIdentifier Source: lib/model/identifiable.js, line 66 Returns: The identifier for this object Type string &lt;private&gt; getModelManager() Get the ModelManager for this instance Inherited From: Identifiable#getModelManager Source: lib/model/identifiable.js, line 58 Returns: The ModelManager for this object Type ModelManager getNamespace() Get the namespace of the instance. Inherited From: Identifiable#getNamespace Source: lib/model/identifiable.js, line 99 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Inherited From: Identifiable#getType Source: lib/model/identifiable.js, line 83 Returns: The type of this object Type string toString() Returns the string representation of this class Overrides: Identifiable#toString Source: lib/model/relationship.js, line 46 Returns: the string representation of the class Type String Ã— Search results Close "},"RelationshipDeclaration.html":{"id":"RelationshipDeclaration.html","title":"Class: RelationshipDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: RelationshipDeclaration RelationshipDeclaration Class representing a relationship between model elements &lt;private&gt; new RelationshipDeclaration(parent, ast) Create a Relationship. Parameters: Name Type Description parent ClassDeclaration The owner of this property ast Object The AST created by the parser Source: lib/parser/relationshipdeclaration.js, line 22 Extends Property Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: Property#accept Source: lib/parser/property.js, line 41 Returns: the result of visiting or null Type Object getFullyQualifiedTypeName() Returns the fully qualified type name of a property Inherited From: Property#getFullyQualifiedTypeName Source: lib/parser/property.js, line 126 Returns: the fully qualified type of this property Type string getName() Returns the name of a property Inherited From: Property#getName Source: lib/parser/property.js, line 102 Returns: the name of this field Type string getNamespace() Returns the namespace of the parent of this property Inherited From: Property#getNamespace Source: lib/parser/property.js, line 153 Returns: the namespace of the parent of this property Type string getParent() Returns the owner of this property Inherited From: Property#getParent Source: lib/parser/property.js, line 49 Returns: the parent class declaration Type ClassDeclaration getType() Returns the type of a property Inherited From: Property#getType Source: lib/parser/property.js, line 110 Returns: the type of this field Type string isArray() Returns true if the field is declared as an array type Inherited From: Property#isArray Source: lib/parser/property.js, line 161 Returns: true if the property is an array type Type boolean isOptional() Returns true if the field is optional Inherited From: Property#isOptional Source: lib/parser/property.js, line 118 Returns: true if the field is optional Type boolean isPrimitive() Returns true if this property is a primitive type. Inherited From: Property#isPrimitive Source: lib/parser/property.js, line 184 Returns: true if the property is a primitive type. Type boolean isTypeEnum() Returns true if the field is declared as an enumerated value Inherited From: Property#isTypeEnum Source: lib/parser/property.js, line 170 Returns: true if the property is an enumerated value Type boolean &lt;private&gt; process() Process the AST and build the model Inherited From: Property#process Source: lib/parser/property.js, line 58 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Inherited From: Property#toJSON Source: lib/parser/property.js, line 193 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns a string representation of this propertyÂ§ Source: lib/parser/relationshipdeclaration.js, line 56 Returns: the string version of the property. Type String &lt;private&gt; validate(classDecl) Validate the property Parameters: Name Type Description classDecl ClassDeclaration the class declaration of the property Overrides: Property#validate Source: lib/parser/relationshipdeclaration.js, line 40 Throws: InvalidModelException Ã— Search results Close "},"Resource.html":{"id":"Resource.html","title":"Class: Resource","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Resource Resource Resource is an instance that has a type. The type of the resource specifies a set of properites (which themselves have types). Type information in Concerto is used to validate the structure of Resource instances and for serialization. Resources are used in Concerto to represent Assets, Participants, Transactions and other domain classes that can be serialized for long-term persistent storage. new Resource(modelManager, ns, type, id) This constructor should not be called directly. Note: Only to be called by framework code. Applications should retrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: lib/model/resource.js, line 31 Extends Identifiable Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: Identifiable#accept Source: lib/model/identifiable.js, line 49 Returns: the result of visiting or null Type Object addArrayValue(propName, value) Adds a value to an array property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: lib/model/resource.js, line 63 &lt;private&gt; assignFieldDefaults() Sets the fields to their default values, based on the model Source: lib/model/resource.js, line 76 &lt;private&gt; getClassDeclaration() Returns the class declaration for this instance object. Source: lib/model/resource.js, line 113 Throws: - if the class or namespace for the instance is not declared Type Error Returns: - the class declaration for this Resource Type ClassDeclaration getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance. (namespace '.' type '#' identifier). Inherited From: Identifiable#getFullyQualifiedIdentifier Source: lib/model/identifiable.js, line 75 Returns: the fully qualified identifier of this instance Type string getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Inherited From: Identifiable#getFullyQualifiedType Source: lib/model/identifiable.js, line 91 Returns: The fully-qualified type name of this object Type string getIdentifier() Get the identifier of this instance Inherited From: Identifiable#getIdentifier Source: lib/model/identifiable.js, line 66 Returns: The identifier for this object Type string &lt;private&gt; getModelManager() Get the ModelManager for this instance Inherited From: Identifiable#getModelManager Source: lib/model/identifiable.js, line 58 Returns: The ModelManager for this object Type ModelManager getNamespace() Get the namespace of the instance. Inherited From: Identifiable#getNamespace Source: lib/model/identifiable.js, line 99 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Inherited From: Identifiable#getType Source: lib/model/identifiable.js, line 83 Returns: The type of this object Type string setPropertyValue(propName, value) Sets a property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: lib/model/resource.js, line 54 &lt;private&gt; toJSON() Overriden to prevent people accidentally converting a resource to JSON without using the Serializer. Source: lib/model/resource.js, line 136 toString() Returns the string representation of this class Overrides: Identifiable#toString Source: lib/model/resource.js, line 144 Returns: the string representation of the class Type String Ã— Search results Close "},"ResourceValidator.html":{"id":"ResourceValidator.html","title":"Class: ResourceValidator","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ResourceValidator ResourceValidator Validates a Resource or Field against the models defined in the ModelManager. This class is used with the Visitor pattern and visits the class declarations (etc) for the model, checking that the data in a Resource / Field is consistent with the model. The parameters for the visit method must contain the following properties: 'stack' - the TypedStack of objects being processed. It should start as [Resource] or [Field] 'rootResourceIdentifier' - the identifier of the resource being validated 'modelManager' - the ModelManager instance to use for type checking &lt;private&gt; new ResourceValidator() Source: lib/serializer/resourcevalidator.js, line 41 Methods &lt;private, static&gt; reportAbstractClass(classDeclaration) Throw a validation exception for an abstract class Parameters: Name Type Description classDeclaration ClassDeclaration the class declaration Source: lib/serializer/resourcevalidator.js, line 463 Throws: the validation exception Type ValidationException &lt;private, static&gt; reportFieldTypeViolation(id, propName, value, field) Throw a new error for a model violation. Parameters: Name Type Description id string the identifier of this instance. propName string the name of the field. value * the value of the field. field Field the field Source: lib/serializer/resourcevalidator.js, line 366 Throws: the exception Type ValidationException &lt;private, static&gt; reportInvalidEnumValue(id, field, obj) Throw a new error for a missing, but required field. Parameters: Name Type Description id string the identifier of this instance. field Field the field obj string the object value Source: lib/serializer/resourcevalidator.js, line 448 &lt;private, static&gt; reportInvalidFieldAssignment(resourceId, propName, obj, field) Throw a validation exception for an invalid field assignment Parameters: Name Type Description resourceId string the id of the resouce being validated propName string the name of the property that is being assigned obj * the Field field Field the Field Source: lib/serializer/resourcevalidator.js, line 496 Throws: the validation exception Type ValidationException &lt;private, static&gt; reportMissingRequiredProperty(id, field) Throw a new error for a missing, but required field. Parameters: Name Type Description id string the identifier of this instance. field Field the field/ Source: lib/serializer/resourcevalidator.js, line 433 &lt;private, static&gt; reportNotRelationshipViolation(id, relationshipDeclaration, value) Throw a new error for a model violation. Parameters: Name Type Description id string the identifier of this instance. relationshipDeclaration RelationshipDeclaration the declaration of the classs value Object the value of the field. Source: lib/serializer/resourcevalidator.js, line 418 &lt;private, static&gt; reportNotResouceViolation(id, classDeclaration, value) Throw a new error for a model violation. Parameters: Name Type Description id string the identifier of this instance. classDeclaration classDeclaration the declaration of the classs value Object the value of the field. Source: lib/serializer/resourcevalidator.js, line 402 &lt;private, static&gt; reportUndeclaredField(resourceId, propertyName, fullyQualifiedTypeName) Throw a validation exception for an abstract class Parameters: Name Type Description resourceId string the id of the resouce being validated propertyName string the name of the property that is not declared fullyQualifiedTypeName string the fully qualified type being validated Source: lib/serializer/resourcevalidator.js, line 478 Throws: the validation exception Type ValidationException &lt;private&gt; checkArray(obj, field, parameters) Check a Field that is declared as an Array. Parameters: Name Type Description obj Object the object being validated field Field the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 217 &lt;private&gt; checkEnum(obj, field, parameters) Check a Field that is declared as an Array. Parameters: Name Type Description obj Object the object being validated field Field the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 188 &lt;private&gt; checkItem(obj, field, parameters) Check a single (non-array) field. Parameters: Name Type Description obj Object the object being validated field Field the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 236 &lt;private&gt; checkRelationship(parameters, relationshipDeclaration, obj) Check a single relationship Parameters: Name Type Description parameters Object the parameter relationshipDeclaration relationshipDeclaration the object being visited obj Object the object being validated Source: lib/serializer/resourcevalidator.js, line 330 log(callSite, message) Parameters: Name Type Description callSite String the location message String the message to log. Source: lib/serializer/resourcevalidator.js, line 346 &lt;private&gt; visit(thing, parameters) Visitor design pattern. Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 50 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 100 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumDeclaration(enumDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumDeclaration EnumDeclaration the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 73 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 156 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationshipDeclaration(relationshipDeclaration, parameters) Visitor design pattern Parameters: Name Type Description relationshipDeclaration RelationshipDeclaration the object being visited parameters Object the parameter Source: lib/serializer/resourcevalidator.js, line 304 Returns: the result of visiting or null Type Object Ã— Search results Close "},"SecurityContext.html":{"id":"SecurityContext.html","title":"Class: SecurityContext","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: SecurityContext SecurityContext SecurityContext is used to authenticate and manage user credentials to the underlying blockchain fabric. new SecurityContext(user, password) Create the SecurityContext. Note: Only to be called by framework code. Applications should retrieve instances by calling login Parameters: Name Type Description user string The user identifier. password string The password. Source: lib/securitycontext.js, line 18 Methods getChaincodeID() Get the chaincode ID. Source: lib/securitycontext.js, line 72 Returns: The chaincode ID. Type string getEnrolledMember() Get the enrolled member. Source: lib/securitycontext.js, line 56 Returns: The enrolled member. Type hfc.Member getEventHub() Get the event hub. Source: lib/securitycontext.js, line 88 Returns: The event hub. Type hfc.EventHub getPassword() Get the user password Source: lib/securitycontext.js, line 48 Returns: The user password. Type string getUser() Get the current username. Source: lib/securitycontext.js, line 40 Returns: The username Type string setChaincodeID(chaincodeID) Set the chaincode ID. Parameters: Name Type Description chaincodeID string The chaincode ID. Source: lib/securitycontext.js, line 80 setEnrolledMember(enrolledMember) Set the enrolled member. Parameters: Name Type Description enrolledMember hfc.Member The enrolled member. Source: lib/securitycontext.js, line 64 setEventHub(eventHub) Set the event hub. Parameters: Name Type Description eventHub hfc.EventHub The event hub. Source: lib/securitycontext.js, line 96 Ã— Search results Close "},"SecurityException.html":{"id":"SecurityException.html","title":"Class: SecurityException","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: SecurityException SecurityException Class representing a security exception new SecurityException(message) Create the SecurityException. Parameters: Name Type Description message string The exception message. Source: lib/securityexception.js, line 19 Ã— Search results Close "},"Serializer.html":{"id":"Serializer.html","title":"Class: Serializer","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Serializer Serializer Serialize Resources instances to/from various formats for long-term storage (e.g. on the blockchain). new Serializer(factory, modelManager) Create a Serializer. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Parameters: Name Type Description factory Factory The Factory to use to create instances modelManager ModelManager The ModelManager to use for validation etc. Source: lib/serializer.js, line 27 Methods fromJSON(jsonObject, options) Create a Resource from a JavaScript Object representation. The JavaScript Object should have been created by calling the toJSON API. The Resource is populated based on the JavaScript object. Parameters: Name Type Description jsonObject Object The JavaScript Object for a Resource options Object the optional serialization options Source: lib/serializer.js, line 110 Returns: The new populated resource Type Resource toJSON(resource, options) Convert a Resource to a JavaScript object suitable for long-term peristent storage. Parameters: Name Type Description resource Resource The instance to convert to JSON options Object the optional serialization options. Properties Name Type Description validate boolean validate the structure of the Resource with its model prior to serialization (default to true) Source: lib/serializer.js, line 61 Throws: - throws an exception if resource is not an instance of Resource or fails validation. Type Error Returns: - The Javascript Object that represents the resource Type Object Ã— Search results Close "},"TestUtil.html":{"id":"TestUtil.html","title":"Class: TestUtil","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: TestUtil TestUtil A class containing test utilities for use in Concerto system tests. &lt;private&gt; new TestUtil() Source: systest/testutil.js, line 25 Methods &lt;static&gt; clearWorldState() Invoke the chain-code to clear all of the world state so that any test data is removed. Call in-between tests. Source: systest/testutil.js, line 172 Returns: - a promise that will be resolved once the chain-code has been invoked. Type Promise &lt;static&gt; getConcerto() Get a configured and connected instance of Concerto. Source: systest/testutil.js, line 148 Returns: - a configured and connected instance of Concerto. Type Concerto &lt;static&gt; getSecurityContext() Get a logged in security context for interacting with Concerto. Source: systest/testutil.js, line 159 Returns: - a logged in security context for interacting with Concerto. Type SecurityContext &lt;static&gt; setUp() Create a new Concerto object, connect, and deploy the chain-code. Source: systest/testutil.js, line 87 Returns: - a promise that wil be resolved with a configured and connected instance of Concerto. Type Promise &lt;static&gt; tearDown() Disconnect the Concerto object. Source: systest/testutil.js, line 133 Returns: - a promise that wil be resolved with a configured and connected instance of Concerto. Type Promise &lt;static&gt; waitForPort(hostname, port) Wait for the specified hostname to start listening on the specified port. Parameters: Name Type Description hostname string the hostname. port integer the port. Source: systest/testutil.js, line 34 Returns: - a promise that will be resolved when the specified hostname to start listening on the specified port. Type Promise &lt;static&gt; waitForPorts() Wait for the peer on the specified hostname and port to start listening on the specified port. Source: systest/testutil.js, line 72 Returns: - a promise that will be resolved when the peer has started listening on the specified port. Type Promise Ã— Search results Close "},"TransactionDeclaration.html":{"id":"TransactionDeclaration.html","title":"Class: TransactionDeclaration","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: TransactionDeclaration TransactionDeclaration Class representing the definition of an Transaction. &lt;private&gt; new TransactionDeclaration(modelFile, ast) Create an TransactionDeclaration. Parameters: Name Type Description modelFile ModelFile the ModelFile for this class ast Object The AST created by the parser Source: lib/parser/transactiondeclaration.js, line 19 Extends ClassDeclaration Methods &lt;private&gt; accept(visitor, parameters) Visitor design pattern Parameters: Name Type Description visitor Object the visitor parameters Object the parameter Inherited From: ClassDeclaration#accept Source: lib/parser/classdeclaration.js, line 57 Returns: the result of visiting or null Type Object getFullyQualifiedName() Returns the fully qualified name of this class. The name will include the namespace if present. Inherited From: ClassDeclaration#getFullyQualifiedName Source: lib/parser/classdeclaration.js, line 229 Returns: the fully-qualified name of this class Type string getIdentifierFieldName() Returns the name of the identifying field for this class. Note that the identifying field may come from a super type. Inherited From: ClassDeclaration#getIdentifierFieldName Source: lib/parser/classdeclaration.js, line 239 Returns: the name of the id field for this class Type string getModelFile() Returns the ModelFile that defines this class. Inherited From: ClassDeclaration#getModelFile Source: lib/parser/classdeclaration.js, line 66 Returns: the owning ModelFile Type ModelFile getName() Returns the short name of a class. This name does not include the namespace from the owning ModelFile. Inherited From: ClassDeclaration#getName Source: lib/parser/classdeclaration.js, line 219 Returns: the short name of this class Type string getOwnProperties() Returns the fields directly defined by this class. Inherited From: ClassDeclaration#getOwnProperties Source: lib/parser/classdeclaration.js, line 274 Returns: the array of fields Type Array.&lt;Property&gt; getOwnProperty(name) Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getOwnProperty Source: lib/parser/classdeclaration.js, line 258 Returns: the field definition or null if it does not exist. Type Property getProperties() Returns the properties defined in this class and all super classes. Inherited From: ClassDeclaration#getProperties Source: lib/parser/classdeclaration.js, line 328 Returns: the array of fields Type Array.&lt;Property&gt; getProperty(name) Returns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected. Parameters: Name Type Description name string the name of the field Inherited From: ClassDeclaration#getProperty Source: lib/parser/classdeclaration.js, line 305 Returns: the field, or null if it does not exist Type Property getSuperType() Returns the FQN of the super type for this class or null if this class does not have a super type. Inherited From: ClassDeclaration#getSuperType Source: lib/parser/classdeclaration.js, line 284 Returns: the FQN name of the super type or null Type string isAbstract() Returns true if this class is declared as abstract in the model file Inherited From: ClassDeclaration#isAbstract Source: lib/parser/classdeclaration.js, line 200 Returns: true if the class is abstract Type boolean isEnum() Returns true if this class is an enumeration. Inherited From: ClassDeclaration#isEnum Source: lib/parser/classdeclaration.js, line 209 Returns: true if the class is an enumerated type Type boolean &lt;private&gt; process() Process the AST and build the model Inherited From: ClassDeclaration#process Source: lib/parser/classdeclaration.js, line 76 Throws: InvalidModelException toJSON() Returns a new object representing this function declaration that is suitable for serializing as JSON. Inherited From: ClassDeclaration#toJSON Source: lib/parser/classdeclaration.js, line 359 Returns: A new object suitable for serializing as JSON. Type Object toString() Returns the string representation of this class Inherited From: ClassDeclaration#toString Source: lib/parser/classdeclaration.js, line 382 Returns: the string representation of the class Type String &lt;private&gt; validate() Semantic validation of the structure of this class. Subclasses should override this method to impose additional semantic constraints on the contents/relations of fields. Inherited From: ClassDeclaration#validate Source: lib/parser/classdeclaration.js, line 126 Throws: InvalidModelException Ã— Search results Close "},"TransactionRegistry.html":{"id":"TransactionRegistry.html","title":"Class: TransactionRegistry","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: TransactionRegistry TransactionRegistry The TransactionRegistry is used to store a set of transactions on the blockchain. new TransactionRegistry(id, name, modelManager, factory, serializer) Create an transaction registry. Note: Only to be called by framework code. Applications should retrieve instances from Concerto Parameters: Name Type Description id string The unique identifier of the transaction registry. name string The display name for the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: lib/transactionregistry.js, line 23 Extends Registry Methods &lt;protected, static&gt; addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) Add a new transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. name string The name of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: lib/transactionregistry.js, line 95 Returns: A promise that will be resolved with a TransactionRegistry instance representing the new transaction registry. Type Promise &lt;protected, static&gt; getAllTransactionRegistries(securityContext, modelManager, factory, serializer) Get a list of all existing transaction registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: lib/transactionregistry.js, line 36 Returns: A promise that will be resolved with a list of TransactionRegistry instances representing the transaction registries. Type Promise &lt;protected, static&gt; getTransactionRegistry(securityContext, id, modelManager, factory, serializer) Get an existing transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: lib/transactionregistry.js, line 65 Returns: A promise that will be resolved with a TransactionRegistry instance representing the transaction registry. Type Promise add(securityContext, id, data) Unsupported operation; you cannot update a transaction in a transaction registry. Call Concerto.submitTransaction to submit a transaction. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. Overrides: Registry#add Source: lib/transactionregistry.js, line 149 get(securityContext, id) Get a specific transaction in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction. Overrides: Registry#get Source: lib/transactionregistry.js, line 202 Returns: A promise that will be resolved with a Resource instance representing the transaction. Type Promise getAll(securityContext) Get all of the transactions in the registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. Overrides: Registry#getAll Source: lib/transactionregistry.js, line 183 Returns: A promise that will be resolved with an array of Resource instances representing the transactions. Type Promise remove(securityContext, id) Unsupported operation; you cannot remove a transaction from a transaction registry. This method will always throw an exception when called. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. Overrides: Registry#remove Source: lib/transactionregistry.js, line 172 update(securityContext, id, data) Unsupported operation; you cannot update a transaction in a transaction registry. This method will always throw an exception when called. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the resource. data string The data for the resource. Overrides: Registry#update Source: lib/transactionregistry.js, line 161 Ã— Search results Close "},"TypedStack.html":{"id":"TypedStack.html","title":"Class: TypedStack","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: TypedStack TypedStack Tracks a stack of typed instances. The type information is used to detect overflow / underflow bugs by the caller. It also performs basic sanity checking on push/pop to make detecting bugs easier. &lt;private&gt; new TypedStack(resource) Create the Stack with the resource at the head. Parameters: Name Type Description resource Object the resource to be put at the head of the stack Source: lib/serializer/typedstack.js, line 21 Methods clear() Clears the stack Source: lib/serializer/typedstack.js, line 88 peek(expectedType) Peek the top of the stack Parameters: Name Type Description expectedType Object the type that should be the result of pop Source: lib/serializer/typedstack.js, line 65 Returns: the result of peek Type Object pop(expectedType) Push a new object. Parameters: Name Type Description expectedType Object the type that should be the result of pop Source: lib/serializer/typedstack.js, line 55 Returns: the result of pop Type Object push(obj, expectedType) Push a new object. Parameters: Name Type Description obj Object the object being visited expectedType Object the expected type of the object being pushed Source: lib/serializer/typedstack.js, line 37 Ã— Search results Close "},"TypescriptVisitor.html":{"id":"TypescriptVisitor.html","title":"Class: TypescriptVisitor","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: TypescriptVisitor TypescriptVisitor Convert the contents of a ModelManager to Go Lang code. All generated code is placed into the 'main' package. Set a fileWriter property (instance of FileWriter) on the parameters object to control where the generated code is written to disk. &lt;private&gt; new TypescriptVisitor() Source: lib/codegen/typescript/typescriptvisitor.js, line 33 Methods &lt;private&gt; toTsType(type) Converts a Concerto type to a Typescript type. Primitive types are converted everything else is passed through unchanged. Parameters: Name Type Description type string the concerto type Source: lib/codegen/typescript/typescriptvisitor.js, line 212 Returns: the corresponding type in Typescript Type string &lt;private&gt; visit(thing, parameters) Visitor design pattern Parameters: Name Type Description thing Object the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 41 Returns: the result of visiting or null Type Object &lt;private&gt; visitClassDeclaration(classDeclaration, parameters) Visitor design pattern Parameters: Name Type Description classDeclaration ClassDeclaration the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 129 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumDeclaration(enumDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumDeclaration EnumDeclaration the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 109 Returns: the result of visiting or null Type Object &lt;private&gt; visitEnumValueDeclaration(enumValueDeclaration, parameters) Visitor design pattern Parameters: Name Type Description enumValueDeclaration EnumValueDeclaration the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 181 Returns: the result of visiting or null Type Object &lt;private&gt; visitField(field, parameters) Visitor design pattern Parameters: Name Type Description field Field the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 163 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelFile(modelFile, parameters) Visitor design pattern Parameters: Name Type Description modelFile ModelFile the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 85 Returns: the result of visiting or null Type Object &lt;private&gt; visitModelManager(modelManager, parameters) Visitor design pattern Parameters: Name Type Description modelManager ModelManager the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 70 Returns: the result of visiting or null Type Object &lt;private&gt; visitRelationship(relationship, parameters) Visitor design pattern Parameters: Name Type Description relationship Relationship the object being visited parameters Object the parameter Source: lib/codegen/typescript/typescriptvisitor.js, line 193 Returns: the result of visiting or null Type Object Ã— Search results Close "},"Util.html":{"id":"Util.html","title":"Class: Util","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Util Util Internal Utility Class &lt;private&gt; new Util() Source: lib/util.js, line 27 Methods &lt;static&gt; deployChainCode(securityContext, chaincodePath, functionName, args, force) Submit an deploy request to the chain-code Parameters: Name Type Description securityContext SecurityContext The user's security context chaincodePath string The path of the chain-code to deploy. functionName string The name of the function to call. args Array.&lt;string&gt; The arguments to pass to the function being called. force boolean Force a new instance of the chain-code to deploy. Source: lib/util.js, line 150 Returns: - A promise that will be resolved with the value returned by the chain-code function. Type Promise &lt;static&gt; invokeChainCode(securityContext, functionName, args) Submit an invoke request to the chain-code Parameters: Name Type Description securityContext SecurityContext The user's security context functionName string The name of the function to call. args Array.&lt;string&gt; The arguments to pass to the function being called. Source: lib/util.js, line 94 Returns: - A promise that will be resolved with the value returned by the chain-code function. Type Promise &lt;static&gt; isNull(obj) Returns true if the typeof the object === 'undefined' or the object === null. Parameters: Name Type Description obj Object the object to be tested Source: lib/util.js, line 136 Returns: true if the object is null or undefined Type boolean &lt;static&gt; queryChainCode(securityContext, functionName, args) Submit a query request to the chain-code Parameters: Name Type Description securityContext SecurityContext The user's security context functionName string The name of the function to call. args Array.&lt;string&gt; The arguments to pass to the function being called. Source: lib/util.js, line 50 Returns: - A promise that will be resolved with the value returned by the chain-code function. Type Promise &lt;static&gt; securityCheck(securityContext) Internal method to check the security context Parameters: Name Type Description securityContext SecurityContext The user's security context Source: lib/util.js, line 34 Throws: if the user context is invalid Type SecurityException Ã— Search results Close "},"ValidatedResource.html":{"id":"ValidatedResource.html","title":"Class: ValidatedResource","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ValidatedResource ValidatedResource ValidatedResource is a Resource that can validate that property changes (or the whole instance) do not violate the structure of the type information associated with the instance. new ValidatedResource(modelManager, ns, type, id, resourceValidator) This constructor should not be called directly. Use the Factory class to create instances. Note: Only to be called by framework code. Applications should retrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. resourceValidator ResourceValidator The validator to use for this instance Source: lib/model/validatedresource.js, line 22 Extends ValidatedResource Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Overrides: ValidatedResource#addArrayValue Source: lib/model/validatedresource.js, line 76 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Overrides: ValidatedResource#setPropertyValue Source: lib/model/validatedresource.js, line 49 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Overrides: ValidatedResource#validate Source: lib/model/validatedresource.js, line 110 Throws: - if the instance if invalid with respect to the model Type Error Ã— Search results Close "},"ValidationException.html":{"id":"ValidationException.html","title":"Class: ValidationException","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: ValidationException ValidationException Exception thrown when a resource fails to model against the model new ValidationException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: lib/serializer/validationexception.js, line 18 Ã— Search results Close "},"Writer.html":{"id":"Writer.html","title":"Class: Writer","body":" IBM Concerto Modules ibm-concerto Classes AssetDeclarationAssetRegistryBaseExceptionClassDeclarationConcertoEnumDeclarationEnumValueDeclarationFactoryFieldFileWriterFunctionDeclarationGoLangVisitorIdentifiableIllegalModelExceptionJSONGeneratorJSONPopulatorJSONWriterModelFileModelManagerModelRegistryModelUtilParseExceptionParticipantDeclarationPlantUMLVisitorPropertyRegistryRelationshipRelationshipDeclarationResourceResourceValidatorSecurityContextSecurityExceptionSerializerTestUtilTransactionDeclarationTransactionRegistryTypedStackTypescriptVisitorUtilValidatedResourceValidationExceptionWriter Global directoryExistsensureDirectoryExistencefindCommentBeforegetMethodArgumentsgetReturnTypegetVisibilityprocessDirectoryprocessFiletoUMLFilename Class: Writer Writer Writer buffers text to be written in memory. It handles simple indentation and tracks the number of lines written. &lt;private&gt; new Writer() Create a FileWriter. Source: lib/codegen/writer.js, line 18 Methods clearBuffer() Empties the underyling buffer and resets the line count. Source: lib/codegen/writer.js, line 105 getBuffer() Returns the text that has been buffered in this Writer. Source: lib/codegen/writer.js, line 98 Returns: the buffered text. Type string getLineCount() Returns the number of lines that have been written to the buffer. Source: lib/codegen/writer.js, line 62 Returns: the number of lines written to the buffer. Type int write(msg) Append text to the buffer (no automatic newline). The text may contain newline, and these will increment the linesWritten counter. Parameters: Name Type Description msg string the text to write Source: lib/codegen/writer.js, line 85 writeBeforeLine(tabs, text) Writes text to the start of the buffer Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/writer.js, line 35 writeIndented(tabs, text) Append text to the buffer, prepending tabs Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/writer.js, line 72 writeLine(tabs, text) Append text to the buffer Parameters: Name Type Description tabs int the number of tabs to use text string the text to write Source: lib/codegen/writer.js, line 49 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
